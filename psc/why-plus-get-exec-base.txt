
main.elf:     file format elf32-littlearm
main.elf
architecture: arm, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00000000

Program Header:
    LOAD off    0x00008000 vaddr 0x00000000 paddr 0x00000000 align 2**15
         filesz 0x000032e0 memsz 0x000036e0 flags rwx
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000031d0  00000000  00000000  00008000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000110  000031d0  000031d0  0000b1d0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000400  000032e0  000032e0  0000b2e0  2**0
                  ALLOC
  3 .stack        00004000  000036e0  000036e0  0000b2e0  2**0
                  CONTENTS
  4 .debug_line   00000fee  00000000  00000000  0000f2e0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   0000346d  00000000  00000000  000102ce  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000dee  00000000  00000000  0001373b  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000220  00000000  00000000  00014530  2**3
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    000023ae  00000000  00000000  00014750  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_pubnames 000003d8  00000000  00000000  00016afe  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_pubtypes 0000035f  00000000  00000000  00016ed6  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00000ea6  00000000  00000000  00017235  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  000006e0  00000000  00000000  000180dc  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 000002d8  00000000  00000000  000187bc  2**0
                  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    d  .text	00000000 .text
000031d0 l    d  .data	00000000 .data
000032e0 l    d  .bss	00000000 .bss
000036e0 l    d  .stack	00000000 .stack
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l       .text	00000000 __load_addr
000000bc l       .text	00000000 __link_addr
00000068 l       .text	00000000 __bss_clear_loop
000000a0 l       .text	00000000 _loop
000076e0 l       .stack	00000000 __stack_top
00000253 l       .text	00000000 __arm_mode_fmt
00000257 l       .text	00000000 __thumb_mode_fmt
000001e8 l       .text	00000000 __pabt_fmt
0000025d l       .text	00000000 __abt_pc_fmt
0000028c l       .text	00000000 __new_line__
0000012c l       .text	00000000 __pabt_loop
00000213 l       .text	00000000 __dabt_fmt
0000026a l       .text	00000000 __abt_arm_instruction
0000027b l       .text	00000000 __abt_thumb_instruction
0000023a l       .text	00000000 __dabt_addr_fmt
000001b0 l       .text	00000000 __dabt_loop
00000318 l       .text	00000000 __skip_psc
0000045e l       .text	00000000 __arm_mode_fmt
00000462 l       .text	00000000 __thumb_mode_fmt
0000042c l       .text	00000000 __undef_fmt
00000468 l       .text	00000000 __undef_pc_fmt
00000476 l       .text	00000000 __undef_arm_instruction
00000486 l       .text	00000000 __undef_thumb_instruction
0000040c l       .text	00000000 __undef_loop
00000640 l       .text	00000000 __div_0__
00000910 l       .text	00000000 Ldiv0
00000000 l    df *ABS*	00000000 main.c
00000000 l    df *ABS*	00000000 am1808exp.c
00000000 l    df *ABS*	00000000 am18x_conf.c
00000000 l    df *ABS*	00000000 am18x_psc.c
000009c8 l     F .text	00000024 module_to_psc
00002dc4 l     O .text	00000010 CSWTCH.3
00002dd4 l     O .text	00000004 CSWTCH.6
00000000 l    df *ABS*	00000000 am18x_syscfg.c
00000000 l    df *ABS*	00000000 am18x_uart.c
00000b8c l     F .text	00000054 __field_xget
00002dd8 l     O .text	00000010 CSWTCH.1
00002de8 l     O .text	0000000c CSWTCH.6
00000000 l    df *ABS*	00000000 arm920t.c
00000000 l    df *ABS*	00000000 auxlib.c
000032e0 l     O .bss	00000400 prbuf.881
00000000 l    df *ABS*	00000000 ctype.c
00000000 l    df *ABS*	00000000 uart.c
00000000 l    df *ABS*	00000000 vsprintf.c
00001378 l     F .text	0000004c simple_guess_base
000013c4 l     F .text	00000044 skip_atoi
00001408 l     F .text	000000e0 put_dec_trunc
000014e8 l     F .text	0000037c number.clone.0
00001864 l     F .text	000000b0 string.clone.2
000032d0 l     O .data	00000001 warn.1744
000031b0 l     O .text	00000000 _GLOBAL_OFFSET_TABLE_
000012f8 g     F .text	00000028 putchar
000004b8 g       .text	00000000 arm_intr_enable
000003a0 g       .text	00000000 HandleUndef
00002500 g     F .text	00000018 vscnprintf
00000a9c g     F .text	00000034 syscfg_kick
00000290 g       .text	00000000 output_a_char
0000256c g     F .text	00000014 vsprintf
000004d0 g       .text	00000000 arm_mmu_enable
00001a78 g     F .text	00000034 simple_strtoll
00000bec g     F .text	00000034 uart_init_conf
00000920 g     F .text	0000001c __aeabi_llsr
00000a5c g     F .text	00000040 psc_get_state
00002518 g     F .text	00000024 snprintf
000019a4 g     F .text	00000028 simple_strtol
000009b4 g     F .text	00000014 low_level_init
00001150 g     F .text	00000054 debug_buf
000031d0 g       .text	00000000 __got_end
000009ec g     F .text	00000070 psc_state_transition
0000253c g     F .text	00000030 scnprintf
000025a8 g     F .text	0000053c vsscanf
0000106c g     F .text	00000024 memcpy
000012c4 g     F .text	00000034 __putchar
00000fdc g     F .text	0000002c puts
00000650 g     F .text	0000009c __udivsi3
00001c20 g     F .text	000008e0 vsnprintf
000000e0 g       .text	00000000 HandlePrefetchAbort
000036e0 g       *ABS*	00000000 __bss_end
00002b10 g     O .text	00000004 f_osc
000010b4 g     F .text	00000028 strnlen
00001b24 g     F .text	00000038 strict_strtol
000004a0 g       .text	00000000 arm_intr_disable
000004e8 g       .text	00000000 arm_mmu_disable
000031b0 g       .text	00000000 __got_start
00000920 g     F .text	0000001c __lshrdi3
00000500 g       .text	00000000 __do_div64
000006ec g     F .text	000000a0 __umodsi3
00003180 g     O .text	00000028 state_kv
0000078c g     F .text	000000cc __aeabi_idiv
00000be0 g     F .text	0000000c uart_input_clock_frequency
00000fb8 g     F .text	00000008 arm_read_cp15_fault_address
00001268 g     F .text	0000005c uart_init
00000000 g       .text	00000000 _start
00001be0 g     F .text	00000040 strict_strtoll
00001348 g     F .text	00000030 peekchar
00000020 g       .text	00000000 __got_size
00000d54 g     F .text	0000000c uart_read_byte
00001aac g     F .text	00000078 strict_strtoul
00002ae4 g     F .text	00000024 sscanf
00001008 g     F .text	00000044 printk
000000c4 g       .text	00000000 stack_top
000031d0 g     O .data	00000100 _ctype
000000a4 g       .text	00000000 __reloc_got
000032e0 g       *ABS*	00000000 __bss_start
0000104c g     F .text	00000020 memset
0000093c g     F .text	00000078 main
00000630 g       .text	00000000 __div0
00000650 g     F .text	0000009c __aeabi_uidiv
00001320 g     F .text	00000028 getchar
00000d60 g     F .text	00000090 arm_mmu_show_id_code
0000078c g     F .text	000000cc __divsi3
000010dc g     F .text	00000044 strcmp
00000fc0 g     F .text	0000001c delay
00000130  w      .text	00000000 HandleDataAbort
000011a4 g     F .text	000000c4 debug_line
00002580 g     F .text	00000028 sprintf
00000ad0 g     F .text	000000bc syscfg_pinmux
00000c20 g     F .text	000000ec uart_set_conf
00001b5c g     F .text	00000084 strict_strtoull
00001914 g     F .text	00000090 simple_strtoul
00003000 g     O .text	00000180 psc_kv
00000df0 g     F .text	000001c8 arm_mmu_show_cache_type
00000858 g     F .text	000000b8 __modsi3
00001090 g     F .text	00000024 strlen
00001120 g     F .text	00000030 strchr
00000d0c g     F .text	0000003c uart_state
000019cc g     F .text	000000ac simple_strtoull
00000d48 g     F .text	0000000c uart_write_byte



Disassembly of section .text:

00000000 <_start>:
		.endm

		.global	_start
_start:
__load_addr:
		NOP
       0:	e1a00000 	nop			; (mov r0, r0)
		MRS	r0, cpsr
       4:	e10f0000 	mrs	r0, CPSR
		BIC	r0, r0, #0x1F       @ CLEAR MODES
       8:	e3c0001f 	bic	r0, r0, #31
		ORR	r0, r0, #0x13       @ SET SUPERVISOR mode
       c:	e3800013 	orr	r0, r0, #19
		ORR	r0, r0, #0xC0       @ Disable FIQ and IRQ
      10:	e38000c0 	orr	r0, r0, #192	; 0xc0
		MSR	cpsr_cxsf, r0
      14:	e12ff000 	msr	CPSR_fsxc, r0
		NOP
      18:	e1a00000 	nop			; (mov r0, r0)

		@ Set the IVT to low memory, leave MMU & caches disabled
		MRC	p15, #0, r0, c1, c0, #0
      1c:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}

00000020 <__got_size>:
		BIC	r0, r0, #0x00002300
      20:	e3c00c23 	bic	r0, r0, #8960	; 0x2300
		BIC	r0, r0, #0x00000087
      24:	e3c00087 	bic	r0, r0, #135	; 0x87
		ORR	r0, r0, #0x00000002
      28:	e3800002 	orr	r0, r0, #2
		ORR	r0, r0, #0x00001000
      2c:	e3800a01 	orr	r0, r0, #4096	; 0x1000
		MCR	p15, #0, r0, c1, c0, #0
      30:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
		NOP
      34:	e1a00000 	nop			; (mov r0, r0)

		@ retrive image offset (load address - link address)
		LDR	R0, __link_addr
      38:	e59f007c 	ldr	r0, [pc, #124]	; bc <__link_addr>
		ADR	R9, __load_addr
      3c:	e24f9044 	sub	r9, pc, #68	; 0x44
		SUB	R9, R9, R0
      40:	e0499000 	sub	r9, r9, r0

		@ Setup the stack pointer
		LDR	r0, stack_top
      44:	e59f0078 	ldr	r0, [pc, #120]	; c4 <stack_top>
		ADD	sp, r0, r9
      48:	e080d009 	add	sp, r0, r9
		SUB	sp, sp, #4
      4c:	e24dd004 	sub	sp, sp, #4
		BIC	sp, sp, #7
      50:	e3cdd007 	bic	sp, sp, #7

		@ Clear BSS area
		.extern	__bss_start
		.extern	__bss_end
		MOV	R0, #0
      54:	e3a00000 	mov	r0, #0
		ldr_fix R1, __bss_start
      58:	e59f1068 	ldr	r1, [pc, #104]	; c8 <stack_top+0x4>
      5c:	e0811009 	add	r1, r1, r9
		ldr_fix R2, __bss_end
      60:	e59f2064 	ldr	r2, [pc, #100]	; cc <stack_top+0x8>
      64:	e0822009 	add	r2, r2, r9

00000068 <__bss_clear_loop>:
__bss_clear_loop:
		STR	R0, [R1], #4
      68:	e4810004 	str	r0, [r1], #4
		CMP	R1, R2
      6c:	e1510002 	cmp	r1, r2
		BLO	__bss_clear_loop
      70:	3afffffc 	bcc	68 <__bss_clear_loop>

		.extern	arm_intr_disable
		BL	arm_intr_disable
      74:	eb000109 	bl	4a0 <arm_intr_disable>

		ldr_fix SL, __load_addr
      78:	e59fa050 	ldr	sl, [pc, #80]	; d0 <stack_top+0xc>
      7c:	e08aa009 	add	sl, sl, r9

		@ relocation got to untranslated address
		.global	__got_start
		.global	__got_end
		MOV	R0, R9
      80:	e1a00009 	mov	r0, r9
		ldr_fix	R1, __got_start
      84:	e59f1048 	ldr	r1, [pc, #72]	; d4 <stack_top+0x10>
      88:	e0811009 	add	r1, r1, r9
		ldr_fix R2, __got_end
      8c:	e59f2044 	ldr	r2, [pc, #68]	; d8 <stack_top+0x14>
      90:	e0822009 	add	r2, r2, r9
		BL	__reloc_got
      94:	eb000002 	bl	a4 <__reloc_got>

		.extern	low_level_init
		BL	low_level_init
      98:	eb000245 	bl	9b4 <low_level_init>

		@ Call to main entry point
		.extern	main
		bl	main
      9c:	eb000226 	bl	93c <main>

000000a0 <_loop>:

_loop:
		B	_loop
      a0:	eafffffe 	b	a0 <_loop>

000000a4 <__reloc_got>:

		@ Add every element in [r1,r2) with r0
		.global	__reloc_got
__reloc_got:
		LDR	R4, [R1]
      a4:	e5914000 	ldr	r4, [r1]
		ADD	R4, R4, R0
      a8:	e0844000 	add	r4, r4, r0
		STR	R4, [R1], #4
      ac:	e4814004 	str	r4, [r1], #4
		CMP	R1, R2
      b0:	e1510002 	cmp	r1, r2
		BLO	__reloc_got
      b4:	3afffffa 	bcc	a4 <__reloc_got>
		MOV	PC, LR
      b8:	e1a0f00e 	mov	pc, lr

000000bc <__link_addr>:
      bc:	00000000 	.word	0x00000000
      c0:	00000020 	.word	0x00000020

000000c4 <stack_top>:
      c4:	000076e0 	.word	0x000076e0
      c8:	000032e0 	.word	0x000032e0
      cc:	000036e0 	.word	0x000036e0
      d0:	00000000 	.word	0x00000000
      d4:	000031b0 	.word	0x000031b0
      d8:	000031d0 	.word	0x000031d0
      dc:	00000000 	.word	0x00000000

000000e0 <HandlePrefetchAbort>:
	@	R13 = SP = SP_abt
	@	R14 = LR = LR_abt
	@	SPSR = SPSR_abt = CPSR(saved)
	.func	pabt
HandlePrefetchAbort:
	PUSH	{R0, R1, V1-V3, LR}
      e0:	e92d4073 	push	{r0, r1, r4, r5, r6, lr}

	MRS	V1, SPSR
      e4:	e14f4000 	mrs	r4, SPSR
	ANDS	V3, V1, #XPSR_F_Thumb
      e8:	e2146020 	ands	r6, r4, #32
	LDREQ	R1, =__arm_mode_fmt
      ec:	059f10cc 	ldreq	r1, [pc, #204]	; 1c0 <__dabt_loop+0x10>
	SUBEQ	V2, LR, #4
      f0:	024e5004 	subeq	r5, lr, #4
	LDRNE	R1, =__thumb_mode_fmt
      f4:	159f10c8 	ldrne	r1, [pc, #200]	; 1c4 <__dabt_loop+0x14>
	SUBNE	V2, LR, #4
      f8:	124e5004 	subne	r5, lr, #4

	LDR	V1, =printk
      fc:	e59f40c4 	ldr	r4, [pc, #196]	; 1c8 <__dabt_loop+0x18>

	LDR	R0, =__pabt_fmt
     100:	e59f00c4 	ldr	r0, [pc, #196]	; 1cc <__dabt_loop+0x1c>
	MOV	LR, PC
     104:	e1a0e00f 	mov	lr, pc
	BX	V1
     108:	e12fff14 	bx	r4

	LDR	R0, =__abt_pc_fmt
     10c:	e59f00bc 	ldr	r0, [pc, #188]	; 1d0 <__dabt_loop+0x20>
	MOV	R1, V2
     110:	e1a01005 	mov	r1, r5
	MOV	LR, PC
     114:	e1a0e00f 	mov	lr, pc
	BX	V1
     118:	e12fff14 	bx	r4

	LDR	R0, =__new_line__
     11c:	e59f00b0 	ldr	r0, [pc, #176]	; 1d4 <__dabt_loop+0x24>
2:
	MOV	LR, PC
     120:	e1a0e00f 	mov	lr, pc
	BX	V1
     124:	e12fff14 	bx	r4
	POP	{R0, R1, V1-V3, LR}
     128:	e8bd4073 	pop	{r0, r1, r4, r5, r6, lr}

0000012c <__pabt_loop>:
	@SUBS	PC, LR, #4
__pabt_loop:
	B	__pabt_loop
     12c:	eafffffe 	b	12c <__pabt_loop>

00000130 <HandleDataAbort>:
	@	R13 = SP = SP_abt
	@	R14 = LR = LR_abt
	@	SPSR = SPSR_abt = CPSR(saved)
	.func	dabt
HandleDataAbort:
	PUSH	{R0, R1, V1-V3, LR}
     130:	e92d4073 	push	{r0, r1, r4, r5, r6, lr}

	MRS	V1, SPSR
     134:	e14f4000 	mrs	r4, SPSR
	ANDS	V3, V1, #XPSR_F_Thumb
     138:	e2146020 	ands	r6, r4, #32
	LDREQ	R1, =__arm_mode_fmt
     13c:	059f107c 	ldreq	r1, [pc, #124]	; 1c0 <__dabt_loop+0x10>
	SUBEQ	V2, LR, #8
     140:	024e5008 	subeq	r5, lr, #8
	LDRNE	R1, =__thumb_mode_fmt
     144:	159f1078 	ldrne	r1, [pc, #120]	; 1c4 <__dabt_loop+0x14>
	SUBNE	V2, LR, #8
     148:	124e5008 	subne	r5, lr, #8

	LDR	V1, =printk
     14c:	e59f4074 	ldr	r4, [pc, #116]	; 1c8 <__dabt_loop+0x18>

	LDR	R0, =__dabt_fmt
     150:	e59f0080 	ldr	r0, [pc, #128]	; 1d8 <__dabt_loop+0x28>
	MOV	LR, PC
     154:	e1a0e00f 	mov	lr, pc
	BX	V1
     158:	e12fff14 	bx	r4

	LDR	R0, =__abt_pc_fmt
     15c:	e59f006c 	ldr	r0, [pc, #108]	; 1d0 <__dabt_loop+0x20>
	MOV	R1, V2
     160:	e1a01005 	mov	r1, r5
	MOV	LR, PC
     164:	e1a0e00f 	mov	lr, pc
	BX	V1
     168:	e12fff14 	bx	r4

	MOVS	V3, V3
     16c:	e1b06006 	movs	r6, r6
	BNE	1f
     170:	1a000002 	bne	180 <HandleDataAbort+0x50>
0:
	LDR	R0, =__abt_arm_instruction
     174:	e59f0060 	ldr	r0, [pc, #96]	; 1dc <__dabt_loop+0x2c>
	LDR	R1, [V2, #0]
     178:	e5951000 	ldr	r1, [r5]
	B	2f
     17c:	ea000002 	b	18c <HandleDataAbort+0x5c>
1:
	LDR	R0, =__abt_thumb_instruction
     180:	e59f0058 	ldr	r0, [pc, #88]	; 1e0 <__dabt_loop+0x30>
	LDRH	R1, [V2, #0]
     184:	e1d510b0 	ldrh	r1, [r5]
	B	2f
     188:	eaffffff 	b	18c <HandleDataAbort+0x5c>
2:
	MOV	LR, PC
     18c:	e1a0e00f 	mov	lr, pc
	BX	V1
     190:	e12fff14 	bx	r4

	BL	arm_read_cp15_fault_address
     194:	eb000387 	bl	fb8 <arm_read_cp15_fault_address>
	MOV	R1, R0
     198:	e1a01000 	mov	r1, r0
	LDR	R0, =__dabt_addr_fmt
     19c:	e59f0040 	ldr	r0, [pc, #64]	; 1e4 <__dabt_loop+0x34>
	MOV	LR, PC
     1a0:	e1a0e00f 	mov	lr, pc
	BX	V1
     1a4:	e12fff14 	bx	r4

	POP	{R0, R1, V1-V3, LR}
     1a8:	e8bd4073 	pop	{r0, r1, r4, r5, r6, lr}
	@SUBS	PC, LR, #8
	SUBS	PC, LR, #4
     1ac:	e25ef004 	subs	pc, lr, #4

000001b0 <__dabt_loop>:
__dabt_loop:
	B	__dabt_loop
     1b0:	eafffffe 	b	1b0 <__dabt_loop>
     1b4:	e1a00000 	nop			; (mov r0, r0)
     1b8:	e1a00000 	nop			; (mov r0, r0)
     1bc:	e1a00000 	nop			; (mov r0, r0)
     1c0:	00000253 	.word	0x00000253
     1c4:	00000257 	.word	0x00000257
     1c8:	00001008 	.word	0x00001008
     1cc:	000001e8 	.word	0x000001e8
     1d0:	0000025d 	.word	0x0000025d
     1d4:	0000028c 	.word	0x0000028c
     1d8:	00000213 	.word	0x00000213
     1dc:	0000026a 	.word	0x0000026a
     1e0:	0000027b 	.word	0x0000027b
     1e4:	0000023a 	.word	0x0000023a

000001e8 <__pabt_fmt>:
     1e8:	2a2a2a0a 	.word	0x2a2a2a0a
     1ec:	202a2a2a 	.word	0x202a2a2a
     1f0:	66657250 	.word	0x66657250
     1f4:	68637465 	.word	0x68637465
     1f8:	6f624120 	.word	0x6f624120
     1fc:	2d207472 	.word	0x2d207472
     200:	25202d2d 	.word	0x25202d2d
     204:	6f6d2073 	.word	0x6f6d2073
     208:	2a206564 	.word	0x2a206564
     20c:	2a2a2a2a 	.word	0x2a2a2a2a
     210:	0a2a      	.short	0x0a2a
     212:	00          	.byte	0x00

00000213 <__dabt_fmt>:
     213:	0a          	.byte	0x0a
     214:	2a2a2a2a 	.word	0x2a2a2a2a
     218:	44202a2a 	.word	0x44202a2a
     21c:	20617461 	.word	0x20617461
     220:	726f6241 	.word	0x726f6241
     224:	2d2d2074 	.word	0x2d2d2074
     228:	7325202d 	.word	0x7325202d
     22c:	646f6d20 	.word	0x646f6d20
     230:	2a2a2065 	.word	0x2a2a2065
     234:	2a2a2a2a 	.word	0x2a2a2a2a
     238:	000a      	.short	0x000a

0000023a <__dabt_addr_fmt>:
     23a:	4109      	.short	0x4109
     23c:	74726f62 	.word	0x74726f62
     240:	64646120 	.word	0x64646120
     244:	73736572 	.word	0x73736572
     248:	30203d20 	.word	0x30203d20
     24c:	382e2578 	.word	0x382e2578
     250:	0a58      	.short	0x0a58
     252:	00          	.byte	0x00

00000253 <__arm_mode_fmt>:
     253:	61          	.byte	0x61
     254:	6d72      	.short	0x6d72
     256:	00          	.byte	0x00

00000257 <__thumb_mode_fmt>:
     257:	74          	.byte	0x74
     258:	626d7568 	.word	0x626d7568
     25c:	00          	.byte	0x00

0000025d <__abt_pc_fmt>:
     25d:	09          	.byte	0x09
     25e:	4350      	.short	0x4350
     260:	30203d20 	.word	0x30203d20
     264:	382e2578 	.word	0x382e2578
     268:	0058      	.short	0x0058

0000026a <__abt_arm_instruction>:
     26a:	0920      	.short	0x0920
     26c:	5d43505b 	.word	0x5d43505b
     270:	30203d20 	.word	0x30203d20
     274:	382e2578 	.word	0x382e2578
     278:	0a58      	.short	0x0a58
     27a:	00          	.byte	0x00

0000027b <__abt_thumb_instruction>:
     27b:	20          	.byte	0x20
     27c:	43505b09 	.word	0x43505b09
     280:	203d205d 	.word	0x203d205d
     284:	2e257830 	.word	0x2e257830
     288:	000a5834 	.word	0x000a5834

0000028c <__new_line__>:
     28c:	000a      	.short	0x000a
     28e:	0000      	.short	0x0000

00000290 <output_a_char>:
		.section .text
		.arm
		.global output_a_char
output_a_char:
		@ kick off
		LDR	R0, =SYSCFG0_BASE
     290:	e59f00e4 	ldr	r0, [pc, #228]	; 37c <__skip_psc+0x64>
		LDR	R1, =KICK0R_UNLOCK
     294:	e59f10e4 	ldr	r1, [pc, #228]	; 380 <__skip_psc+0x68>
		LDR	R2, =KICK1R_UNLOCK
     298:	e59f20e4 	ldr	r2, [pc, #228]	; 384 <__skip_psc+0x6c>
		STR	R1, [R0, #0x38]
     29c:	e5801038 	str	r1, [r0, #56]	; 0x38
		STR	R2, [R0, #0x3C]
     2a0:	e580203c 	str	r2, [r0, #60]	; 0x3c

		@ uart module state transition
		LDR	R0, =PSC1_BASE
     2a4:	e59f00dc 	ldr	r0, [pc, #220]	; 388 <__skip_psc+0x70>
		LDR	R1, =MDCTLx_STATE_Enable
     2a8:	e3a01003 	mov	r1, #3

1:		// Wait until PTSTAT == 0
		LDR	R3, [R0, #0x128]
     2ac:	e5903128 	ldr	r3, [r0, #296]	; 0x128
		TST	R3, #1
     2b0:	e3130001 	tst	r3, #1
		BNE	1b
     2b4:	1afffffc 	bne	2ac <output_a_char+0x1c>

		// if MDSTATx[UART2] != MDCTLx_STATE_Enable
		MOV	R3, #UART2_PSC_NR
     2b8:	e3a0300d 	mov	r3, #13
		ADD	R3, R3, #0x200
     2bc:	e2833c02 	add	r3, r3, #512	; 0x200
		LDR	R2, [R0, R3, LSL #2]
     2c0:	e7902103 	ldr	r2, [r0, r3, lsl #2]
		AND	R2, R2, #0x1F
     2c4:	e202201f 	and	r2, r2, #31
		SUBS	R2, R2, R1
     2c8:	e0522001 	subs	r2, r2, r1
		BEQ	__skip_psc
     2cc:	0a000011 	beq	318 <__skip_psc>

		// R2 = MDCTLx[UART2]
		MOV	R3, #UART2_PSC_NR
     2d0:	e3a0300d 	mov	r3, #13
		ADD	R3, R3, #0x280
     2d4:	e2833d0a 	add	r3, r3, #640	; 0x280
		LDR	R2, [R0, R3, LSL #2]
     2d8:	e7902103 	ldr	r2, [r0, r3, lsl #2]

		// MDCTLx[UART2] |= R1
		BIC	R2, R2, #0x7
     2dc:	e3c22007 	bic	r2, r2, #7
		ORR	R2, R2, R1
     2e0:	e1822001 	orr	r2, r2, r1
		STR	R2, [R0, R3, LSL #2]
     2e4:	e7802103 	str	r2, [r0, r3, lsl #2]

		// PTCMD = 1
		LDR	R3, [R0, #0x120]
     2e8:	e5903120 	ldr	r3, [r0, #288]	; 0x120
		ORR	R3, R3, #1
     2ec:	e3833001 	orr	r3, r3, #1
		STR	R3, [R0, #0x120]
     2f0:	e5803120 	str	r3, [r0, #288]	; 0x120

2:		// Wait until PTSTAT == 0
		LDR	R3, [R0, #0x128]
     2f4:	e5903128 	ldr	r3, [r0, #296]	; 0x128
		TST	R3, #1
     2f8:	e3130001 	tst	r3, #1
		BNE	2b
     2fc:	1afffffc 	bne	2f4 <output_a_char+0x64>

3:		// Wait until MDSTATx[UART2] == MDCTLx_STATE_Enable
		MOV	R3, #UART2_PSC_NR
     300:	e3a0300d 	mov	r3, #13
		ADD	R3, R3, #0x200
     304:	e2833c02 	add	r3, r3, #512	; 0x200
		LDR	R2, [R0, R3, LSL #2]
     308:	e7902103 	ldr	r2, [r0, r3, lsl #2]
		AND	R2, R2, #0x1F
     30c:	e202201f 	and	r2, r2, #31
		SUBS	R2, R2, R1
     310:	e0522001 	subs	r2, r2, r1
		BNE	3b
     314:	1afffff9 	bne	300 <output_a_char+0x70>

00000318 <__skip_psc>:
__skip_psc:

		@ AM1808 UART2 pinmux setting
		// R2 = PINMUXx[4]
		LDR	R0, =SYSCFG0_BASE
     318:	e59f005c 	ldr	r0, [pc, #92]	; 37c <__skip_psc+0x64>
		LDR	R3, =4
     31c:	e3a03004 	mov	r3, #4
		ADD	R3, R3, #0x48
     320:	e2833048 	add	r3, r3, #72	; 0x48
		LDR	R2, [R0, R3, LSL #2]
     324:	e7902103 	ldr	r2, [r0, r3, lsl #2]

		// PINMUXx[4] = XX22XXXX
		BIC	R2, R2, #0x00FF0000
     328:	e3c228ff 	bic	r2, r2, #16711680	; 0xff0000
		ORR	R2, R2, #0x00220000
     32c:	e3822822 	orr	r2, r2, #2228224	; 0x220000
		STR	R2, [R0, R3, LSL #2]
     330:	e7802103 	str	r2, [r0, r3, lsl #2]

		@ AM1808 UART setting
		LDR	R0, =UART2_BASE
     334:	e59f0050 	ldr	r0, [pc, #80]	; 38c <__skip_psc+0x74>

		LDR	R1, =0x6003
     338:	e59f1050 	ldr	r1, [pc, #80]	; 390 <__skip_psc+0x78>
		STR	R1, [R0, #0x30]
     33c:	e5801030 	str	r1, [r0, #48]	; 0x30

		LDR	R1, =0x03
     340:	e3a01003 	mov	r1, #3
		STR	R1, [R0, #0x0C]
     344:	e580100c 	str	r1, [r0, #12]

		LDR	R1, =0x08
     348:	e3a01008 	mov	r1, #8
		STR	R1, [R0, #0x20]
     34c:	e5801020 	str	r1, [r0, #32]
		MOV	R1, #0x00
     350:	e3a01000 	mov	r1, #0
		STR	R1, [R0, #0x24]
     354:	e5801024 	str	r1, [r0, #36]	; 0x24

		LDR	R1, =0x01
     358:	e3a01001 	mov	r1, #1
		STR	R1, [R0, #0x34]
     35c:	e5801034 	str	r1, [r0, #52]	; 0x34

		@ wait buffer empty
		LDR	R0, =UART2_BASE
     360:	e59f0024 	ldr	r0, [pc, #36]	; 38c <__skip_psc+0x74>
4:
		LDR	R1, [R0, #0x14]
     364:	e5901014 	ldr	r1, [r0, #20]
		TST	R1, #(0x1 << 5)
     368:	e3110020 	tst	r1, #32
		BEQ	4b
     36c:	0afffffc 	beq	364 <__skip_psc+0x4c>

		@ output a char to uart
		LDR	R1, ='X'
     370:	e3a01058 	mov	r1, #88	; 0x58
		STR	R1, [R0, #0x00]
     374:	e5801000 	str	r1, [r0]

		MOV	PC, LR
     378:	e1a0f00e 	mov	pc, lr
     37c:	01c14000 	.word	0x01c14000
     380:	83e70b13 	.word	0x83e70b13
     384:	95a4f1e0 	.word	0x95a4f1e0
     388:	01e27000 	.word	0x01e27000
     38c:	01d0d000 	.word	0x01d0d000
     390:	00006003 	.word	0x00006003
     394:	00000000 	.word	0x00000000
     398:	00000000 	.word	0x00000000
     39c:	00000000 	.word	0x00000000

000003a0 <HandleUndef>:
	@	now in Undefined Instruction Mode
	@	R13 = SP = SP_und
	@	R14 = LR = LR_und
	@	SPSR = SPSR_und = CPSR(saved)
HandleUndef:
	PUSH	{R0, R1, V1-V3, LR}
     3a0:	e92d4073 	push	{r0, r1, r4, r5, r6, lr}

	MRS	V1, SPSR
     3a4:	e14f4000 	mrs	r4, SPSR
	ANDS	V3, V1, #XPSR_F_Thumb
     3a8:	e2146020 	ands	r6, r4, #32
	LDREQ	R1, =__arm_mode_fmt
     3ac:	059f105c 	ldreq	r1, [pc, #92]	; 410 <__undef_loop+0x4>
	SUBEQ	V2, LR, #4
     3b0:	024e5004 	subeq	r5, lr, #4
	LDRNE	R1, =__thumb_mode_fmt
     3b4:	159f1058 	ldrne	r1, [pc, #88]	; 414 <__undef_loop+0x8>
	SUBNE	V2, LR, #2
     3b8:	124e5002 	subne	r5, lr, #2
	LDR	R0, =__undef_fmt
     3bc:	e59f0054 	ldr	r0, [pc, #84]	; 418 <__undef_loop+0xc>
	LDR	V1, =printk
     3c0:	e59f4054 	ldr	r4, [pc, #84]	; 41c <__undef_loop+0x10>
	MOV	LR, PC
     3c4:	e1a0e00f 	mov	lr, pc
	BX	V1
     3c8:	e12fff14 	bx	r4

	LDR	R0, =__undef_pc_fmt
     3cc:	e59f004c 	ldr	r0, [pc, #76]	; 420 <__undef_loop+0x14>
	MOV	R1, V2
     3d0:	e1a01005 	mov	r1, r5
	MOV	LR, PC
     3d4:	e1a0e00f 	mov	lr, pc
	BX	V1
     3d8:	e12fff14 	bx	r4

	MOVS	V3, V3
     3dc:	e1b06006 	movs	r6, r6
	BNE	1f
     3e0:	1a000002 	bne	3f0 <HandleUndef+0x50>
0:
	LDR	R0, =__undef_arm_instruction
     3e4:	e59f0038 	ldr	r0, [pc, #56]	; 424 <__undef_loop+0x18>
	LDR	R1, [V2, #0]
     3e8:	e5951000 	ldr	r1, [r5]
	B	2f
     3ec:	ea000002 	b	3fc <HandleUndef+0x5c>
1:
	LDR	R0, =__undef_thumb_instruction
     3f0:	e59f0030 	ldr	r0, [pc, #48]	; 428 <__undef_loop+0x1c>
	LDRH	R1, [V2, #0]
     3f4:	e1d510b0 	ldrh	r1, [r5]
	B	2f
     3f8:	eaffffff 	b	3fc <HandleUndef+0x5c>
2:
	MOV	LR, PC
     3fc:	e1a0e00f 	mov	lr, pc
	BX	V1
     400:	e12fff14 	bx	r4

	POP	{R0, R1, V1-V3, LR}
     404:	e8bd4073 	pop	{r0, r1, r4, r5, r6, lr}
	MOVS	PC, LR
     408:	e1b0f00e 	movs	pc, lr

0000040c <__undef_loop>:
__undef_loop:
	B	__undef_loop
     40c:	eafffffe 	b	40c <__undef_loop>
     410:	0000045e 	.word	0x0000045e
     414:	00000462 	.word	0x00000462
     418:	0000042c 	.word	0x0000042c
     41c:	00001008 	.word	0x00001008
     420:	00000468 	.word	0x00000468
     424:	00000476 	.word	0x00000476
     428:	00000486 	.word	0x00000486

0000042c <__undef_fmt>:
     42c:	2a2a2a0a 	.word	0x2a2a2a0a
     430:	202a2a2a 	.word	0x202a2a2a
     434:	65646e55 	.word	0x65646e55
     438:	656e6966 	.word	0x656e6966
     43c:	6e492064 	.word	0x6e492064
     440:	75727473 	.word	0x75727473
     444:	6f697463 	.word	0x6f697463
     448:	2d2d206e 	.word	0x2d2d206e
     44c:	7325202d 	.word	0x7325202d
     450:	646f6d20 	.word	0x646f6d20
     454:	2a2a2065 	.word	0x2a2a2065
     458:	2a2a2a2a 	.word	0x2a2a2a2a
     45c:	000a      	.short	0x000a

0000045e <__arm_mode_fmt>:
     45e:	7261      	.short	0x7261
     460:	006d      	.short	0x006d

00000462 <__thumb_mode_fmt>:
     462:	6874      	.short	0x6874
     464:	00626d75 	.word	0x00626d75

00000468 <__undef_pc_fmt>:
     468:	20435009 	.word	0x20435009
     46c:	7830203d 	.word	0x7830203d
     470:	58382e25 	.word	0x58382e25
     474:	0020      	.short	0x0020

00000476 <__undef_arm_instruction>:
     476:	5b09      	.short	0x5b09
     478:	205d4350 	.word	0x205d4350
     47c:	7830203d 	.word	0x7830203d
     480:	58382e25 	.word	0x58382e25
     484:	000a      	.short	0x000a

00000486 <__undef_thumb_instruction>:
     486:	5b09      	.short	0x5b09
     488:	205d4350 	.word	0x205d4350
     48c:	7830203d 	.word	0x7830203d
     490:	58342e25 	.word	0x58342e25
     494:	000a      	.short	0x000a
     496:	0000      	.short	0x0000
     498:	e1a00000 	nop			; (mov r0, r0)
     49c:	e1a00000 	nop			; (mov r0, r0)

000004a0 <arm_intr_disable>:
		.SECTION .text, "ax"
		.arm

		.GLOBAL	arm_intr_disable
arm_intr_disable:
		PUSH	{R0}
     4a0:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
		MRS	R0, CPSR
     4a4:	e10f0000 	mrs	r0, CPSR
		ORR	R0, R0, # XPSR_F_IRQ | XPSR_F_FIQ
     4a8:	e38000c0 	orr	r0, r0, #192	; 0xc0
		MSR	CPSR_c, R0
     4ac:	e121f000 	msr	CPSR_c, r0
		POP	{R0}
     4b0:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
		MOV	PC, LR
     4b4:	e1a0f00e 	mov	pc, lr

000004b8 <arm_intr_enable>:

		.GLOBAL	arm_intr_enable
arm_intr_enable:
		PUSH	{R0}
     4b8:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
		MRS	R0, CPSR
     4bc:	e10f0000 	mrs	r0, CPSR
		BIC	R0, R0, # XPSR_F_IRQ | XPSR_F_FIQ
     4c0:	e3c000c0 	bic	r0, r0, #192	; 0xc0
		MSR	CPSR_c, R0
     4c4:	e121f000 	msr	CPSR_c, r0
		POP	{R0}
     4c8:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
		MOV	PC, LR
     4cc:	e1a0f00e 	mov	pc, lr

000004d0 <arm_mmu_enable>:

		@ enable MMU
		.GLOBAL arm_mmu_enable
arm_mmu_enable:
		PUSH	{R1}
     4d0:	e52d1004 	push	{r1}		; (str r1, [sp, #-4]!)
		MRC	p15, 0, R1, C1, C0, 0
     4d4:	ee111f10 	mrc	15, 0, r1, cr1, cr0, {0}
		ORR	R1, #0x1
     4d8:	e3811001 	orr	r1, r1, #1
		MCR	p15, 0, R1, C1, C0, 0
     4dc:	ee011f10 	mcr	15, 0, r1, cr1, cr0, {0}
		@ !!! make here one instruction between mcr and mov
		POP	{R1}
     4e0:	e49d1004 	pop	{r1}		; (ldr r1, [sp], #4)
		MOV	PC, LR
     4e4:	e1a0f00e 	mov	pc, lr

000004e8 <arm_mmu_disable>:

		@ disable MMU
		.GLOBAL arm_mmu_disable
arm_mmu_disable:
		PUSH	{R1}
     4e8:	e52d1004 	push	{r1}		; (str r1, [sp, #-4]!)
		MRC	p15, 0, R1, C1, C0, 0
     4ec:	ee111f10 	mrc	15, 0, r1, cr1, cr0, {0}
		BIC	R1, R1, #0x5
     4f0:	e3c11005 	bic	r1, r1, #5
		MCR	p15, 0, R1, C1, C0, 0
     4f4:	ee011f10 	mcr	15, 0, r1, cr1, cr0, {0}
		@ !!! make here one instruction between mcr and mov
		POP	{R1}
     4f8:	e49d1004 	pop	{r1}		; (ldr r1, [sp], #4)
		MOV	PC, LR
     4fc:	e1a0f00e 	mov	pc, lr

00000500 <__do_div64>:
.GLOBAL __do_div64
__do_div64:


	@ Test for easy paths first.
	subs	ip, r4, #1
     500:	e254c001 	subs	ip, r4, #1
	bls	9f			@ divisor is 0 or 1
     504:	9a00003f 	bls	608 <__do_div64+0x108>
	tst	ip, r4
     508:	e11c0004 	tst	ip, r4
	beq	8f			@ divisor is power of 2
     50c:	0a000028 	beq	5b4 <__do_div64+0xb4>

	@ See if we need to handle upper 32-bit result.
	cmp	xh, r4
     510:	e1510004 	cmp	r1, r4
	mov	yh, #0
     514:	e3a03000 	mov	r3, #0
	blo	3f
     518:	3a00000c 	bcc	550 <__do_div64+0x50>

	@ Align divisor with upper part of dividend.
	@ The aligned divisor is stored in yl preserving the original.
	@ The bit position is stored in ip.

	mov	yl, r4
     51c:	e1a02004 	mov	r2, r4
	mov	ip, #1
     520:	e3a0c001 	mov	ip, #1
1:	cmp	yl, #0x80000000
     524:	e3520102 	cmp	r2, #-2147483648	; 0x80000000
	cmpcc	yl, xh
     528:	31520001 	cmpcc	r2, r1
	movcc	yl, yl, lsl #1
     52c:	31a02082 	lslcc	r2, r2, #1
	movcc	ip, ip, lsl #1
     530:	31a0c08c 	lslcc	ip, ip, #1
	bcc	1b
     534:	3afffffa 	bcc	524 <__do_div64+0x24>

	@ The division loop for needed upper bit positions.
 	@ Break out early if dividend reaches 0.
2:	cmp	xh, yl
     538:	e1510002 	cmp	r1, r2
	orrcs	yh, yh, ip
     53c:	2183300c 	orrcs	r3, r3, ip
	subcss	xh, xh, yl
     540:	20511002 	subscs	r1, r1, r2
	movnes	ip, ip, lsr #1
     544:	11b0c0ac 	lsrsne	ip, ip, #1
	mov	yl, yl, lsr #1
     548:	e1a020a2 	lsr	r2, r2, #1
	bne	2b
     54c:	1afffff9 	bne	538 <__do_div64+0x38>

	@ See if we need to handle lower 32-bit result.
3:	cmp	xh, #0
     550:	e3510000 	cmp	r1, #0
	mov	yl, #0
     554:	e3a02000 	mov	r2, #0
	cmpeq	xl, r4
     558:	01500004 	cmpeq	r0, r4
	movlo	xh, xl
     55c:	31a01000 	movcc	r1, r0
	movlo	pc, lr
     560:	31a0f00e 	movcc	pc, lr

	@ The division loop for lower bit positions.
	@ Here we shift remainer bits leftwards rather than moving the
	@ divisor for comparisons, considering the carry-out bit as well.
	mov	ip, #0x80000000
     564:	e3a0c102 	mov	ip, #-2147483648	; 0x80000000
4:	movs	xl, xl, lsl #1
     568:	e1b00080 	lsls	r0, r0, #1
	adcs	xh, xh, xh
     56c:	e0b11001 	adcs	r1, r1, r1
	beq	6f
     570:	0a000005 	beq	58c <__do_div64+0x8c>
	cmpcc	xh, r4
     574:	31510004 	cmpcc	r1, r4
5:	orrcs	yl, yl, ip
     578:	2182200c 	orrcs	r2, r2, ip
	subcs	xh, xh, r4
     57c:	20411004 	subcs	r1, r1, r4
	movs	ip, ip, lsr #1
     580:	e1b0c0ac 	lsrs	ip, ip, #1
	bne	4b
     584:	1afffff7 	bne	568 <__do_div64+0x68>
	mov	pc, lr
     588:	e1a0f00e 	mov	pc, lr

	@ The top part of remainder became zero.  If carry is set
	@ (the 33th bit) this is a false positive so resume the loop.
	@ Otherwise, if lower part is also null then we are done.
6:	bcs	5b
     58c:	2afffff9 	bcs	578 <__do_div64+0x78>
	cmp	xl, #0
     590:	e3500000 	cmp	r0, #0
	moveq	pc, lr
     594:	01a0f00e 	moveq	pc, lr

	@ We still have remainer bits in the low part.  Bring them up.

7:	movs	xl, xl, lsl #1
     598:	e1b00080 	lsls	r0, r0, #1
	mov	ip, ip, lsr #1
     59c:	e1a0c0ac 	lsr	ip, ip, #1
	bcc	7b
     5a0:	3afffffc 	bcc	598 <__do_div64+0x98>

	@ Current remainder is now 1.  It is worthless to compare with
	@ divisor at this point since divisor can not be smaller than 3 here.
	@ If possible, branch for another shift in the division loop.
	@ If no bit position left then we are done.
	movs	ip, ip, lsr #1
     5a4:	e1b0c0ac 	lsrs	ip, ip, #1
	mov	xh, #1
     5a8:	e3a01001 	mov	r1, #1
	bne	4b
     5ac:	1affffed 	bne	568 <__do_div64+0x68>
	mov	pc, lr
     5b0:	e1a0f00e 	mov	pc, lr

8:	@ Division by a power of 2: determine what that divisor order is
	@ then simply shift values around

	mov	yl, r4
     5b4:	e1a02004 	mov	r2, r4
	cmp	r4, #(1 << 16)
     5b8:	e3540801 	cmp	r4, #65536	; 0x10000
	mov	ip, #0
     5bc:	e3a0c000 	mov	ip, #0
	movhs	yl, yl, lsr #16
     5c0:	21a02822 	lsrcs	r2, r2, #16
	movhs	ip, #16
     5c4:	23a0c010 	movcs	ip, #16

	cmp	yl, #(1 << 8)
     5c8:	e3520c01 	cmp	r2, #256	; 0x100
	movhs	yl, yl, lsr #8
     5cc:	21a02422 	lsrcs	r2, r2, #8
	addhs	ip, ip, #8
     5d0:	228cc008 	addcs	ip, ip, #8

	cmp	yl, #(1 << 4)
     5d4:	e3520010 	cmp	r2, #16
	movhs	yl, yl, lsr #4
     5d8:	21a02222 	lsrcs	r2, r2, #4
	addhs	ip, ip, #4
     5dc:	228cc004 	addcs	ip, ip, #4

	cmp	yl, #(1 << 2)
     5e0:	e3520004 	cmp	r2, #4
	addhi	ip, ip, #3
     5e4:	828cc003 	addhi	ip, ip, #3
	addls	ip, ip, yl, lsr #1
     5e8:	908cc0a2 	addls	ip, ip, r2, lsr #1

	mov	yh, xh, lsr ip
     5ec:	e1a03c31 	lsr	r3, r1, ip
	mov	yl, xl, lsr ip
     5f0:	e1a02c30 	lsr	r2, r0, ip
	rsb	ip, ip, #32
     5f4:	e26cc020 	rsb	ip, ip, #32
	orr	yl, yl, xh, lsl ip
     5f8:	e1822c11 	orr	r2, r2, r1, lsl ip
	mov	xh, xl, lsl ip
     5fc:	e1a01c10 	lsl	r1, r0, ip
	mov	xh, xh, lsr ip
     600:	e1a01c31 	lsr	r1, r1, ip
	mov	pc, lr
     604:	e1a0f00e 	mov	pc, lr

	@ eq -> division by 1: obvious enough...
9:	moveq	yl, xl
     608:	01a02000 	moveq	r2, r0
	moveq	yh, xh
     60c:	01a03001 	moveq	r3, r1
	moveq	xh, #0
     610:	03a01000 	moveq	r1, #0
	moveq	pc, lr
     614:	01a0f00e 	moveq	pc, lr

	@ Division by 0:
	str	lr, [sp, #-8]!
     618:	e52de008 	str	lr, [sp, #-8]!
	bl	__div0
     61c:	eb000003 	bl	630 <__div0>

	@ as wrong as it could be...
	mov	yl, #0
     620:	e3a02000 	mov	r2, #0
	mov	yh, #0
     624:	e3a03000 	mov	r3, #0
	mov	xh, #0
     628:	e3a01000 	mov	r1, #0
	ldr	pc, [sp], #8
     62c:	e49df008 	ldr	pc, [sp], #8

00000630 <__div0>:
ENDPROC(__do_div64)

	.global	__div0
	.extern	puts
__div0:
	push	{lr}
     630:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	adr	r0, __div_0__
     634:	e28f0004 	add	r0, pc, #4
	bl	puts
     638:	eb000267 	bl	fdc <puts>
	pop	{pc}
     63c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

00000640 <__div_0__>:
     640:	69766964 	.word	0x69766964
     644:	6e6f6973 	.word	0x6e6f6973
     648:	20796220 	.word	0x20796220
     64c:	0a30      	.short	0x0a30
     64e:	00          	.byte	0x00
     64f:	00          	.byte	0x00

00000650 <__aeabi_uidiv>:
	cmp	\divisor, #(1 << 2)
	addhi	\order, \order, #3
	addls	\order, \order, \divisor, lsr #1

#endif

     650:	e2512001 	subs	r2, r1, #1
.endm
     654:	01a0f00e 	moveq	pc, lr

     658:	3a0000ac 	bcc	910 <Ldiv0>

     65c:	e1500001 	cmp	r0, r1
.macro ARM_MOD_BODY dividend, divisor, order, spare
     660:	9a00001a 	bls	6d0 <__aeabi_uidiv+0x80>

     664:	e1110002 	tst	r1, r2
#if __LINUX_ARM_ARCH__ >= 5
     668:	0a00001b 	beq	6dc <__aeabi_uidiv+0x8c>

	clz	\order, \divisor
     66c:	e16f3f11 	clz	r3, r1
     670:	e16f2f10 	clz	r2, r0
     674:	e0432002 	sub	r2, r3, r2
     678:	e3a03001 	mov	r3, #1
     67c:	e1a01211 	lsl	r1, r1, r2
     680:	e1a03213 	lsl	r3, r3, r2
     684:	e3a02000 	mov	r2, #0
	blo	1b

	mov	\result, #0

#endif

     688:	e1500001 	cmp	r0, r1
     68c:	20400001 	subcs	r0, r0, r1
     690:	21822003 	orrcs	r2, r2, r3
     694:	e15000a1 	cmp	r0, r1, lsr #1
     698:	204000a1 	subcs	r0, r0, r1, lsr #1
     69c:	218220a3 	orrcs	r2, r2, r3, lsr #1
     6a0:	e1500121 	cmp	r0, r1, lsr #2
     6a4:	20400121 	subcs	r0, r0, r1, lsr #2
     6a8:	21822123 	orrcs	r2, r2, r3, lsr #2
     6ac:	e15001a1 	cmp	r0, r1, lsr #3
     6b0:	204001a1 	subcs	r0, r0, r1, lsr #3
     6b4:	218221a3 	orrcs	r2, r2, r3, lsr #3
     6b8:	e3500000 	cmp	r0, #0
     6bc:	11b03223 	lsrsne	r3, r3, #4
     6c0:	11a01221 	lsrne	r1, r1, #4
     6c4:	1affffef 	bne	688 <__aeabi_uidiv+0x38>

#if __LINUX_ARM_ARCH__ >= 5

	clz	\order, \divisor
	clz	\spare, \dividend
	sub	\order, \order, \spare
     6c8:	e1a00002 	mov	r0, r2
	mov	\divisor, \divisor, lsl \order
     6cc:	e1a0f00e 	mov	pc, lr

#else
     6d0:	03a00001 	moveq	r0, #1

     6d4:	13a00000 	movne	r0, #0
	mov	\order, #0
     6d8:	e1a0f00e 	mov	pc, lr

	@ Unless the divisor is very big, shift it up in multiples of
     6dc:	e16f2f11 	clz	r2, r1
     6e0:	e262201f 	rsb	r2, r2, #31
	@ four bits, since this is the amount of unwinding in the main
     6e4:	e1a00230 	lsr	r0, r0, r2
	@ division loop.  Continue shifting until the divisor is 
     6e8:	e1a0f00e 	mov	pc, lr

000006ec <__umodsi3>:
1:	cmp	\divisor, #0x10000000
	cmplo	\divisor, \dividend
	movlo	\divisor, \divisor, lsl #4
	addlo	\order, \order, #4
	blo	1b

     6ec:	e2512001 	subs	r2, r1, #1
	@ For very big divisors, we must shift it a bit at a time, or
     6f0:	3a000086 	bcc	910 <Ldiv0>
	@ we will be in danger of overflowing.
     6f4:	11500001 	cmpne	r0, r1
1:	cmp	\divisor, #0x80000000
     6f8:	03a00000 	moveq	r0, #0
	cmplo	\divisor, \dividend
     6fc:	81110002 	tsthi	r1, r2
	movlo	\divisor, \divisor, lsl #1
     700:	00000002 	andeq	r0, r0, r2
	addlo	\order, \order, #1
     704:	91a0f00e 	movls	pc, lr
	blo	1b

     708:	e16f2f11 	clz	r2, r1
     70c:	e16f3f10 	clz	r3, r0
     710:	e0422003 	sub	r2, r2, r3
     714:	e1a01211 	lsl	r1, r1, r2
#endif

     718:	e2522003 	subs	r2, r2, #3
     71c:	ba00000e 	blt	75c <__umodsi3+0x70>
     720:	e1500001 	cmp	r0, r1
     724:	20400001 	subcs	r0, r0, r1
     728:	e15000a1 	cmp	r0, r1, lsr #1
     72c:	204000a1 	subcs	r0, r0, r1, lsr #1
     730:	e1500121 	cmp	r0, r1, lsr #2
     734:	20400121 	subcs	r0, r0, r1, lsr #2
     738:	e15001a1 	cmp	r0, r1, lsr #3
     73c:	204001a1 	subcs	r0, r0, r1, lsr #3
     740:	e3500001 	cmp	r0, #1
     744:	e1a01221 	lsr	r1, r1, #4
     748:	a2522004 	subsge	r2, r2, #4
     74c:	aafffff3 	bge	720 <__umodsi3+0x34>
     750:	e3120003 	tst	r2, #3
     754:	13300000 	teqne	r0, #0
     758:	0a00000a 	beq	788 <__umodsi3+0x9c>
     75c:	e3720002 	cmn	r2, #2
     760:	ba000006 	blt	780 <__umodsi3+0x94>
     764:	0a000002 	beq	774 <__umodsi3+0x88>
     768:	e1500001 	cmp	r0, r1
     76c:	20400001 	subcs	r0, r0, r1
     770:	e1a010a1 	lsr	r1, r1, #1
     774:	e1500001 	cmp	r0, r1
     778:	20400001 	subcs	r0, r0, r1
     77c:	e1a010a1 	lsr	r1, r1, #1
     780:	e1500001 	cmp	r0, r1
     784:	20400001 	subcs	r0, r0, r1
     788:	e1a0f00e 	mov	pc, lr

0000078c <__aeabi_idiv>:
	@ Do comparisons in batch of 4 first.
	subs	\order, \order, #3		@ yes, 3 is intended here
	blt	2f

1:	cmp	\dividend, \divisor
	subhs	\dividend, \dividend, \divisor
     78c:	e3510000 	cmp	r1, #0
	cmp	\dividend, \divisor,  lsr #1
     790:	e020c001 	eor	ip, r0, r1
	subhs	\dividend, \dividend, \divisor, lsr #1
     794:	0a00005d 	beq	910 <Ldiv0>
	cmp	\dividend, \divisor,  lsr #2
     798:	42611000 	rsbmi	r1, r1, #0
	subhs	\dividend, \dividend, \divisor, lsr #2
     79c:	e2512001 	subs	r2, r1, #1
	cmp	\dividend, \divisor,  lsr #3
     7a0:	0a00001f 	beq	824 <__aeabi_idiv+0x98>
	subhs	\dividend, \dividend, \divisor, lsr #3
     7a4:	e1b03000 	movs	r3, r0
	cmp	\dividend, #1
     7a8:	42603000 	rsbmi	r3, r0, #0
	mov	\divisor, \divisor, lsr #4
     7ac:	e1530001 	cmp	r3, r1
	subges	\order, \order, #4
     7b0:	9a00001e 	bls	830 <__aeabi_idiv+0xa4>
	bge	1b
     7b4:	e1110002 	tst	r1, r2

     7b8:	0a000020 	beq	840 <__aeabi_idiv+0xb4>
	tst	\order, #3
	teqne	\dividend, #0
     7bc:	e16f2f11 	clz	r2, r1
     7c0:	e16f0f13 	clz	r0, r3
     7c4:	e0420000 	sub	r0, r2, r0
     7c8:	e3a02001 	mov	r2, #1
     7cc:	e1a01011 	lsl	r1, r1, r0
     7d0:	e1a02012 	lsl	r2, r2, r0
     7d4:	e3a00000 	mov	r0, #0
	blo	1b

	mov	\result, #0

#endif

     7d8:	e1530001 	cmp	r3, r1
     7dc:	20433001 	subcs	r3, r3, r1
     7e0:	21800002 	orrcs	r0, r0, r2
     7e4:	e15300a1 	cmp	r3, r1, lsr #1
     7e8:	204330a1 	subcs	r3, r3, r1, lsr #1
     7ec:	218000a2 	orrcs	r0, r0, r2, lsr #1
     7f0:	e1530121 	cmp	r3, r1, lsr #2
     7f4:	20433121 	subcs	r3, r3, r1, lsr #2
     7f8:	21800122 	orrcs	r0, r0, r2, lsr #2
     7fc:	e15301a1 	cmp	r3, r1, lsr #3
     800:	204331a1 	subcs	r3, r3, r1, lsr #3
     804:	218001a2 	orrcs	r0, r0, r2, lsr #3
     808:	e3530000 	cmp	r3, #0
     80c:	11b02222 	lsrsne	r2, r2, #4
     810:	11a01221 	lsrne	r1, r1, #4
     814:	1affffef 	bne	7d8 <__aeabi_idiv+0x4c>
	bge	1b

	tst	\order, #3
	teqne	\dividend, #0
	beq	5f

     818:	e35c0000 	cmp	ip, #0
	@ Either 1, 2 or 3 comparison/substractions are left.
     81c:	42600000 	rsbmi	r0, r0, #0
2:	cmn	\order, #2
     820:	e1a0f00e 	mov	pc, lr
	blt	4f
	beq	3f
     824:	e13c0000 	teq	ip, r0
	cmp	\dividend, \divisor
     828:	42600000 	rsbmi	r0, r0, #0
	subhs	\dividend, \dividend, \divisor
     82c:	e1a0f00e 	mov	pc, lr
	mov	\divisor,  \divisor,  lsr #1
3:	cmp	\dividend, \divisor
     830:	33a00000 	movcc	r0, #0
	subhs	\dividend, \dividend, \divisor
     834:	01a00fcc 	asreq	r0, ip, #31
	mov	\divisor,  \divisor,  lsr #1
     838:	03800001 	orreq	r0, r0, #1
4:	cmp	\dividend, \divisor
     83c:	e1a0f00e 	mov	pc, lr
	subhs	\dividend, \dividend, \divisor
5:
     840:	e16f2f11 	clz	r2, r1
     844:	e262201f 	rsb	r2, r2, #31
.endm

     848:	e35c0000 	cmp	ip, #0

     84c:	e1a00233 	lsr	r0, r3, r2
ENTRY(__udivsi3)
     850:	42600000 	rsbmi	r0, r0, #0
ENTRY(__aeabi_uidiv)
     854:	e1a0f00e 	mov	pc, lr

00000858 <__modsi3>:
	subs	r2, r1, #1
	moveq	pc, lr
	bcc	Ldiv0
	cmp	r0, r1
	bls	11f
	tst	r1, r2
     858:	e3510000 	cmp	r1, #0
	beq	12f
     85c:	0a00002b 	beq	910 <Ldiv0>

     860:	42611000 	rsbmi	r1, r1, #0
	ARM_DIV_BODY r0, r1, r2, r3
     864:	e1b0c000 	movs	ip, r0

     868:	42600000 	rsbmi	r0, r0, #0
	mov	r0, r2
     86c:	e2512001 	subs	r2, r1, #1
	mov	pc, lr
     870:	11500001 	cmpne	r0, r1

     874:	03a00000 	moveq	r0, #0
11:	moveq	r0, #1
     878:	81110002 	tsthi	r1, r2
	movne	r0, #0
     87c:	00000002 	andeq	r0, r0, r2
	mov	pc, lr
     880:	9a00001f 	bls	904 <__modsi3+0xac>

12:	ARM_DIV2_ORDER r1, r2
     884:	e16f2f11 	clz	r2, r1
     888:	e16f3f10 	clz	r3, r0
     88c:	e0422003 	sub	r2, r2, r3
     890:	e1a01211 	lsl	r1, r1, r2
	movlo	\divisor, \divisor, lsl #1
	addlo	\order, \order, #1
	blo	1b

#endif

     894:	e2522003 	subs	r2, r2, #3
     898:	ba00000e 	blt	8d8 <__modsi3+0x80>
     89c:	e1500001 	cmp	r0, r1
     8a0:	20400001 	subcs	r0, r0, r1
     8a4:	e15000a1 	cmp	r0, r1, lsr #1
     8a8:	204000a1 	subcs	r0, r0, r1, lsr #1
     8ac:	e1500121 	cmp	r0, r1, lsr #2
     8b0:	20400121 	subcs	r0, r0, r1, lsr #2
     8b4:	e15001a1 	cmp	r0, r1, lsr #3
     8b8:	204001a1 	subcs	r0, r0, r1, lsr #3
     8bc:	e3500001 	cmp	r0, #1
     8c0:	e1a01221 	lsr	r1, r1, #4
     8c4:	a2522004 	subsge	r2, r2, #4
     8c8:	aafffff3 	bge	89c <__modsi3+0x44>
     8cc:	e3120003 	tst	r2, #3
     8d0:	13300000 	teqne	r0, #0
     8d4:	0a00000a 	beq	904 <__modsi3+0xac>
     8d8:	e3720002 	cmn	r2, #2
     8dc:	ba000006 	blt	8fc <__modsi3+0xa4>
     8e0:	0a000002 	beq	8f0 <__modsi3+0x98>
     8e4:	e1500001 	cmp	r0, r1
     8e8:	20400001 	subcs	r0, r0, r1
     8ec:	e1a010a1 	lsr	r1, r1, #1
     8f0:	e1500001 	cmp	r0, r1
     8f4:	20400001 	subcs	r0, r0, r1
     8f8:	e1a010a1 	lsr	r1, r1, #1
     8fc:	e1500001 	cmp	r0, r1
     900:	20400001 	subcs	r0, r0, r1
	movne	r0, #0
	mov	pc, lr

12:	ARM_DIV2_ORDER r1, r2
	mov	r0, r0, lsr r2
	mov	pc, lr
     904:	e35c0000 	cmp	ip, #0

     908:	42600000 	rsbmi	r0, r0, #0
ENDPROC(__udivsi3)
     90c:	e1a0f00e 	mov	pc, lr

00000910 <Ldiv0>:

#endif

Ldiv0:

	str	lr, [sp, #-8]!
     910:	e52de008 	str	lr, [sp, #-8]!
	bl	__div0
     914:	ebffff45 	bl	630 <__div0>
	mov	r0, #0			@ About as wrong as it could be.
     918:	e3a00000 	mov	r0, #0
	ldr	pc, [sp], #8
     91c:	e49df008 	ldr	pc, [sp], #8

00000920 <__aeabi_llsr>:
#endif

ENTRY(__lshrdi3)
ENTRY(__aeabi_llsr)

	subs	r3, r2, #32
     920:	e2523020 	subs	r3, r2, #32
	rsb	ip, r2, #32
     924:	e262c020 	rsb	ip, r2, #32
	movmi	al, al, lsr r2
     928:	41a00230 	lsrmi	r0, r0, r2
	movpl	al, ah, lsr r3
     92c:	51a00331 	lsrpl	r0, r1, r3
	orrmi	al, al, ah, lsl ip
     930:	41800c11 	orrmi	r0, r0, r1, lsl ip
	mov	ah, ah, lsr r2
     934:	e1a01231 	lsr	r1, r1, r2
	mov	pc, lr
     938:	e1a0f00e 	mov	pc, lr

0000093c <main>:
	KV(PSC_STATE_DISABLE),
	KV(PSC_STATE_ENABLE),
	KV(PSC_STATE_IN_TRANSITION),
};

int main(int argc, char* argv[]) {
     93c:	e92d4073 	push	{r0, r1, r4, r5, r6, lr}
	const char* title = "\nam18x library for am1808 psc!\n";
	int i;

	printk(title);
     940:	e59f005c 	ldr	r0, [pc, #92]	; 9a4 <main+0x68>
     944:	e3a04000 	mov	r4, #0
     948:	e08f0000 	add	r0, pc, r0
     94c:	eb0001ad 	bl	1008 <printk>

	for (i = 0; i < countof(psc_kv); i++) {
		int v;
		char* stat;

		v = psc_get_state(psc_kv[i].key);
     950:	e59f3050 	ldr	r3, [pc, #80]	; 9a8 <main+0x6c>	;r3 = 0x31c4
     954:	e79a6003 	ldr	r6, [sl, r3]				;r6 = 0x3000 = &psc_kv
     958:	e7d60004 	ldrb	r0, [r6, r4]				;r0 = psc_kv[i].key
     95c:	eb00003e 	bl	a5c <psc_get_state>			;r0 = psc_get_state(key)
		stat = state_kv[v].val;
     960:	e59f2044 	ldr	r2, [pc, #68]	; 9ac <main+0x70>	;r2 = 0x000031bc

	for (i = 0; i < countof(psc_kv); i++) {
		int v;
		char* stat;

		v = psc_get_state(psc_kv[i].key);
     964:	e0845006 	add	r5, r4, r6				;r5 = &psc_kv[i].key
		stat = state_kv[v].val;
     968:	e79a2002 	ldr	r2, [sl, r2]				;r2 = 0x3180 = &state_kv
     96c:	e0822180 	add	r2, r2, r0, lsl #3			;r2 = &state_kv[v]
		printk("[%2d] %-20s =[%2d] %s\n", psc_kv[i].key, psc_kv[i].val, v, stat);
     970:	e5922004 	ldr	r2, [r2, #4]				;r2 = stat = state_kv[v].val

	for (i = 0; i < countof(psc_kv); i++) {
		int v;
		char* stat;

		v = psc_get_state(psc_kv[i].key);
     974:	e1a03000 	mov	r3, r0					;r3 = v
		stat = state_kv[v].val;
		printk("[%2d] %-20s =[%2d] %s\n", psc_kv[i].key, psc_kv[i].val, v, stat);
     978:	e59f0030 	ldr	r0, [pc, #48]	; 9b0 <main+0x74>	;r0 = 0x21ac
     97c:	e58d2000 	str	r2, [sp]				;v4 = stat
     980:	e08f0000 	add	r0, pc, r0				;r0 = 0x2b34
     984:	e7941006 	ldr	r1, [r4, r6]				;r1 = psc_kv[i].key
     988:	e5952004 	ldr	r2, [r5, #4]				;r2 = psc_kv[i].val
     98c:	eb00019d 	bl	1008 <printk>
     990:	e2844008 	add	r4, r4, #8				;i++
	const char* title = "\nam18x library for am1808 psc!\n";
	int i;

	printk(title);

	for (i = 0; i < countof(psc_kv); i++) {
     994:	e3540d06 	cmp	r4, #384	; 0x180
     998:	1affffec 	bne	950 <main+0x14>
		stat = state_kv[v].val;
		printk("[%2d] %-20s =[%2d] %s\n", psc_kv[i].key, psc_kv[i].val, v, stat);
	}

	return 0;
}
     99c:	e3a00000 	mov	r0, #0
     9a0:	e8bd807c 	pop	{r2, r3, r4, r5, r6, pc}
     9a4:	000021c4 	.word	0x000021c4
     9a8:	000031c4 	.word	0x000031c4
     9ac:	000031bc 	.word	0x000031bc
     9b0:	000021ac 	.word	0x000021ac

000009b4 <low_level_init>:
#include "auxlib.h"

#define SYSTICK_PERIOD			10/* milli seconds */
extern int output_a_char(void);

int low_level_init(void) {
     9b4:	e92d4008 	push	{r3, lr}
	if (AM18X_OK != (r = timer_con_init())) {
		return r;
	}
*/

	output_a_char();
     9b8:	ebfffe34 	bl	290 <output_a_char>

	uart_init();
     9bc:	eb000229 	bl	1268 <uart_init>
		printk("systick_start() error\n");
		return r;
	}
*/
	return AM18X_OK;
}
     9c0:	e3a00000 	mov	r0, #0
     9c4:	e8bd8008 	pop	{r3, pc}

000009c8 <module_to_psc>:
// tary, 0:35 2012/12/27
#include "am18x_psc.h"

static PSC_con_t* module_to_psc(psc_module_t module, uint32_t* nr) {
	if (module < MODULE_NR_PER_PSC) {
     9c8:	e350001f 	cmp	r0, #31
		*nr = module;
		return PSC0;
	}
	*nr = module - MODULE_NR_PER_PSC;
     9cc:	82400020 	subhi	r0, r0, #32
// tary, 0:35 2012/12/27
#include "am18x_psc.h"

static PSC_con_t* module_to_psc(psc_module_t module, uint32_t* nr) {
	if (module < MODULE_NR_PER_PSC) {
		*nr = module;
     9d0:	95810000 	strls	r0, [r1]
		return PSC0;
	}
	*nr = module - MODULE_NR_PER_PSC;
     9d4:	85810000 	strhi	r0, [r1]
#include "am18x_psc.h"

static PSC_con_t* module_to_psc(psc_module_t module, uint32_t* nr) {
	if (module < MODULE_NR_PER_PSC) {
		*nr = module;
		return PSC0;
     9d8:	959f0004 	ldrls	r0, [pc, #4]	; 9e4 <module_to_psc+0x1c>
	}
	*nr = module - MODULE_NR_PER_PSC;
	return PSC1;
     9dc:	859f0004 	ldrhi	r0, [pc, #4]	; 9e8 <module_to_psc+0x20>
}
     9e0:	e12fff1e 	bx	lr
     9e4:	01c10000 	.word	0x01c10000
     9e8:	01e27000 	.word	0x01e27000

000009ec <psc_state_transition>:

// 8.3.2 Module State Transitions
am18x_rt psc_state_transition(psc_module_t module, psc_state_t state) {
     9ec:	e92d4013 	push	{r0, r1, r4, lr}
     9f0:	e1a04001 	mov	r4, r1
	PSC_con_t* psc;
	uint32_t nr;
	uint32_t reg, val;

	psc = module_to_psc(module, &nr);
     9f4:	e28d1004 	add	r1, sp, #4
     9f8:	ebfffff2 	bl	9c8 <module_to_psc>

	// 1. Wait for the GOSTAT[x] bit in PTSTAT to clear to 0
	while (FIELD_GET(psc->PTSTAT, PTSTAT_GO0_MASK) != PTSTAT_GO0_no);
     9fc:	e5903128 	ldr	r3, [r0, #296]	; 0x128
     a00:	e3130001 	tst	r3, #1
     a04:	1afffffc 	bne	9fc <psc_state_transition+0x10>
     a08:	e3540003 	cmp	r4, #3
     a0c:	83a02002 	movhi	r2, #2
     a10:	959f3040 	ldrls	r3, [pc, #64]	; a58 <psc_state_transition+0x6c>
     a14:	908f3003 	addls	r3, pc, r3
     a18:	97932104 	ldrls	r2, [r3, r4, lsl #2]
	case PSC_STATE_DISABLE:
	default:
		val = MDCTLx_STATE_Disable;
		break;
	}
	reg = psc->MDCTLx[nr];
     a1c:	e59d3004 	ldr	r3, [sp, #4]
	psc->MDCTLx[nr] = FIELD_SET(reg, MDCTLx_STATE_MASK, val);
     a20:	e2022007 	and	r2, r2, #7
	case PSC_STATE_DISABLE:
	default:
		val = MDCTLx_STATE_Disable;
		break;
	}
	reg = psc->MDCTLx[nr];
     a24:	e2833d0a 	add	r3, r3, #640	; 0x280
     a28:	e7901103 	ldr	r1, [r0, r3, lsl #2]
	psc->MDCTLx[nr] = FIELD_SET(reg, MDCTLx_STATE_MASK, val);
     a2c:	e3c11007 	bic	r1, r1, #7
     a30:	e1822001 	orr	r2, r2, r1
     a34:	e7802103 	str	r2, [r0, r3, lsl #2]

	// 3. Set the GO[x] bit in PTCMD to 1 to initiate the transition(s)
	psc->PTCMD = FIELD_SET(psc->PTCMD, PTCMD_GO0, PTCMD_GO0);
     a38:	e5903120 	ldr	r3, [r0, #288]	; 0x120
     a3c:	e3833001 	orr	r3, r3, #1
     a40:	e5803120 	str	r3, [r0, #288]	; 0x120

	// 4. Wait for the GOSTAT[x] bit in PTSTAT to clear to 0
	while (FIELD_GET(psc->PTSTAT, PTSTAT_GO0_MASK) != PTSTAT_GO0_no);
     a44:	e5903128 	ldr	r3, [r0, #296]	; 0x128
     a48:	e3130001 	tst	r3, #1
     a4c:	1afffffc 	bne	a44 <psc_state_transition+0x58>

	// while (__field_xget(psc->MDSTATx[nr], MDSTATx_STATE_MASK) != val);

	return AM18X_TRUE;
}
     a50:	e3a00001 	mov	r0, #1
     a54:	e8bd801c 	pop	{r2, r3, r4, pc}
     a58:	000023a8 	.word	0x000023a8

00000a5c <psc_get_state>:

psc_state_t psc_get_state(psc_module_t module) {
     a5c:	e92d4007 	push	{r0, r1, r2, lr}
	PSC_con_t* psc;
	uint32_t nr;
	uint32_t val;
	psc_state_t s = PSC_STATE_DISABLE;

	psc = module_to_psc(module, &nr);
     a60:	e28d1004 	add	r1, sp, #4
     a64:	ebffffd7 	bl	9c8 <module_to_psc>

	val = __field_xget(psc->MDSTATx[nr], MDSTATx_STATE_MASK);
     a68:	e59d3004 	ldr	r3, [sp, #4]
     a6c:	e2833c02 	add	r3, r3, #512	; 0x200
     a70:	e7902103 	ldr	r2, [r0, r3, lsl #2]
	}
	return r;
}

static inline uint32_t __field_xget(uint32_t reg, uint32_t msk) {
	return ((reg & msk) >> __ffs(msk));
     a74:	e202203f 	and	r2, r2, #63	; 0x3f
	if (MDSTATx_STATE_in_transition(val)) {
     a78:	e2423004 	sub	r3, r2, #4
     a7c:	e353003b 	cmp	r3, #59	; 0x3b
		return PSC_STATE_IN_TRANSITION;
     a80:	93a00004 	movls	r0, #4
	psc_state_t s = PSC_STATE_DISABLE;

	psc = module_to_psc(module, &nr);

	val = __field_xget(psc->MDSTATx[nr], MDSTATx_STATE_MASK);
	if (MDSTATx_STATE_in_transition(val)) {
     a84:	859f300c 	ldrhi	r3, [pc, #12]	; a98 <psc_get_state+0x3c>
     a88:	808f3003 	addhi	r3, pc, r3
     a8c:	80833002 	addhi	r3, r3, r2
     a90:	85d30010 	ldrbhi	r0, [r3, #16]
		s = PSC_STATE_ENABLE;
		break;
	}

	return s;
}
     a94:	e8bd800e 	pop	{r1, r2, r3, pc}
     a98:	00002334 	.word	0x00002334

00000a9c <syscfg_kick>:
am18x_rt syscfg_kick(am18x_bool lock) {
	uint32_t kick0, kick1;

	if (lock) {
		kick0 = KICK0R_LOCK;
		kick1 = KICK1R_LOCK;
     a9c:	e59f2020 	ldr	r2, [pc, #32]	; ac4 <syscfg_kick+0x28>
     aa0:	e59f1020 	ldr	r1, [pc, #32]	; ac8 <syscfg_kick+0x2c>
	} else {
		kick0 = KICK0R_UNLOCK;
		kick1 = KICK1R_UNLOCK;
	}

	SYSCFG0->KICKxR[0] = kick0;
     aa4:	e59f3020 	ldr	r3, [pc, #32]	; acc <syscfg_kick+0x30>
#include "am18x_syscfg.h"

am18x_rt syscfg_kick(am18x_bool lock) {
	uint32_t kick0, kick1;

	if (lock) {
     aa8:	e3500000 	cmp	r0, #0
		kick0 = KICK0R_LOCK;
		kick1 = KICK1R_LOCK;
     aac:	13a02000 	movne	r2, #0
     ab0:	13a01000 	movne	r1, #0
	} else {
		kick0 = KICK0R_UNLOCK;
		kick1 = KICK1R_UNLOCK;
	}

	SYSCFG0->KICKxR[0] = kick0;
     ab4:	e5831038 	str	r1, [r3, #56]	; 0x38
	SYSCFG0->KICKxR[1] = kick1;

	return AM18X_TRUE;
}
     ab8:	e3a00001 	mov	r0, #1
		kick0 = KICK0R_UNLOCK;
		kick1 = KICK1R_UNLOCK;
	}

	SYSCFG0->KICKxR[0] = kick0;
	SYSCFG0->KICKxR[1] = kick1;
     abc:	e583203c 	str	r2, [r3, #60]	; 0x3c

	return AM18X_TRUE;
}
     ac0:	e12fff1e 	bx	lr
     ac4:	95a4f1e0 	.word	0x95a4f1e0
     ac8:	83e70b13 	.word	0x83e70b13
     acc:	01c14000 	.word	0x01c14000

00000ad0 <syscfg_pinmux>:
// pos = [0,4,8,12,16,20,24,28]
// val = [0..15]
am18x_rt syscfg_pinmux(uint32_t mux, uint32_t pos, uint32_t val) {
	uint32_t reg;

	if (mux >= 20 || pos >= 32 || pos % 4 != 0 || val >= 8) {
     ad0:	e3500013 	cmp	r0, #19
     ad4:	9351001f 	cmpls	r1, #31
	return AM18X_TRUE;
}

// pos = [0,4,8,12,16,20,24,28]
// val = [0..15]
am18x_rt syscfg_pinmux(uint32_t mux, uint32_t pos, uint32_t val) {
     ad8:	e92d4030 	push	{r4, r5, lr}
	uint32_t reg;

	if (mux >= 20 || pos >= 32 || pos % 4 != 0 || val >= 8) {
     adc:	93a0c000 	movls	ip, #0
     ae0:	83a0c001 	movhi	ip, #1
		return AM18X_FALSE;
     ae4:	83a00000 	movhi	r0, #0
// pos = [0,4,8,12,16,20,24,28]
// val = [0..15]
am18x_rt syscfg_pinmux(uint32_t mux, uint32_t pos, uint32_t val) {
	uint32_t reg;

	if (mux >= 20 || pos >= 32 || pos % 4 != 0 || val >= 8) {
     ae8:	88bd8030 	pophi	{r4, r5, pc}
     aec:	e2113003 	ands	r3, r1, #3
     af0:	13a03001 	movne	r3, #1
     af4:	e3520007 	cmp	r2, #7
     af8:	83833001 	orrhi	r3, r3, #1
     afc:	e3530000 	cmp	r3, #0
     b00:	1a00001e 	bne	b80 <syscfg_pinmux+0xb0>
		return AM18X_FALSE;
	}

	reg = SYSCFG0->PINMUXx[mux];
     b04:	e59fc07c 	ldr	ip, [pc, #124]	; b88 <syscfg_pinmux+0xb8>
     b08:	e2804048 	add	r4, r0, #72	; 0x48
     b0c:	e79c5104 	ldr	r5, [ip, r4, lsl #2]
	SYSCFG0->PINMUXx[mux] = __field_xset(reg, (0xFUL << pos), val);
     b10:	e3a0400f 	mov	r4, #15
     b14:	e1a01114 	lsl	r1, r4, r1
#ifndef __ASSEMBLY__
static inline uint32_t __ffs(uint32_t x)
{
	uint32_t r = 0;

	if (!x)	return 0;
     b18:	e3510000 	cmp	r1, #0
static inline uint32_t __field_xget(uint32_t reg, uint32_t msk) {
	return ((reg & msk) >> __ffs(msk));
}

static inline uint32_t __field_xset(uint32_t reg, uint32_t msk, uint32_t vx) {
	return (reg & ~msk) | ((vx << __ffs(msk)) & msk);
     b1c:	e1c55001 	bic	r5, r5, r1
     b20:	e1a0400c 	mov	r4, ip
#ifndef __ASSEMBLY__
static inline uint32_t __ffs(uint32_t x)
{
	uint32_t r = 0;

	if (!x)	return 0;
     b24:	01a03001 	moveq	r3, r1
     b28:	0a00000e 	beq	b68 <syscfg_pinmux+0x98>

	if (!(x & 0xffff)) {
     b2c:	e1b0c801 	lsls	ip, r1, #16
		x >>= 16; r += 16;
     b30:	01a0c821 	lsreq	ip, r1, #16
{
	uint32_t r = 0;

	if (!x)	return 0;

	if (!(x & 0xffff)) {
     b34:	11a0c001 	movne	ip, r1
		x >>= 16; r += 16;
     b38:	02833010 	addeq	r3, r3, #16
	}
	if (!(x & 0xff)) {
     b3c:	e31c00ff 	tst	ip, #255	; 0xff
		x >>= 8; r += 8;
     b40:	01a0c42c 	lsreq	ip, ip, #8
     b44:	02833008 	addeq	r3, r3, #8
	}
	if (!(x & 0xf)) {
     b48:	e31c000f 	tst	ip, #15
		x >>= 4; r += 4;
     b4c:	01a0c22c 	lsreq	ip, ip, #4
     b50:	02833004 	addeq	r3, r3, #4
	}
	if (!(x & 3)) {
     b54:	e31c0003 	tst	ip, #3
		x >>= 2; r += 2;
     b58:	01a0c12c 	lsreq	ip, ip, #2
     b5c:	02833002 	addeq	r3, r3, #2
	}
	if (!(x & 1)) {
     b60:	e31c0001 	tst	ip, #1
		x >>= 1; r += 1;
     b64:	02833001 	addeq	r3, r3, #1
static inline uint32_t __field_xget(uint32_t reg, uint32_t msk) {
	return ((reg & msk) >> __ffs(msk));
}

static inline uint32_t __field_xset(uint32_t reg, uint32_t msk, uint32_t vx) {
	return (reg & ~msk) | ((vx << __ffs(msk)) & msk);
     b68:	e0011312 	and	r1, r1, r2, lsl r3
     b6c:	e2800048 	add	r0, r0, #72	; 0x48
     b70:	e1811005 	orr	r1, r1, r5
     b74:	e7841100 	str	r1, [r4, r0, lsl #2]

	return AM18X_TRUE;
     b78:	e3a00001 	mov	r0, #1
     b7c:	e8bd8030 	pop	{r4, r5, pc}
// val = [0..15]
am18x_rt syscfg_pinmux(uint32_t mux, uint32_t pos, uint32_t val) {
	uint32_t reg;

	if (mux >= 20 || pos >= 32 || pos % 4 != 0 || val >= 8) {
		return AM18X_FALSE;
     b80:	e1a0000c 	mov	r0, ip

	reg = SYSCFG0->PINMUXx[mux];
	SYSCFG0->PINMUXx[mux] = __field_xset(reg, (0xFUL << pos), val);

	return AM18X_TRUE;
}
     b84:	e8bd8030 	pop	{r4, r5, pc}
     b88:	01c14000 	.word	0x01c14000

00000b8c <__field_xget>:
#ifndef __ASSEMBLY__
static inline uint32_t __ffs(uint32_t x)
{
	uint32_t r = 0;

	if (!x)	return 0;
     b8c:	e3510000 	cmp	r1, #0
	}
	return r;
}

static inline uint32_t __field_xget(uint32_t reg, uint32_t msk) {
	return ((reg & msk) >> __ffs(msk));
     b90:	e0010000 	and	r0, r1, r0
#ifndef __ASSEMBLY__
static inline uint32_t __ffs(uint32_t x)
{
	uint32_t r = 0;

	if (!x)	return 0;
     b94:	01a03001 	moveq	r3, r1
     b98:	0a00000e 	beq	bd8 <__field_xget+0x4c>

	if (!(x & 0xffff)) {
     b9c:	e1b03801 	lsls	r3, r1, #16
		x >>= 16; r += 16;
     ba0:	01a01821 	lsreq	r1, r1, #16
     ba4:	03a03010 	moveq	r3, #16
#define FIELD_XSET(_reg,_msk,_vx)	(((_reg) & ~(_msk)) | (((_vx) << MASK_OFFSET(_msk)) & (_msk)))

#ifndef __ASSEMBLY__
static inline uint32_t __ffs(uint32_t x)
{
	uint32_t r = 0;
     ba8:	13a03000 	movne	r3, #0
	if (!x)	return 0;

	if (!(x & 0xffff)) {
		x >>= 16; r += 16;
	}
	if (!(x & 0xff)) {
     bac:	e31100ff 	tst	r1, #255	; 0xff
		x >>= 8; r += 8;
     bb0:	01a01421 	lsreq	r1, r1, #8
     bb4:	02833008 	addeq	r3, r3, #8
	}
	if (!(x & 0xf)) {
     bb8:	e311000f 	tst	r1, #15
		x >>= 4; r += 4;
     bbc:	01a01221 	lsreq	r1, r1, #4
     bc0:	02833004 	addeq	r3, r3, #4
	}
	if (!(x & 3)) {
     bc4:	e3110003 	tst	r1, #3
		x >>= 2; r += 2;
     bc8:	01a01121 	lsreq	r1, r1, #2
     bcc:	02833002 	addeq	r3, r3, #2
	}
	if (!(x & 1)) {
     bd0:	e3110001 	tst	r1, #1
		x >>= 1; r += 1;
     bd4:	02833001 	addeq	r3, r3, #1
	return r;
}

static inline uint32_t __field_xget(uint32_t reg, uint32_t msk) {
	return ((reg & msk) >> __ffs(msk));
}
     bd8:	e1a00330 	lsr	r0, r0, r3
     bdc:	e12fff1e 	bx	lr

00000be0 <uart_input_clock_frequency>:
// tary, 0:22 2012/12/22
#include "am18x_uart.h"

uint32_t uart_input_clock_frequency(UART_con_t* ucon) {
	return F_OSCIN / 2UL;
}
     be0:	e51f0000 	ldr	r0, [pc, #-0]	; be8 <uart_input_clock_frequency+0x8>
     be4:	e12fff1e 	bx	lr
     be8:	00b71b00 	.word	0x00b71b00

00000bec <uart_init_conf>:
}

am18x_rt uart_init_conf(uart_conf_t* conf) {
	assert(conf);

	conf->baudrate = 115200UL;
     bec:	e59f2028 	ldr	r2, [pc, #40]	; c1c <uart_init_conf+0x30>

	return uart_input_clock_frequency(ucon) / (samp_clk * baud_rate);
	//return 8;
}

am18x_rt uart_init_conf(uart_conf_t* conf) {
     bf0:	e1a03000 	mov	r3, r0
	assert(conf);

	conf->baudrate = 115200UL;
     bf4:	e5802000 	str	r2, [r0]
	conf->length = UART_LENGTH_8BIT;
     bf8:	e3a02003 	mov	r2, #3
     bfc:	e5c02004 	strb	r2, [r0, #4]
	conf->stop = UART_STOP_1BIT;
     c00:	e3a00000 	mov	r0, #0
	conf->parity = UART_PARITY_NONE;
	conf->flow = UART_FLOW_NONE;
	conf->mode = UART_MODE_INTR;
     c04:	e3a02001 	mov	r2, #1
am18x_rt uart_init_conf(uart_conf_t* conf) {
	assert(conf);

	conf->baudrate = 115200UL;
	conf->length = UART_LENGTH_8BIT;
	conf->stop = UART_STOP_1BIT;
     c08:	e5c30005 	strb	r0, [r3, #5]
	conf->parity = UART_PARITY_NONE;
     c0c:	e5c30006 	strb	r0, [r3, #6]
	conf->flow = UART_FLOW_NONE;
     c10:	e5c30007 	strb	r0, [r3, #7]
	conf->mode = UART_MODE_INTR;
     c14:	e5c32008 	strb	r2, [r3, #8]

	return AM18X_OK;
}
     c18:	e12fff1e 	bx	lr
     c1c:	0001c200 	.word	0x0001c200

00000c20 <uart_set_conf>:

am18x_rt uart_set_conf(UART_con_t* ucon, const uart_conf_t* conf) {
     c20:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	assert(conf);
	assert(conf->baudrate);

	// 2. Set the desired baud rate by writing the appropriate
	// clock divisor values to the divisor latch registers
	ucon->MDR = FIELD_SET(ucon->MDR, MDR_OSM_SEL_MASK, MDR_OSM_SEL_13x);
     c24:	e5903034 	ldr	r3, [r0, #52]	; 0x34

	v = uart_get_divisor(ucon, conf->baudrate);
     c28:	e5917000 	ldr	r7, [r1]
	assert(conf);
	assert(conf->baudrate);

	// 2. Set the desired baud rate by writing the appropriate
	// clock divisor values to the divisor latch registers
	ucon->MDR = FIELD_SET(ucon->MDR, MDR_OSM_SEL_MASK, MDR_OSM_SEL_13x);
     c2c:	e3833001 	orr	r3, r3, #1
     c30:	e5803034 	str	r3, [r0, #52]	; 0x34

static inline uint32_t uart_get_divisor(UART_con_t* ucon, uint32_t baud_rate) {
	uint32_t samp_clk;

	samp_clk = 16;
	if (FIELD_GET(ucon->MDR, MDR_OSM_SEL_MASK) == MDR_OSM_SEL_13x) {
     c34:	e5903034 	ldr	r3, [r0, #52]	; 0x34
	conf->mode = UART_MODE_INTR;

	return AM18X_OK;
}

am18x_rt uart_set_conf(UART_con_t* ucon, const uart_conf_t* conf) {
     c38:	e1a04000 	mov	r4, r0

static inline uint32_t uart_get_divisor(UART_con_t* ucon, uint32_t baud_rate) {
	uint32_t samp_clk;

	samp_clk = 16;
	if (FIELD_GET(ucon->MDR, MDR_OSM_SEL_MASK) == MDR_OSM_SEL_13x) {
     c3c:	e3130001 	tst	r3, #1
}

static inline uint32_t uart_get_divisor(UART_con_t* ucon, uint32_t baud_rate) {
	uint32_t samp_clk;

	samp_clk = 16;
     c40:	13a0600d 	movne	r6, #13
     c44:	03a06010 	moveq	r6, #16
	conf->mode = UART_MODE_INTR;

	return AM18X_OK;
}

am18x_rt uart_set_conf(UART_con_t* ucon, const uart_conf_t* conf) {
     c48:	e1a05001 	mov	r5, r1
	samp_clk = 16;
	if (FIELD_GET(ucon->MDR, MDR_OSM_SEL_MASK) == MDR_OSM_SEL_13x) {
		samp_clk = 13;
	}

	return uart_input_clock_frequency(ucon) / (samp_clk * baud_rate);
     c4c:	ebffffe3 	bl	be0 <uart_input_clock_frequency>
     c50:	e0010697 	mul	r1, r7, r6
     c54:	ebfffe7d 	bl	650 <__aeabi_uidiv>
	// 2. Set the desired baud rate by writing the appropriate
	// clock divisor values to the divisor latch registers
	ucon->MDR = FIELD_SET(ucon->MDR, MDR_OSM_SEL_MASK, MDR_OSM_SEL_13x);

	v = uart_get_divisor(ucon, conf->baudrate);
	ucon->DLL = __field_xget(v, 0x00FF);
     c58:	e3a010ff 	mov	r1, #255	; 0xff
	samp_clk = 16;
	if (FIELD_GET(ucon->MDR, MDR_OSM_SEL_MASK) == MDR_OSM_SEL_13x) {
		samp_clk = 13;
	}

	return uart_input_clock_frequency(ucon) / (samp_clk * baud_rate);
     c5c:	e1a06000 	mov	r6, r0
	// 2. Set the desired baud rate by writing the appropriate
	// clock divisor values to the divisor latch registers
	ucon->MDR = FIELD_SET(ucon->MDR, MDR_OSM_SEL_MASK, MDR_OSM_SEL_13x);

	v = uart_get_divisor(ucon, conf->baudrate);
	ucon->DLL = __field_xget(v, 0x00FF);
     c60:	ebffffc9 	bl	b8c <__field_xget>
	ucon->DLH = __field_xget(v, 0xFF00);
     c64:	e3a01cff 	mov	r1, #65280	; 0xff00
	// 2. Set the desired baud rate by writing the appropriate
	// clock divisor values to the divisor latch registers
	ucon->MDR = FIELD_SET(ucon->MDR, MDR_OSM_SEL_MASK, MDR_OSM_SEL_13x);

	v = uart_get_divisor(ucon, conf->baudrate);
	ucon->DLL = __field_xget(v, 0x00FF);
     c68:	e20000ff 	and	r0, r0, #255	; 0xff
     c6c:	e5c40020 	strb	r0, [r4, #32]
	ucon->DLH = __field_xget(v, 0xFF00);
     c70:	e1a00006 	mov	r0, r6
     c74:	ebffffc4 	bl	b8c <__field_xget>
     c78:	e20000ff 	and	r0, r0, #255	; 0xff
     c7c:	e5c40024 	strb	r0, [r4, #36]	; 0x24
	// appropriate values to the line control register
	reg = FIELD_SET(ucon->LCR, LCR_DLAB_MASK, LCR_DLAB_rbr_thr_ier);
	reg = FIELD_SET(reg, LCR_BC_MASK, LCR_BC_disabled);

	msk = LCR_PEN_MASK | LCR_EPS_MASK | LCR_SP_MASK;
	switch (conf->parity) {
     c80:	e5d52006 	ldrb	r2, [r5, #6]
	ucon->DLL = __field_xget(v, 0x00FF);
	ucon->DLH = __field_xget(v, 0xFF00);

	// 4. Choose the desired protocol settings by writing the
	// appropriate values to the line control register
	reg = FIELD_SET(ucon->LCR, LCR_DLAB_MASK, LCR_DLAB_rbr_thr_ier);
     c84:	e594100c 	ldr	r1, [r4, #12]
	reg = FIELD_SET(reg, LCR_BC_MASK, LCR_BC_disabled);

	msk = LCR_PEN_MASK | LCR_EPS_MASK | LCR_SP_MASK;
	switch (conf->parity) {
     c88:	e2422001 	sub	r2, r2, #1
     c8c:	e20220ff 	and	r2, r2, #255	; 0xff
     c90:	e3520003 	cmp	r2, #3
     c94:	83a03000 	movhi	r3, #0
     c98:	959f3064 	ldrls	r3, [pc, #100]	; d04 <uart_set_conf+0xe4>
     c9c:	908f3003 	addls	r3, pc, r3
     ca0:	97933102 	ldrls	r3, [r3, r2, lsl #2]
	case UART_PARITY_NONE:
	default:
		v = LCR_PEN_No;
		break;
	}
	reg = FIELD_SET(reg, msk, v);
     ca4:	e3c120fc 	bic	r2, r1, #252	; 0xfc
     ca8:	e2033038 	and	r3, r3, #56	; 0x38
     cac:	e5d51005 	ldrb	r1, [r5, #5]
	case UART_STOP_1BIT:
	default:
		v = LCR_STB_1STOP;
		break;
	}
	reg = FIELD_SET(reg, LCR_STB_MASK, v);
     cb0:	e1823003 	orr	r3, r2, r3

	switch(conf->length) {
     cb4:	e5d52004 	ldrb	r2, [r5, #4]
	case UART_STOP_1BIT:
	default:
		v = LCR_STB_1STOP;
		break;
	}
	reg = FIELD_SET(reg, LCR_STB_MASK, v);
     cb8:	e3510001 	cmp	r1, #1
     cbc:	03a01004 	moveq	r1, #4
     cc0:	13a01000 	movne	r1, #0

	switch(conf->length) {
     cc4:	e3520002 	cmp	r2, #2
	case UART_STOP_1BIT:
	default:
		v = LCR_STB_1STOP;
		break;
	}
	reg = FIELD_SET(reg, LCR_STB_MASK, v);
     cc8:	e1811003 	orr	r1, r1, r3

	switch(conf->length) {
     ccc:	83a03003 	movhi	r3, #3
     cd0:	959f3030 	ldrls	r3, [pc, #48]	; d08 <uart_set_conf+0xe8>
     cd4:	908f3003 	addls	r3, pc, r3
     cd8:	90833102 	addls	r3, r3, r2, lsl #2
     cdc:	95933010 	ldrls	r3, [r3, #16]
	case UART_LENGTH_8BIT:
	default:
		v = LCR_WLS_8bits;
		break;
	}
	reg = FIELD_SET(reg, LCR_WLS_MASK, v);
     ce0:	e3c12003 	bic	r2, r1, #3
     ce4:	e2033003 	and	r3, r3, #3
     ce8:	e1833002 	orr	r3, r3, r2
	ucon->LCR = reg;
     cec:	e584300c 	str	r3, [r4, #12]
	// by configuring the FREE bit and enable the UART
	// by setting the UTRST and URRST bits in the power and emulation
	// management register
	msk = PWREMU_UTRST_MASK | PWREMU_URRST_MASK;// | PWREMU_FREE_MASK;
	v = PWREMU_UTRST_enabled | PWREMU_URRST_enabled;// | PWREMU_FREE_run;
	ucon->PWREMU_MGMT = FIELD_SET(ucon->PWREMU_MGMT, msk, v);
     cf0:	e5943030 	ldr	r3, [r4, #48]	; 0x30

	return AM18X_OK;
}
     cf4:	e3a00000 	mov	r0, #0
	// by configuring the FREE bit and enable the UART
	// by setting the UTRST and URRST bits in the power and emulation
	// management register
	msk = PWREMU_UTRST_MASK | PWREMU_URRST_MASK;// | PWREMU_FREE_MASK;
	v = PWREMU_UTRST_enabled | PWREMU_URRST_enabled;// | PWREMU_FREE_run;
	ucon->PWREMU_MGMT = FIELD_SET(ucon->PWREMU_MGMT, msk, v);
     cf8:	e3833a06 	orr	r3, r3, #24576	; 0x6000
     cfc:	e5843030 	str	r3, [r4, #48]	; 0x30

	return AM18X_OK;
}
     d00:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
     d04:	00002134 	.word	0x00002134
     d08:	000020fc 	.word	0x000020fc

00000d0c <uart_state>:

am18x_bool uart_state(const UART_con_t* ucon, uart_state_type_t type) {
	am18x_bool r;

	r = AM18X_FALSE;
	switch(type) {
     d0c:	e3510001 	cmp	r1, #1
     d10:	9a000002 	bls	d20 <uart_state+0x14>
     d14:	e3510002 	cmp	r1, #2
     d18:	1a000008 	bne	d40 <uart_state+0x34>
     d1c:	ea000004 	b	d34 <uart_state+0x28>
	case STATE_TX_EMPTY:
	// BugFix:
	case STATE_TX_BUF_EMPTY:
		if (FIELD_GET(ucon->LSR, LSR_THRE_MASK) == LSR_THRE_yes) {
     d20:	e5903014 	ldr	r3, [r0, #20]
}

am18x_bool uart_state(const UART_con_t* ucon, uart_state_type_t type) {
	am18x_bool r;

	r = AM18X_FALSE;
     d24:	e3130020 	tst	r3, #32
     d28:	03a00000 	moveq	r0, #0
     d2c:	13a00001 	movne	r0, #1
     d30:	e12fff1e 	bx	lr
		if (FIELD_GET(ucon->LSR, LSR_THRE_MASK) == LSR_THRE_yes) {
			r = AM18X_TRUE;
		}
		break;
	case STATE_RX_READY:
		if (FIELD_GET(ucon->LSR, LSR_DR_MASK) == LSR_DR_yes) {
     d34:	e5900014 	ldr	r0, [r0, #20]
}

am18x_bool uart_state(const UART_con_t* ucon, uart_state_type_t type) {
	am18x_bool r;

	r = AM18X_FALSE;
     d38:	e2000001 	and	r0, r0, #1
     d3c:	e12fff1e 	bx	lr
     d40:	e3a00000 	mov	r0, #0
	case STATE_FIFO_TXFULL:
	case STATE_FIFO_RXFULL:
		break;
	}
	return r;
}
     d44:	e12fff1e 	bx	lr

00000d48 <uart_write_byte>:

am18x_rt uart_write_byte(UART_con_t* ucon, uint8_t c) {
	ucon->THRw = c;
     d48:	e5801000 	str	r1, [r0]
	return AM18X_OK;
}
     d4c:	e3a00000 	mov	r0, #0
     d50:	e12fff1e 	bx	lr

00000d54 <uart_read_byte>:

uint8_t uart_read_byte(const UART_con_t* ucon) {
	return ucon->RBRr;
     d54:	e5900000 	ldr	r0, [r0]
     d58:	e20000ff 	and	r0, r0, #255	; 0xff
}
     d5c:	e12fff1e 	bx	lr

00000d60 <arm_mmu_show_id_code>:
// tary, 1:15 2011/8/3
#include "arm920t.h"
#include "auxlib.h"

int arm_mmu_show_id_code(void) {
     d60:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
} cp15_id_code_t;

static inline cp15_id_code_t arm_read_cp15_id_code(void) {
	cp15_id_code_t c0;

	asm volatile(
     d64:	ee101f10 	mrc	15, 0, r1, cr0, cr0, {0}
	cp15_id_code_t id[1];

	id[0] = arm_read_cp15_id_code();

	printk("MMU\tLayoutRev\t= 0x%X\n", id->LayoutRev);
     d68:	e59f006c 	ldr	r0, [pc, #108]	; ddc <arm_mmu_show_id_code+0x7c>
	"mrc	p15, 0, %0, c0, c0, 0\n"
	: "=r" (c0)
	);
	return c0;
     d6c:	e1a04c21 	lsr	r4, r1, #24
     d70:	e1a07801 	lsl	r7, r1, #16
     d74:	e1a06821 	lsr	r6, r1, #16
     d78:	e1a05a21 	lsr	r5, r1, #20
     d7c:	e08f0000 	add	r0, pc, r0
     d80:	e201100f 	and	r1, r1, #15
     d84:	eb00009f 	bl	1008 <printk>
	printk("\tPartNumber\t= 0x%X\n", id->PartNumber);
     d88:	e59f0050 	ldr	r0, [pc, #80]	; de0 <arm_mmu_show_id_code+0x80>
     d8c:	e1a07a27 	lsr	r7, r7, #20
     d90:	e1a01007 	mov	r1, r7
     d94:	e08f0000 	add	r0, pc, r0
     d98:	eb00009a 	bl	1008 <printk>
	printk("\tArchitecture\t= 0x%X\n", id->Architecture);
     d9c:	e59f0040 	ldr	r0, [pc, #64]	; de4 <arm_mmu_show_id_code+0x84>
     da0:	e206600f 	and	r6, r6, #15
     da4:	e1a01006 	mov	r1, r6
     da8:	e08f0000 	add	r0, pc, r0
     dac:	eb000095 	bl	1008 <printk>
	printk("\tSpecRev  \t= 0x%X\n", id->SpecRev);
     db0:	e59f0030 	ldr	r0, [pc, #48]	; de8 <arm_mmu_show_id_code+0x88>
     db4:	e205500f 	and	r5, r5, #15
     db8:	e1a01005 	mov	r1, r5
     dbc:	e08f0000 	add	r0, pc, r0
     dc0:	eb000090 	bl	1008 <printk>
	printk("\tImplementer\t= 0x%X\n", id->Implementer);
     dc4:	e59f0020 	ldr	r0, [pc, #32]	; dec <arm_mmu_show_id_code+0x8c>
     dc8:	e1a01004 	mov	r1, r4
     dcc:	e08f0000 	add	r0, pc, r0
     dd0:	eb00008c 	bl	1008 <printk>

	return 0;
}
     dd4:	e3a00000 	mov	r0, #0
     dd8:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
     ddc:	00002070 	.word	0x00002070
     de0:	0000206e 	.word	0x0000206e
     de4:	0000206e 	.word	0x0000206e
     de8:	00002070 	.word	0x00002070
     dec:	00002073 	.word	0x00002073

00000df0 <arm_mmu_show_cache_type>:

int arm_mmu_show_cache_type(void) {
     df0:	e92d4bff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, fp, lr}
} cp15_cache_type_t;

static inline cp15_cache_type_t arm_read_cp15_cache_type(void) {
	cp15_cache_type_t c0;

	asm volatile(
     df4:	ee105f30 	mrc	15, 0, r5, cr0, cr0, {1}
	cp15_cache_type_t ctype[1];

	ctype[0] = arm_read_cp15_cache_type();

	printk("MMU\tIlen\t= 0x%X\n", ctype->Ilen);
     df8:	e59f0178 	ldr	r0, [pc, #376]	; f78 <arm_mmu_show_cache_type+0x188>
	"mrc	p15, 0, %0, c0, c0, 1\n"
	: "=r" (c0)
	);
	return c0;
     dfc:	e1a0b125 	lsr	fp, r5, #2
     e00:	e1a041a5 	lsr	r4, r5, #3
     e04:	e1a06325 	lsr	r6, r5, #6
     e08:	e1a08625 	lsr	r8, r5, #12
     e0c:	e1a03725 	lsr	r3, r5, #14
     e10:	e1a077a5 	lsr	r7, r5, #15
     e14:	e1a09925 	lsr	r9, r5, #18
     e18:	e1a02c25 	lsr	r2, r5, #24
     e1c:	e1a0cca5 	lsr	ip, r5, #25
     e20:	e2055003 	and	r5, r5, #3
     e24:	e20cc00f 	and	ip, ip, #15
     e28:	e2022001 	and	r2, r2, #1
     e2c:	e2033001 	and	r3, r3, #1
     e30:	e1a01005 	mov	r1, r5
     e34:	e08f0000 	add	r0, pc, r0
     e38:	e58dc004 	str	ip, [sp, #4]
     e3c:	e58d2008 	str	r2, [sp, #8]
     e40:	e58d300c 	str	r3, [sp, #12]
     e44:	eb00006f 	bl	1008 <printk>
	printk("\tIM\t= 0x%X\n", ctype->IM);
     e48:	e59f012c 	ldr	r0, [pc, #300]	; f7c <arm_mmu_show_cache_type+0x18c>
     e4c:	e20bb001 	and	fp, fp, #1
     e50:	e1a0100b 	mov	r1, fp
     e54:	e08f0000 	add	r0, pc, r0
     e58:	eb00006a 	bl	1008 <printk>
	printk("\tIassoc\t= 0x%X\n", ctype->Iassoc);
     e5c:	e59f011c 	ldr	r0, [pc, #284]	; f80 <arm_mmu_show_cache_type+0x190>
     e60:	e2044007 	and	r4, r4, #7
     e64:	e1a01004 	mov	r1, r4
     e68:	e08f0000 	add	r0, pc, r0
     e6c:	eb000065 	bl	1008 <printk>
	printk("\tIsize\t= 0x%X\n", ctype->Isize);
     e70:	e59f010c 	ldr	r0, [pc, #268]	; f84 <arm_mmu_show_cache_type+0x194>
     e74:	e2066007 	and	r6, r6, #7
     e78:	e1a01006 	mov	r1, r6
     e7c:	e08f0000 	add	r0, pc, r0
     e80:	eb000060 	bl	1008 <printk>
	printk("\tDlen\t= 0x%X\n", ctype->Dlen);
     e84:	e59f00fc 	ldr	r0, [pc, #252]	; f88 <arm_mmu_show_cache_type+0x198>
     e88:	e2088003 	and	r8, r8, #3
     e8c:	e1a01008 	mov	r1, r8
     e90:	e08f0000 	add	r0, pc, r0
     e94:	eb00005b 	bl	1008 <printk>
	printk("\tDM\t= 0x%X\n", ctype->DM);
     e98:	e59d300c 	ldr	r3, [sp, #12]
     e9c:	e59f00e8 	ldr	r0, [pc, #232]	; f8c <arm_mmu_show_cache_type+0x19c>
     ea0:	e1a01003 	mov	r1, r3
     ea4:	e08f0000 	add	r0, pc, r0
     ea8:	eb000056 	bl	1008 <printk>
	printk("\tDassoc\t= 0x%X\n", ctype->Dassoc);
     eac:	e59f00dc 	ldr	r0, [pc, #220]	; f90 <arm_mmu_show_cache_type+0x1a0>
     eb0:	e2077007 	and	r7, r7, #7
     eb4:	e1a01007 	mov	r1, r7
     eb8:	e08f0000 	add	r0, pc, r0
     ebc:	eb000051 	bl	1008 <printk>
	printk("\tDsize\t= 0x%X\n", ctype->Dsize);
     ec0:	e59f00cc 	ldr	r0, [pc, #204]	; f94 <arm_mmu_show_cache_type+0x1a4>
     ec4:	e2099007 	and	r9, r9, #7
     ec8:	e1a01009 	mov	r1, r9
     ecc:	e08f0000 	add	r0, pc, r0
     ed0:	eb00004c 	bl	1008 <printk>
	printk("\tS\t= 0x%X\n", ctype->S);
     ed4:	e59d2008 	ldr	r2, [sp, #8]
     ed8:	e59f00b8 	ldr	r0, [pc, #184]	; f98 <arm_mmu_show_cache_type+0x1a8>
     edc:	e1a01002 	mov	r1, r2
     ee0:	e08f0000 	add	r0, pc, r0
     ee4:	eb000047 	bl	1008 <printk>
	printk("\tctype\t= 0x%X\n", ctype->ctype);
     ee8:	e59dc004 	ldr	ip, [sp, #4]
     eec:	e59f00a8 	ldr	r0, [pc, #168]	; f9c <arm_mmu_show_cache_type+0x1ac>
     ef0:	e1a0100c 	mov	r1, ip
     ef4:	e08f0000 	add	r0, pc, r0

	printk("MMU\tDCache Size     \t= %d KB\n", (1 << ctype->Dsize) >> 1);
     ef8:	e3a0b001 	mov	fp, #1
	printk("\tDlen\t= 0x%X\n", ctype->Dlen);
	printk("\tDM\t= 0x%X\n", ctype->DM);
	printk("\tDassoc\t= 0x%X\n", ctype->Dassoc);
	printk("\tDsize\t= 0x%X\n", ctype->Dsize);
	printk("\tS\t= 0x%X\n", ctype->S);
	printk("\tctype\t= 0x%X\n", ctype->ctype);
     efc:	eb000041 	bl	1008 <printk>

	printk("MMU\tDCache Size     \t= %d KB\n", (1 << ctype->Dsize) >> 1);
     f00:	e59f0098 	ldr	r0, [pc, #152]	; fa0 <arm_mmu_show_cache_type+0x1b0>
     f04:	e1a0191b 	lsl	r1, fp, r9
     f08:	e08f0000 	add	r0, pc, r0
     f0c:	e1a01b51 	asr	r1, r1, fp
     f10:	eb00003c 	bl	1008 <printk>
	printk("\tDCache Line length\t= %d bytes\n", 8 << ctype->Dlen);
     f14:	e59f0088 	ldr	r0, [pc, #136]	; fa4 <arm_mmu_show_cache_type+0x1b4>
     f18:	e3a09008 	mov	r9, #8
     f1c:	e1a01819 	lsl	r1, r9, r8
     f20:	e08f0000 	add	r0, pc, r0
     f24:	eb000037 	bl	1008 <printk>
	printk("\tDCache associativity\t= %d-way\n", (1 << ctype->Dassoc));
     f28:	e59f0078 	ldr	r0, [pc, #120]	; fa8 <arm_mmu_show_cache_type+0x1b8>
     f2c:	e1a0171b 	lsl	r1, fp, r7
     f30:	e08f0000 	add	r0, pc, r0
     f34:	eb000033 	bl	1008 <printk>
	printk("\tICache Size     \t= %d KB\n", (1 << ctype->Isize) >> 1);
     f38:	e59f006c 	ldr	r0, [pc, #108]	; fac <arm_mmu_show_cache_type+0x1bc>
     f3c:	e1a0161b 	lsl	r1, fp, r6
     f40:	e08f0000 	add	r0, pc, r0
     f44:	e1a01b51 	asr	r1, r1, fp
     f48:	eb00002e 	bl	1008 <printk>
	printk("\tICache Line length\t= %d bytes\n", 8 << ctype->Ilen);
     f4c:	e59f005c 	ldr	r0, [pc, #92]	; fb0 <arm_mmu_show_cache_type+0x1c0>
     f50:	e1a01519 	lsl	r1, r9, r5
     f54:	e08f0000 	add	r0, pc, r0
     f58:	eb00002a 	bl	1008 <printk>
	printk("\tICache associativity\t= %d-way\n", (1 << ctype->Iassoc));
     f5c:	e59f0050 	ldr	r0, [pc, #80]	; fb4 <arm_mmu_show_cache_type+0x1c4>
     f60:	e1a0141b 	lsl	r1, fp, r4
     f64:	e08f0000 	add	r0, pc, r0
     f68:	eb000026 	bl	1008 <printk>

	return 0;
}
     f6c:	e3a00000 	mov	r0, #0
     f70:	e28dd010 	add	sp, sp, #16
     f74:	e8bd8bf0 	pop	{r4, r5, r6, r7, r8, r9, fp, pc}
     f78:	00002020 	.word	0x00002020
     f7c:	00002011 	.word	0x00002011
     f80:	00002009 	.word	0x00002009
     f84:	00002005 	.word	0x00002005
     f88:	00002000 	.word	0x00002000
     f8c:	00001ffa 	.word	0x00001ffa
     f90:	00001ff2 	.word	0x00001ff2
     f94:	00001fee 	.word	0x00001fee
     f98:	00001fe9 	.word	0x00001fe9
     f9c:	00001fe0 	.word	0x00001fe0
     fa0:	00001fdb 	.word	0x00001fdb
     fa4:	00001fe1 	.word	0x00001fe1
     fa8:	00001ff1 	.word	0x00001ff1
     fac:	00002001 	.word	0x00002001
     fb0:	00002008 	.word	0x00002008
     fb4:	00002018 	.word	0x00002018

00000fb8 <arm_read_cp15_fault_address>:

unsigned arm_read_cp15_fault_address(void) {
	unsigned fadr;

	asm volatile(
     fb8:	ee160f10 	mrc	15, 0, r0, cr6, cr0, {0}
	"mrc	p15, 0, %0, c6, c0, 0\n"
	: "=r"(fadr));
	return fadr;
}
     fbc:	e12fff1e 	bx	lr

00000fc0 <delay>:
#endif

extern int vsprintf(char *buf, const char *fmt, va_list args);

int delay(int d) {
	for (;d > 0; d--) {
     fc0:	ea000001 	b	fcc <delay+0xc>
		asm volatile("nop");
     fc4:	e1a00000 	nop			; (mov r0, r0)
#endif

extern int vsprintf(char *buf, const char *fmt, va_list args);

int delay(int d) {
	for (;d > 0; d--) {
     fc8:	e2400001 	sub	r0, r0, #1
     fcc:	e3500000 	cmp	r0, #0
     fd0:	cafffffb 	bgt	fc4 <delay+0x4>
		asm volatile("nop");
	}
	return 0;
}
     fd4:	e3a00000 	mov	r0, #0
     fd8:	e12fff1e 	bx	lr

00000fdc <puts>:

int puts(const char* s) {
     fdc:	e92d4038 	push	{r3, r4, r5, lr}
     fe0:	e1a05000 	mov	r5, r0
     fe4:	e1a04000 	mov	r4, r0
	const char* st = s;
	while (*s) {
     fe8:	ea000000 	b	ff0 <puts+0x14>
		putchar(*s++);
     fec:	eb0000c1 	bl	12f8 <putchar>
     ff0:	e1a03004 	mov	r3, r4
	return 0;
}

int puts(const char* s) {
	const char* st = s;
	while (*s) {
     ff4:	e4d40001 	ldrb	r0, [r4], #1
     ff8:	e3500000 	cmp	r0, #0
     ffc:	1afffffa 	bne	fec <puts+0x10>
		putchar(*s++);
	}
	return s - st;
}
    1000:	e0650003 	rsb	r0, r5, r3
    1004:	e8bd8038 	pop	{r3, r4, r5, pc}

00001008 <printk>:

int printk(const char* s, ...) {
    1008:	e92d000f 	push	{r0, r1, r2, r3}
    100c:	e92d4037 	push	{r0, r1, r2, r4, r5, lr}
	static char prbuf[1024];
	va_list v;
	int r;

	va_start(v, s);
	r = vsprintf(prbuf, s, v);
    1010:	e59f4030 	ldr	r4, [pc, #48]	; 1048 <printk+0x40>
int printk(const char* s, ...) {
	static char prbuf[1024];
	va_list v;
	int r;

	va_start(v, s);
    1014:	e28d201c 	add	r2, sp, #28
	r = vsprintf(prbuf, s, v);
    1018:	e08f4004 	add	r4, pc, r4
    101c:	e59d1018 	ldr	r1, [sp, #24]
    1020:	e1a00004 	mov	r0, r4
int printk(const char* s, ...) {
	static char prbuf[1024];
	va_list v;
	int r;

	va_start(v, s);
    1024:	e58d2004 	str	r2, [sp, #4]
	r = vsprintf(prbuf, s, v);
    1028:	eb00054f 	bl	256c <vsprintf>
    102c:	e1a05000 	mov	r5, r0
	puts(prbuf);
    1030:	e1a00004 	mov	r0, r4
    1034:	ebffffe8 	bl	fdc <puts>
	va_end(v);
	return r;
}
    1038:	e1a00005 	mov	r0, r5
    103c:	e8bd403e 	pop	{r1, r2, r3, r4, r5, lr}
    1040:	e28dd010 	add	sp, sp, #16
    1044:	e12fff1e 	bx	lr
    1048:	000022c0 	.word	0x000022c0

0000104c <memset>:

int memset(void* dst, int pattern, size_t size) {
    104c:	e1a03000 	mov	r3, r0
	char* dstc;
	int i;

	dstc = (char*)dst;
	for (i = 0; i < size; i++) {
    1050:	e3a00000 	mov	r0, #0
    1054:	ea000001 	b	1060 <memset+0x14>
		dstc[i] = pattern;
    1058:	e7c31000 	strb	r1, [r3, r0]
int memset(void* dst, int pattern, size_t size) {
	char* dstc;
	int i;

	dstc = (char*)dst;
	for (i = 0; i < size; i++) {
    105c:	e2800001 	add	r0, r0, #1
    1060:	e1500002 	cmp	r0, r2
    1064:	1afffffb 	bne	1058 <memset+0xc>
		dstc[i] = pattern;
	}
	return size;
}
    1068:	e12fff1e 	bx	lr

0000106c <memcpy>:

int memcpy(char* dst, const char* src, size_t size) {
    106c:	e1a03000 	mov	r3, r0
	int i;

	for (i = 0; i < size; i++) {
    1070:	e3a00000 	mov	r0, #0
    1074:	ea000002 	b	1084 <memcpy+0x18>
		dst[i] = src[i];
    1078:	e7d1c000 	ldrb	ip, [r1, r0]
    107c:	e7c3c000 	strb	ip, [r3, r0]
}

int memcpy(char* dst, const char* src, size_t size) {
	int i;

	for (i = 0; i < size; i++) {
    1080:	e2800001 	add	r0, r0, #1
    1084:	e1500002 	cmp	r0, r2
    1088:	1afffffa 	bne	1078 <memcpy+0xc>
		dst[i] = src[i];
	}
	return size;
}
    108c:	e12fff1e 	bx	lr

00001090 <strlen>:

size_t strlen(const char* s) {
	const char* b = s;

	while (*++s);
    1090:	e1a03000 	mov	r3, r0
    1094:	ea000000 	b	109c <strlen+0xc>
    1098:	e1a03002 	mov	r3, r2
		dst[i] = src[i];
	}
	return size;
}

size_t strlen(const char* s) {
    109c:	e2832001 	add	r2, r3, #1
	const char* b = s;

	while (*++s);
    10a0:	e5d33001 	ldrb	r3, [r3, #1]
    10a4:	e3530000 	cmp	r3, #0
    10a8:	1afffffa 	bne	1098 <strlen+0x8>
	return s - b;
}
    10ac:	e0600002 	rsb	r0, r0, r2
    10b0:	e12fff1e 	bx	lr

000010b4 <strnlen>:

size_t strnlen(const char* s, size_t size) {
    10b4:	e1a03000 	mov	r3, r0
	size_t i;

	for (i = 0; i < size && s[i] != 0; i++);
    10b8:	e3a00000 	mov	r0, #0
    10bc:	ea000000 	b	10c4 <strnlen+0x10>
    10c0:	e2800001 	add	r0, r0, #1
    10c4:	e1500001 	cmp	r0, r1
    10c8:	212fff1e 	bxcs	lr
    10cc:	e7d32000 	ldrb	r2, [r3, r0]
    10d0:	e3520000 	cmp	r2, #0
    10d4:	1afffff9 	bne	10c0 <strnlen+0xc>

	return i;
}
    10d8:	e12fff1e 	bx	lr

000010dc <strcmp>:

int strcmp(const char* ss, const char* sd) {
    10dc:	e92d4010 	push	{r4, lr}
	while (*ss && *sd && *ss++ == *sd++);
    10e0:	e1a02000 	mov	r2, r0
    10e4:	e4d04001 	ldrb	r4, [r0], #1
    10e8:	e1a03001 	mov	r3, r1
    10ec:	e3540000 	cmp	r4, #0
    10f0:	0a000006 	beq	1110 <strcmp+0x34>
    10f4:	e4d1c001 	ldrb	ip, [r1], #1
    10f8:	e35c0000 	cmp	ip, #0
    10fc:	0a000003 	beq	1110 <strcmp+0x34>
    1100:	e154000c 	cmp	r4, ip
    1104:	e1a02000 	mov	r2, r0
    1108:	e1a03001 	mov	r3, r1
    110c:	0afffff3 	beq	10e0 <strcmp+0x4>
	return *ss - *sd;
    1110:	e5d20000 	ldrb	r0, [r2]
    1114:	e5d33000 	ldrb	r3, [r3]
}
    1118:	e0630000 	rsb	r0, r3, r0
    111c:	e8bd8010 	pop	{r4, pc}

00001120 <strchr>:

const char* strchr(const char* s, char c) {
	for (; *s && *s != c; s++);
    1120:	e5d02000 	ldrb	r2, [r0]
    1124:	e1a03000 	mov	r3, r0
    1128:	e3520000 	cmp	r2, #0
    112c:	e2800001 	add	r0, r0, #1
    1130:	1a000002 	bne	1140 <strchr+0x20>
	if (*s == c) {
		return s;
	}
	return NULL;
    1134:	e3510000 	cmp	r1, #0
    1138:	13a03000 	movne	r3, #0
    113c:	ea000001 	b	1148 <strchr+0x28>
	while (*ss && *sd && *ss++ == *sd++);
	return *ss - *sd;
}

const char* strchr(const char* s, char c) {
	for (; *s && *s != c; s++);
    1140:	e1520001 	cmp	r2, r1
    1144:	1afffff5 	bne	1120 <strchr>
	if (*s == c) {
		return s;
	}
	return NULL;
}
    1148:	e1a00003 	mov	r0, r3
    114c:	e12fff1e 	bx	lr

00001150 <debug_buf>:

int debug_buf(const char* head, char* buf, int len) {
    1150:	e1a03000 	mov	r3, r0
	int i;

	printk("\r\nDBG:%s[%d] = \r\n\t", head, len);
    1154:	e59f0040 	ldr	r0, [pc, #64]	; 119c <debug_buf+0x4c>
		return s;
	}
	return NULL;
}

int debug_buf(const char* head, char* buf, int len) {
    1158:	e92d4070 	push	{r4, r5, r6, lr}
	int i;

	printk("\r\nDBG:%s[%d] = \r\n\t", head, len);
    115c:	e08f0000 	add	r0, pc, r0
		return s;
	}
	return NULL;
}

int debug_buf(const char* head, char* buf, int len) {
    1160:	e1a05001 	mov	r5, r1
	int i;

	printk("\r\nDBG:%s[%d] = \r\n\t", head, len);
    1164:	e1a01003 	mov	r1, r3
		return s;
	}
	return NULL;
}

int debug_buf(const char* head, char* buf, int len) {
    1168:	e1a04002 	mov	r4, r2
	int i;

	printk("\r\nDBG:%s[%d] = \r\n\t", head, len);
	for (i = 0; i < len; i++) {
    116c:	e3a06000 	mov	r6, #0
}

int debug_buf(const char* head, char* buf, int len) {
	int i;

	printk("\r\nDBG:%s[%d] = \r\n\t", head, len);
    1170:	ebffffa4 	bl	1008 <printk>
	for (i = 0; i < len; i++) {
    1174:	ea000004 	b	118c <debug_buf+0x3c>
		printk("%.2X ", buf[i]);
    1178:	e59f0020 	ldr	r0, [pc, #32]	; 11a0 <debug_buf+0x50>
    117c:	e7d51006 	ldrb	r1, [r5, r6]
    1180:	e08f0000 	add	r0, pc, r0
    1184:	ebffff9f 	bl	1008 <printk>

int debug_buf(const char* head, char* buf, int len) {
	int i;

	printk("\r\nDBG:%s[%d] = \r\n\t", head, len);
	for (i = 0; i < len; i++) {
    1188:	e2866001 	add	r6, r6, #1
    118c:	e1560004 	cmp	r6, r4
    1190:	bafffff8 	blt	1178 <debug_buf+0x28>
		printk("%.2X ", buf[i]);
	}
	return len;
}
    1194:	e1a00004 	mov	r0, r4
    1198:	e8bd8070 	pop	{r4, r5, r6, pc}
    119c:	00001e40 	.word	0x00001e40
    11a0:	00001e2f 	.word	0x00001e2f

000011a4 <debug_line>:

int debug_line(const char* file, int lin, int nr, ...) {
    11a4:	e92d000c 	push	{r2, r3}
    11a8:	e1a03000 	mov	r3, r0
    11ac:	e92d4073 	push	{r0, r1, r4, r5, r6, lr}
	int val = 0;
	const char* s;
	va_list ap;

	printk("\r\nDBG:%s() L%d\t", file, lin);
    11b0:	e59f00a8 	ldr	r0, [pc, #168]	; 1260 <debug_line+0xbc>
		printk("%.2X ", buf[i]);
	}
	return len;
}

int debug_line(const char* file, int lin, int nr, ...) {
    11b4:	e1a02001 	mov	r2, r1
	int val = 0;
	const char* s;
	va_list ap;

	printk("\r\nDBG:%s() L%d\t", file, lin);
    11b8:	e08f0000 	add	r0, pc, r0
    11bc:	e1a01003 	mov	r1, r3
		printk("%.2X ", buf[i]);
	}
	return len;
}

int debug_line(const char* file, int lin, int nr, ...) {
    11c0:	e59d4018 	ldr	r4, [sp, #24]
	int val = 0;
	const char* s;
	va_list ap;

	printk("\r\nDBG:%s() L%d\t", file, lin);
    11c4:	ebffff8f 	bl	1008 <printk>
	
	va_start(ap, nr);
    11c8:	e28d301c 	add	r3, sp, #28
    11cc:	e58d3004 	str	r3, [sp, #4]
	while (nr-- > 0) {
    11d0:	ea00001c 	b	1248 <debug_line+0xa4>
		s = va_arg(ap, char*);
    11d4:	e59d3004 	ldr	r3, [sp, #4]
		printk("%.2X ", buf[i]);
	}
	return len;
}

int debug_line(const char* file, int lin, int nr, ...) {
    11d8:	e2444002 	sub	r4, r4, #2
    11dc:	e2841001 	add	r1, r4, #1

	printk("\r\nDBG:%s() L%d\t", file, lin);
	
	va_start(ap, nr);
	while (nr-- > 0) {
		s = va_arg(ap, char*);
    11e0:	e2832004 	add	r2, r3, #4
		if (nr-- <= 0) {
    11e4:	e3510000 	cmp	r1, #0

	printk("\r\nDBG:%s() L%d\t", file, lin);
	
	va_start(ap, nr);
	while (nr-- > 0) {
		s = va_arg(ap, char*);
    11e8:	e58d2004 	str	r2, [sp, #4]
    11ec:	e5935000 	ldr	r5, [r3]
		if (nr-- <= 0) {
    11f0:	ca000003 	bgt	1204 <debug_line+0x60>
			printk(s);
    11f4:	e1a00005 	mov	r0, r5
    11f8:	ebffff82 	bl	1008 <printk>
	printk("\r\nDBG:%s() L%d\t", file, lin);
	
	va_start(ap, nr);
	while (nr-- > 0) {
		s = va_arg(ap, char*);
		if (nr-- <= 0) {
    11fc:	e1a00004 	mov	r0, r4
			printk(s);
			break;
    1200:	ea000013 	b	1254 <debug_line+0xb0>
		}
		val = va_arg(ap, int);
    1204:	e2822004 	add	r2, r2, #4
		if (strchr(s, '%') == NULL) {
    1208:	e1a00005 	mov	r0, r5
    120c:	e3a01025 	mov	r1, #37	; 0x25
		s = va_arg(ap, char*);
		if (nr-- <= 0) {
			printk(s);
			break;
		}
		val = va_arg(ap, int);
    1210:	e58d2004 	str	r2, [sp, #4]
    1214:	e5936004 	ldr	r6, [r3, #4]
		if (strchr(s, '%') == NULL) {
    1218:	ebffffc0 	bl	1120 <strchr>
    121c:	e3500000 	cmp	r0, #0
    1220:	1a000005 	bne	123c <debug_line+0x98>
			printk("%s=%d", s, val);
    1224:	e59f0038 	ldr	r0, [pc, #56]	; 1264 <debug_line+0xc0>
    1228:	e1a01005 	mov	r1, r5
    122c:	e1a02006 	mov	r2, r6
    1230:	e08f0000 	add	r0, pc, r0
    1234:	ebffff73 	bl	1008 <printk>
    1238:	ea000002 	b	1248 <debug_line+0xa4>
		} else {
			printk(s, val);
    123c:	e1a00005 	mov	r0, r5
    1240:	e1a01006 	mov	r1, r6
    1244:	ebffff6f 	bl	1008 <printk>
	va_list ap;

	printk("\r\nDBG:%s() L%d\t", file, lin);
	
	va_start(ap, nr);
	while (nr-- > 0) {
    1248:	e3540000 	cmp	r4, #0
		printk("%.2X ", buf[i]);
	}
	return len;
}

int debug_line(const char* file, int lin, int nr, ...) {
    124c:	e2440001 	sub	r0, r4, #1
	va_list ap;

	printk("\r\nDBG:%s() L%d\t", file, lin);
	
	va_start(ap, nr);
	while (nr-- > 0) {
    1250:	caffffdf 	bgt	11d4 <debug_line+0x30>
		}
	}
 	va_end(ap);

	return nr;
}
    1254:	e8bd407c 	pop	{r2, r3, r4, r5, r6, lr}
    1258:	e28dd008 	add	sp, sp, #8
    125c:	e12fff1e 	bx	lr
    1260:	00001dfd 	.word	0x00001dfd
    1264:	00001d95 	.word	0x00001d95

00001268 <uart_init>:

// AM1808 UART2 pins
#define UART2_TXD		4,20,2
#define UART2_RXD		4,16,2

int uart_init(void) {
    1268:	e92d401f 	push	{r0, r1, r2, r3, r4, lr}
	uart_conf_t conf;

	syscfg_kick(AM18X_FALSE);
    126c:	e3a00000 	mov	r0, #0
    1270:	ebfffe09 	bl	a9c <syscfg_kick>

	psc_state_transition(PSC_UART2, PSC_STATE_ENABLE);
    1274:	e3a01003 	mov	r1, #3
    1278:	e3a0002d 	mov	r0, #45	; 0x2d
    127c:	ebfffdda 	bl	9ec <psc_state_transition>

	syscfg_pinmux(UART2_TXD);
    1280:	e3a01014 	mov	r1, #20
    1284:	e3a02002 	mov	r2, #2
    1288:	e3a00004 	mov	r0, #4
    128c:	ebfffe0f 	bl	ad0 <syscfg_pinmux>
	syscfg_pinmux(UART2_RXD);
    1290:	e3a02002 	mov	r2, #2
    1294:	e3a01010 	mov	r1, #16
    1298:	e3a00004 	mov	r0, #4
    129c:	ebfffe0b 	bl	ad0 <syscfg_pinmux>

	uart_init_conf(&conf);
    12a0:	e28d0004 	add	r0, sp, #4
    12a4:	ebfffe50 	bl	bec <uart_init_conf>
	uart_set_conf(UART2, &conf);
    12a8:	e28d1004 	add	r1, sp, #4
    12ac:	e59f000c 	ldr	r0, [pc, #12]	; 12c0 <uart_init+0x58>
    12b0:	ebfffe5a 	bl	c20 <uart_set_conf>

	return 0;
}
    12b4:	e3a00000 	mov	r0, #0
    12b8:	e28dd014 	add	sp, sp, #20
    12bc:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
    12c0:	01d0d000 	.word	0x01d0d000

000012c4 <__putchar>:

int __putchar(int c) {
    12c4:	e92d4010 	push	{r4, lr}
    12c8:	e1a04000 	mov	r4, r0
	while (AM18X_FALSE == uart_state(UART2, STATE_TX_EMPTY));
    12cc:	e59f0020 	ldr	r0, [pc, #32]	; 12f4 <__putchar+0x30>
    12d0:	e3a01000 	mov	r1, #0
    12d4:	ebfffe8c 	bl	d0c <uart_state>
    12d8:	e3500000 	cmp	r0, #0
    12dc:	0afffffa 	beq	12cc <__putchar+0x8>
	uart_write_byte(UART2, c);
    12e0:	e20410ff 	and	r1, r4, #255	; 0xff
    12e4:	e59f0008 	ldr	r0, [pc, #8]	; 12f4 <__putchar+0x30>
    12e8:	ebfffe96 	bl	d48 <uart_write_byte>
	return c;
}
    12ec:	e1a00004 	mov	r0, r4
    12f0:	e8bd8010 	pop	{r4, pc}
    12f4:	01d0d000 	.word	0x01d0d000

000012f8 <putchar>:

int putchar(int c) {
	if (c == '\n') {
    12f8:	e350000a 	cmp	r0, #10
	while (AM18X_FALSE == uart_state(UART2, STATE_TX_EMPTY));
	uart_write_byte(UART2, c);
	return c;
}

int putchar(int c) {
    12fc:	e92d4010 	push	{r4, lr}
    1300:	e1a04000 	mov	r4, r0
	if (c == '\n') {
    1304:	1a000001 	bne	1310 <putchar+0x18>
		__putchar('\r');
    1308:	e3a0000d 	mov	r0, #13
    130c:	ebffffec 	bl	12c4 <__putchar>
	}
	__putchar(c);
    1310:	e1a00004 	mov	r0, r4
    1314:	ebffffea 	bl	12c4 <__putchar>
	return c;
}
    1318:	e1a00004 	mov	r0, r4
    131c:	e8bd8010 	pop	{r4, pc}

00001320 <getchar>:

int getchar(void) {
    1320:	e92d4008 	push	{r3, lr}
	while (AM18X_FALSE == uart_state(UART2, STATE_RX_READY));
    1324:	e59f0018 	ldr	r0, [pc, #24]	; 1344 <getchar+0x24>
    1328:	e3a01002 	mov	r1, #2
    132c:	ebfffe76 	bl	d0c <uart_state>
    1330:	e3500000 	cmp	r0, #0
    1334:	0afffffa 	beq	1324 <getchar+0x4>
	return uart_read_byte(UART2);
    1338:	e59f0004 	ldr	r0, [pc, #4]	; 1344 <getchar+0x24>
    133c:	ebfffe84 	bl	d54 <uart_read_byte>
}
    1340:	e8bd8008 	pop	{r3, pc}
    1344:	01d0d000 	.word	0x01d0d000

00001348 <peekchar>:

int peekchar(void) {
    1348:	e92d4008 	push	{r3, lr}
	if (AM18X_FALSE == uart_state(UART2, STATE_RX_READY)) {
    134c:	e59f0020 	ldr	r0, [pc, #32]	; 1374 <peekchar+0x2c>
    1350:	e3a01002 	mov	r1, #2
    1354:	ebfffe6c 	bl	d0c <uart_state>
    1358:	e3500000 	cmp	r0, #0
    135c:	0a000002 	beq	136c <peekchar+0x24>
		return -1;
	}
	return uart_read_byte(UART2);
    1360:	e59f000c 	ldr	r0, [pc, #12]	; 1374 <peekchar+0x2c>
    1364:	ebfffe7a 	bl	d54 <uart_read_byte>
    1368:	e8bd8008 	pop	{r3, pc}
	return uart_read_byte(UART2);
}

int peekchar(void) {
	if (AM18X_FALSE == uart_state(UART2, STATE_RX_READY)) {
		return -1;
    136c:	e3e00000 	mvn	r0, #0
	}
	return uart_read_byte(UART2);
}
    1370:	e8bd8008 	pop	{r3, pc}
    1374:	01d0d000 	.word	0x01d0d000

00001378 <simple_guess_base>:
/* Works only for digits and letters, but small and fast */
#define TOLOWER(x) ((x) | 0x20)

static unsigned int simple_guess_base(const char *cp)
{
	if (cp[0] == '0') {
    1378:	e5d03000 	ldrb	r3, [r0]
    137c:	e3530030 	cmp	r3, #48	; 0x30
		if (TOLOWER(cp[1]) == 'x' && isxdigit(cp[2]))
			return 16;
		else
			return 8;
	} else {
		return 10;
    1380:	13a0000a 	movne	r0, #10
/* Works only for digits and letters, but small and fast */
#define TOLOWER(x) ((x) | 0x20)

static unsigned int simple_guess_base(const char *cp)
{
	if (cp[0] == '0') {
    1384:	112fff1e 	bxne	lr
		if (TOLOWER(cp[1]) == 'x' && isxdigit(cp[2]))
    1388:	e5d03001 	ldrb	r3, [r0, #1]
    138c:	e3833020 	orr	r3, r3, #32
    1390:	e3530078 	cmp	r3, #120	; 0x78
    1394:	1a000007 	bne	13b8 <simple_guess_base+0x40>
    1398:	e59f3020 	ldr	r3, [pc, #32]	; 13c0 <simple_guess_base+0x48>
    139c:	e79a2003 	ldr	r2, [sl, r3]
    13a0:	e5d03002 	ldrb	r3, [r0, #2]
    13a4:	e7d23003 	ldrb	r3, [r2, r3]
    13a8:	e3130044 	tst	r3, #68	; 0x44
			return 16;
		else
			return 8;
    13ac:	13a00010 	movne	r0, #16
    13b0:	03a00008 	moveq	r0, #8
    13b4:	e12fff1e 	bx	lr
    13b8:	e3a00008 	mov	r0, #8
	} else {
		return 10;
	}
}
    13bc:	e12fff1e 	bx	lr
    13c0:	000031c0 	.word	0x000031c0

000013c4 <skip_atoi>:
}
EXPORT_SYMBOL(strict_strtoll);

static int skip_atoi(const char **s)
{
	int i=0;
    13c4:	e3a03000 	mov	r3, #0

	while (isdigit(**s))
    13c8:	ea000004 	b	13e0 <skip_atoi+0x1c>
		i = i*10 + *((*s)++) - '0';
    13cc:	e2422030 	sub	r2, r2, #48	; 0x30
    13d0:	e3a0c00a 	mov	ip, #10
    13d4:	e023239c 	mla	r3, ip, r3, r2
    13d8:	e2811001 	add	r1, r1, #1
    13dc:	e5801000 	str	r1, [r0]

static int skip_atoi(const char **s)
{
	int i=0;

	while (isdigit(**s))
    13e0:	e5901000 	ldr	r1, [r0]
    13e4:	e59fc018 	ldr	ip, [pc, #24]	; 1404 <skip_atoi+0x40>
    13e8:	e5d12000 	ldrb	r2, [r1]
    13ec:	e79ac00c 	ldr	ip, [sl, ip]
    13f0:	e7dcc002 	ldrb	ip, [ip, r2]
    13f4:	e31c0004 	tst	ip, #4
    13f8:	1afffff3 	bne	13cc <skip_atoi+0x8>
		i = i*10 + *((*s)++) - '0';
	return i;
}
    13fc:	e1a00003 	mov	r0, r3
    1400:	e12fff1e 	bx	lr
    1404:	000031c0 	.word	0x000031c0

00001408 <put_dec_trunc>:

/* Formats correctly any integer in [0,99999].
 * Outputs from one to five digits depending on input.
 * On i386 gcc 4.1.2 -O2: ~250 bytes of code. */
static char* put_dec_trunc(char *buf, unsigned q)
{
    1408:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
	unsigned d3, d2, d1, d0;
	d1 = (q>>4) & 0xf;
    140c:	e1a07221 	lsr	r7, r1, #4
	d2 = (q>>8) & 0xf;
    1410:	e1a04421 	lsr	r4, r1, #8
 * Outputs from one to five digits depending on input.
 * On i386 gcc 4.1.2 -O2: ~250 bytes of code. */
static char* put_dec_trunc(char *buf, unsigned q)
{
	unsigned d3, d2, d1, d0;
	d1 = (q>>4) & 0xf;
    1414:	e207700f 	and	r7, r7, #15
	d2 = (q>>8) & 0xf;
    1418:	e204400f 	and	r4, r4, #15
	d3 = (q>>12);
    141c:	e1a02621 	lsr	r2, r1, #12

	d0 = 6*(d3 + d2 + d1) + (q & 0xf);
    1420:	e087c004 	add	ip, r7, r4

/* Formats correctly any integer in [0,99999].
 * Outputs from one to five digits depending on input.
 * On i386 gcc 4.1.2 -O2: ~250 bytes of code. */
static char* put_dec_trunc(char *buf, unsigned q)
{
    1424:	e1a03000 	mov	r3, r0
	unsigned d3, d2, d1, d0;
	d1 = (q>>4) & 0xf;
	d2 = (q>>8) & 0xf;
	d3 = (q>>12);

	d0 = 6*(d3 + d2 + d1) + (q & 0xf);
    1428:	e08cc002 	add	ip, ip, r2
    142c:	e201000f 	and	r0, r1, #15
    1430:	e3a01006 	mov	r1, #6
    1434:	e021019c 	mla	r1, ip, r1, r0
	q = (d0 * 0xcd) >> 11;
    1438:	e3a050cd 	mov	r5, #205	; 0xcd
    143c:	e0060195 	mul	r6, r5, r1
	d0 = d0 - 10*q;
    1440:	e3a0c00a 	mov	ip, #10
	d1 = (q>>4) & 0xf;
	d2 = (q>>8) & 0xf;
	d3 = (q>>12);

	d0 = 6*(d3 + d2 + d1) + (q & 0xf);
	q = (d0 * 0xcd) >> 11;
    1444:	e1a065a6 	lsr	r6, r6, #11
	d0 = d0 - 10*q;
    1448:	e000069c 	mul	r0, ip, r6
	*buf++ = d0 + '0'; /* least significant digit */
	d1 = q + 9*d3 + 5*d2 + d1;
    144c:	e0848104 	add	r8, r4, r4, lsl #2
	d2 = (q>>8) & 0xf;
	d3 = (q>>12);

	d0 = 6*(d3 + d2 + d1) + (q & 0xf);
	q = (d0 * 0xcd) >> 11;
	d0 = d0 - 10*q;
    1450:	e0601001 	rsb	r1, r0, r1
	*buf++ = d0 + '0'; /* least significant digit */
    1454:	e2811030 	add	r1, r1, #48	; 0x30
    1458:	e1a00003 	mov	r0, r3
    145c:	e4c01001 	strb	r1, [r0], #1
	d1 = q + 9*d3 + 5*d2 + d1;
    1460:	e0821182 	add	r1, r2, r2, lsl #3
    1464:	e0811007 	add	r1, r1, r7
    1468:	e0811008 	add	r1, r1, r8
	if (d1 != 0) {
    146c:	e0916006 	adds	r6, r1, r6
    1470:	08bd81f0 	popeq	{r4, r5, r6, r7, r8, pc}
		q = (d1 * 0xcd) >> 11;
    1474:	e0010695 	mul	r1, r5, r6
		d1 = d1 - 10*q;
		*buf++ = d1 + '0'; /* next digit */
    1478:	e2800001 	add	r0, r0, #1
	q = (d0 * 0xcd) >> 11;
	d0 = d0 - 10*q;
	*buf++ = d0 + '0'; /* least significant digit */
	d1 = q + 9*d3 + 5*d2 + d1;
	if (d1 != 0) {
		q = (d1 * 0xcd) >> 11;
    147c:	e1a015a1 	lsr	r1, r1, #11
		d1 = d1 - 10*q;
    1480:	e007019c 	mul	r7, ip, r1
		*buf++ = d1 + '0'; /* next digit */

		d2 = q + 2*d2;
    1484:	e0814084 	add	r4, r1, r4, lsl #1
	d0 = d0 - 10*q;
	*buf++ = d0 + '0'; /* least significant digit */
	d1 = q + 9*d3 + 5*d2 + d1;
	if (d1 != 0) {
		q = (d1 * 0xcd) >> 11;
		d1 = d1 - 10*q;
    1488:	e0676006 	rsb	r6, r7, r6
		*buf++ = d1 + '0'; /* next digit */
    148c:	e2866030 	add	r6, r6, #48	; 0x30
    1490:	e5c36001 	strb	r6, [r3, #1]

		d2 = q + 2*d2;
		if ((d2 != 0) || (d3 != 0)) {
    1494:	e1943002 	orrs	r3, r4, r2
    1498:	08bd81f0 	popeq	{r4, r5, r6, r7, r8, pc}
			q = (d2 * 0xd) >> 7;
    149c:	e3a0300d 	mov	r3, #13
    14a0:	e0030394 	mul	r3, r4, r3
    14a4:	e1a033a3 	lsr	r3, r3, #7
			d2 = d2 - 10*q;
    14a8:	e001039c 	mul	r1, ip, r3
			*buf++ = d2 + '0'; /* next digit */

			d3 = q + 4*d3;
			if (d3 != 0) {
    14ac:	e0932102 	adds	r2, r3, r2, lsl #2
		*buf++ = d1 + '0'; /* next digit */

		d2 = q + 2*d2;
		if ((d2 != 0) || (d3 != 0)) {
			q = (d2 * 0xd) >> 7;
			d2 = d2 - 10*q;
    14b0:	e0614004 	rsb	r4, r1, r4
			*buf++ = d2 + '0'; /* next digit */
    14b4:	e2844030 	add	r4, r4, #48	; 0x30
    14b8:	e4c04001 	strb	r4, [r0], #1

			d3 = q + 4*d3;
			if (d3 != 0) {
    14bc:	08bd81f0 	popeq	{r4, r5, r6, r7, r8, pc}
				q = (d3 * 0xcd) >> 11;
    14c0:	e0030295 	mul	r3, r5, r2
    14c4:	e1a035a3 	lsr	r3, r3, #11
				d3 = d3 - 10*q;
    14c8:	e00c0c93 	mul	ip, r3, ip
				*buf++ = d3 + '0';  /* next digit */
				if (q != 0)
    14cc:	e3530000 	cmp	r3, #0
			*buf++ = d2 + '0'; /* next digit */

			d3 = q + 4*d3;
			if (d3 != 0) {
				q = (d3 * 0xcd) >> 11;
				d3 = d3 - 10*q;
    14d0:	e06c2002 	rsb	r2, ip, r2
				*buf++ = d3 + '0';  /* next digit */
    14d4:	e2822030 	add	r2, r2, #48	; 0x30
				if (q != 0)
					*buf++ = q + '0';  /* most sign. digit */
    14d8:	12833030 	addne	r3, r3, #48	; 0x30

			d3 = q + 4*d3;
			if (d3 != 0) {
				q = (d3 * 0xcd) >> 11;
				d3 = d3 - 10*q;
				*buf++ = d3 + '0';  /* next digit */
    14dc:	e4c02001 	strb	r2, [r0], #1
				if (q != 0)
					*buf++ = q + '0';  /* most sign. digit */
    14e0:	14c03001 	strbne	r3, [r0], #1
			}
		}
	}
	return buf;
}
    14e4:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

000014e8 <number.clone.0>:
	int			base;
	int			precision;	/* # of digits/chars */
	int			qualifier;
};

static char *number(char *buf, char *end, unsigned long long num,
    14e8:	e92d4bf0 	push	{r4, r5, r6, r7, r8, r9, fp, lr}
    14ec:	e24dd060 	sub	sp, sp, #96	; 0x60
    14f0:	e59d7080 	ldr	r7, [sp, #128]	; 0x80
    14f4:	e58d1004 	str	r1, [sp, #4]
	static const char digits[16] = "0123456789ABCDEF"; /* "GHIJKLMNOPQRSTUVWXYZ"; */

	char tmp[66];
	char sign;
	char locase;
	int need_pfx = ((spec.flags & SPECIAL) && spec.base != 10);
    14f8:	e2171040 	ands	r1, r7, #64	; 0x40
	int			base;
	int			precision;	/* # of digits/chars */
	int			qualifier;
};

static char *number(char *buf, char *end, unsigned long long num,
    14fc:	e1a05000 	mov	r5, r0
    1500:	e59d6084 	ldr	r6, [sp, #132]	; 0x84
	static const char digits[16] = "0123456789ABCDEF"; /* "GHIJKLMNOPQRSTUVWXYZ"; */

	char tmp[66];
	char sign;
	char locase;
	int need_pfx = ((spec.flags & SPECIAL) && spec.base != 10);
    1504:	0a000002 	beq	1514 <number.clone.0+0x2c>
    1508:	e59d1088 	ldr	r1, [sp, #136]	; 0x88
    150c:	e251100a 	subs	r1, r1, #10
    1510:	13a01001 	movne	r1, #1
	int i;

	/* locase = 0 or 0x20. ORing digits or letters with 'locase'
	 * produces same digits or (maybe lowercased) letters */
	locase = (spec.flags & SMALL);
	if (spec.flags & LEFT)
    1514:	e3170010 	tst	r7, #16
	static const char digits[16] = "0123456789ABCDEF"; /* "GHIJKLMNOPQRSTUVWXYZ"; */

	char tmp[66];
	char sign;
	char locase;
	int need_pfx = ((spec.flags & SPECIAL) && spec.base != 10);
    1518:	e58d100c 	str	r1, [sp, #12]
	int i;

	/* locase = 0 or 0x20. ORing digits or letters with 'locase'
	 * produces same digits or (maybe lowercased) letters */
	locase = (spec.flags & SMALL);
    151c:	e2071020 	and	r1, r7, #32
	if (spec.flags & LEFT)
		spec.flags &= ~ZEROPAD;
    1520:	13c77001 	bicne	r7, r7, #1
	int need_pfx = ((spec.flags & SPECIAL) && spec.base != 10);
	int i;

	/* locase = 0 or 0x20. ORing digits or letters with 'locase'
	 * produces same digits or (maybe lowercased) letters */
	locase = (spec.flags & SMALL);
    1524:	e58d1010 	str	r1, [sp, #16]
	if (spec.flags & LEFT)
		spec.flags &= ~ZEROPAD;
	sign = 0;
	if (spec.flags & SIGN) {
    1528:	e2171002 	ands	r1, r7, #2
    152c:	0a00000e 	beq	156c <number.clone.0+0x84>
		if ((signed long long) num < 0) {
    1530:	e3520000 	cmp	r2, #0
    1534:	e2d31000 	sbcs	r1, r3, #0
    1538:	aa000004 	bge	1550 <number.clone.0+0x68>
			sign = '-';
			num = - (signed long long) num;
    153c:	e2722000 	rsbs	r2, r2, #0
    1540:	e2e33000 	rsc	r3, r3, #0
			spec.field_width--;
    1544:	e2466001 	sub	r6, r6, #1
	if (spec.flags & LEFT)
		spec.flags &= ~ZEROPAD;
	sign = 0;
	if (spec.flags & SIGN) {
		if ((signed long long) num < 0) {
			sign = '-';
    1548:	e3a0102d 	mov	r1, #45	; 0x2d
    154c:	ea000006 	b	156c <number.clone.0+0x84>
			num = - (signed long long) num;
			spec.field_width--;
		} else if (spec.flags & PLUS) {
    1550:	e3170004 	tst	r7, #4
			sign = '+';
			spec.field_width--;
    1554:	12466001 	subne	r6, r6, #1
		if ((signed long long) num < 0) {
			sign = '-';
			num = - (signed long long) num;
			spec.field_width--;
		} else if (spec.flags & PLUS) {
			sign = '+';
    1558:	13a0102b 	movne	r1, #43	; 0x2b
	if (spec.flags & SIGN) {
		if ((signed long long) num < 0) {
			sign = '-';
			num = - (signed long long) num;
			spec.field_width--;
		} else if (spec.flags & PLUS) {
    155c:	1a000002 	bne	156c <number.clone.0+0x84>
			sign = '+';
			spec.field_width--;
		} else if (spec.flags & SPACE) {
    1560:	e2171008 	ands	r1, r7, #8
			sign = ' ';
			spec.field_width--;
    1564:	12466001 	subne	r6, r6, #1
			spec.field_width--;
		} else if (spec.flags & PLUS) {
			sign = '+';
			spec.field_width--;
		} else if (spec.flags & SPACE) {
			sign = ' ';
    1568:	13a01020 	movne	r1, #32
	/* locase = 0 or 0x20. ORing digits or letters with 'locase'
	 * produces same digits or (maybe lowercased) letters */
	locase = (spec.flags & SMALL);
	if (spec.flags & LEFT)
		spec.flags &= ~ZEROPAD;
	sign = 0;
    156c:	e58d1008 	str	r1, [sp, #8]
		} else if (spec.flags & SPACE) {
			sign = ' ';
			spec.field_width--;
		}
	}
	if (need_pfx) {
    1570:	e59d100c 	ldr	r1, [sp, #12]
    1574:	e3510000 	cmp	r1, #0
    1578:	0a000003 	beq	158c <number.clone.0+0xa4>
		spec.field_width--;
		if (spec.base == 16)
    157c:	e59d1088 	ldr	r1, [sp, #136]	; 0x88
			sign = ' ';
			spec.field_width--;
		}
	}
	if (need_pfx) {
		spec.field_width--;
    1580:	e2466001 	sub	r6, r6, #1
		if (spec.base == 16)
    1584:	e3510010 	cmp	r1, #16
			spec.field_width--;
    1588:	02466001 	subeq	r6, r6, #1
	}

	/* generate full string in tmp[], in reverse order */
	i = 0;
	if (num == 0)
    158c:	e1921003 	orrs	r1, r2, r3
		tmp[i++] = '0';
    1590:	03a03030 	moveq	r3, #48	; 0x30
    1594:	05cd301c 	strbeq	r3, [sp, #28]
    1598:	03a04001 	moveq	r4, #1
			spec.field_width--;
	}

	/* generate full string in tmp[], in reverse order */
	i = 0;
	if (num == 0)
    159c:	0a00005d 	beq	1718 <number.clone.0+0x230>
	/* Generic code, for any base:
	else do {
		tmp[i++] = (digits[do_div(num,base)] | locase);
	} while (num != 0);
	*/
	else if (spec.base != 10) { /* 8 or 16 */
    15a0:	e59d1088 	ldr	r1, [sp, #136]	; 0x88
    15a4:	e351000a 	cmp	r1, #10
    15a8:	e28d101c 	add	r1, sp, #28
    15ac:	e58d1000 	str	r1, [sp]
    15b0:	0a000016 	beq	1610 <number.clone.0+0x128>
		int mask = spec.base - 1;
    15b4:	e59d1088 	ldr	r1, [sp, #136]	; 0x88
		int shift = 3;
		if (spec.base == 16) shift = 4;
    15b8:	e3a04000 	mov	r4, #0
		tmp[i++] = (digits[do_div(num,base)] | locase);
	} while (num != 0);
	*/
	else if (spec.base != 10) { /* 8 or 16 */
		int mask = spec.base - 1;
		int shift = 3;
    15bc:	e3510010 	cmp	r1, #16
	else do {
		tmp[i++] = (digits[do_div(num,base)] | locase);
	} while (num != 0);
	*/
	else if (spec.base != 10) { /* 8 or 16 */
		int mask = spec.base - 1;
    15c0:	e2419001 	sub	r9, r1, #1
		int shift = 3;
    15c4:	03a08004 	moveq	r8, #4
    15c8:	13a08003 	movne	r8, #3
		if (spec.base == 16) shift = 4;
    15cc:	e1a00002 	mov	r0, r2
    15d0:	e1a01003 	mov	r1, r3
		do {
			tmp[i++] = (digits[((unsigned char)num) & mask] | locase);
    15d4:	e59f327c 	ldr	r3, [pc, #636]	; 1858 <number.clone.0+0x370>
    15d8:	e20020ff 	and	r2, r0, #255	; 0xff
    15dc:	e0022009 	and	r2, r2, r9
    15e0:	e08f3003 	add	r3, pc, r3
    15e4:	e7d33002 	ldrb	r3, [r3, r2]
    15e8:	e59d2010 	ldr	r2, [sp, #16]
    15ec:	e1823003 	orr	r3, r2, r3
    15f0:	e28d201c 	add	r2, sp, #28
    15f4:	e7c23004 	strb	r3, [r2, r4]
			num >>= shift;
    15f8:	e1a02008 	mov	r2, r8
    15fc:	ebfffcc7 	bl	920 <__aeabi_llsr>
	else if (spec.base != 10) { /* 8 or 16 */
		int mask = spec.base - 1;
		int shift = 3;
		if (spec.base == 16) shift = 4;
		do {
			tmp[i++] = (digits[((unsigned char)num) & mask] | locase);
    1600:	e2844001 	add	r4, r4, #1
			num >>= shift;
		} while (num);
    1604:	e1903001 	orrs	r3, r0, r1
    1608:	1afffff1 	bne	15d4 <number.clone.0+0xec>
    160c:	ea000041 	b	1718 <number.clone.0+0x230>
	} else { /* base 10 */
		i = put_dec(tmp, num) - tmp;
    1610:	e28db01c 	add	fp, sp, #28
    1614:	e58d5014 	str	r5, [sp, #20]
/* No inlining helps gcc to use registers better */
static char* put_dec(char *buf, unsigned long long num)
{
	while (1) {
		unsigned rem;
		if (num < 100000)
    1618:	e59f423c 	ldr	r4, [pc, #572]	; 185c <number.clone.0+0x374>
    161c:	e3a05000 	mov	r5, #0
    1620:	e1550003 	cmp	r5, r3
    1624:	01540002 	cmpeq	r4, r2
		int shift = 3;
		if (spec.base == 16) shift = 4;
		do {
			tmp[i++] = (digits[((unsigned char)num) & mask] | locase);
			num >>= shift;
		} while (num);
    1628:	e1a0000b 	mov	r0, fp
    162c:	e28bb005 	add	fp, fp, #5
/* No inlining helps gcc to use registers better */
static char* put_dec(char *buf, unsigned long long num)
{
	while (1) {
		unsigned rem;
		if (num < 100000)
    1630:	3a000005 	bcc	164c <number.clone.0+0x164>
			return put_dec_trunc(buf, num);
    1634:	e1a01002 	mov	r1, r2
    1638:	e59d5014 	ldr	r5, [sp, #20]
    163c:	ebffff71 	bl	1408 <put_dec_trunc>
		do {
			tmp[i++] = (digits[((unsigned char)num) & mask] | locase);
			num >>= shift;
		} while (num);
	} else { /* base 10 */
		i = put_dec(tmp, num) - tmp;
    1640:	e59d1000 	ldr	r1, [sp]
    1644:	e0614000 	rsb	r4, r1, r0
    1648:	ea000032 	b	1718 <number.clone.0+0x230>
{
	while (1) {
		unsigned rem;
		if (num < 100000)
			return put_dec_trunc(buf, num);
		rem = do_div(num, 100000);
    164c:	e59f420c 	ldr	r4, [pc, #524]	; 1860 <number.clone.0+0x378>
    1650:	e1a00002 	mov	r0, r2
    1654:	e1a01003 	mov	r1, r3
    1658:	ebfffba8 	bl	500 <__do_div64>
static char* put_dec_full(char *buf, unsigned q)
{
	/* BTW, if q is in [0,9999], 8-bit ints will be enough, */
	/* but anyway, gcc produces better code with full-sized ints */
	unsigned d3, d2, d1, d0;
	d1 = (q>>4) & 0xf;
    165c:	e1a08221 	lsr	r8, r1, #4
	d2 = (q>>8) & 0xf;
    1660:	e1a0e421 	lsr	lr, r1, #8
    1664:	e20ee00f 	and	lr, lr, #15
static char* put_dec_full(char *buf, unsigned q)
{
	/* BTW, if q is in [0,9999], 8-bit ints will be enough, */
	/* but anyway, gcc produces better code with full-sized ints */
	unsigned d3, d2, d1, d0;
	d1 = (q>>4) & 0xf;
    1668:	e208800f 	and	r8, r8, #15
	d2 = (q>>8) & 0xf;
	d3 = (q>>12);
    166c:	e1a0c621 	lsr	ip, r1, #12
	// (x * 0x67) >> 10:  1100111
	// (x * 0x34) >> 9:    110100 - same
	// (x * 0x1a) >> 8:     11010 - same
	// (x * 0x0d) >> 7:      1101 - same, shortest code (on i386)

	d0 = 6*(d3 + d2 + d1) + (q & 0xf);
    1670:	e088400e 	add	r4, r8, lr
    1674:	e084400c 	add	r4, r4, ip
    1678:	e201000f 	and	r0, r1, #15
    167c:	e3a01006 	mov	r1, #6
    1680:	e0210194 	mla	r1, r4, r1, r0
	q = (d0 * 0xcd) >> 11;
    1684:	e3a040cd 	mov	r4, #205	; 0xcd
    1688:	e0050194 	mul	r5, r4, r1
	d0 = d0 - 10*q;
    168c:	e3a0000a 	mov	r0, #10
	// (x * 0x34) >> 9:    110100 - same
	// (x * 0x1a) >> 8:     11010 - same
	// (x * 0x0d) >> 7:      1101 - same, shortest code (on i386)

	d0 = 6*(d3 + d2 + d1) + (q & 0xf);
	q = (d0 * 0xcd) >> 11;
    1690:	e1a055a5 	lsr	r5, r5, #11
	d0 = d0 - 10*q;
    1694:	e0090590 	mul	r9, r0, r5
    1698:	e0691001 	rsb	r1, r9, r1
	*buf++ = d0 + '0';
    169c:	e2811030 	add	r1, r1, #48	; 0x30
    16a0:	e54b1005 	strb	r1, [fp, #-5]
	d1 = q + 9*d3 + 5*d2 + d1;
    16a4:	e08c118c 	add	r1, ip, ip, lsl #3
    16a8:	e0818008 	add	r8, r1, r8
    16ac:	e08e110e 	add	r1, lr, lr, lsl #2
    16b0:	e0888001 	add	r8, r8, r1
    16b4:	e0885005 	add	r5, r8, r5
		q = (d1 * 0xcd) >> 11;
    16b8:	e0010594 	mul	r1, r4, r5
    16bc:	e1a015a1 	lsr	r1, r1, #11
		d1 = d1 - 10*q;
    16c0:	e0080190 	mul	r8, r0, r1
		*buf++ = d1 + '0';

		d2 = q + 2*d2;
    16c4:	e081e08e 	add	lr, r1, lr, lsl #1
	q = (d0 * 0xcd) >> 11;
	d0 = d0 - 10*q;
	*buf++ = d0 + '0';
	d1 = q + 9*d3 + 5*d2 + d1;
		q = (d1 * 0xcd) >> 11;
		d1 = d1 - 10*q;
    16c8:	e0685005 	rsb	r5, r8, r5
		*buf++ = d1 + '0';
    16cc:	e2855030 	add	r5, r5, #48	; 0x30
    16d0:	e54b5004 	strb	r5, [fp, #-4]

		d2 = q + 2*d2;
			q = (d2 * 0xd) >> 7;
    16d4:	e3a0500d 	mov	r5, #13
    16d8:	e005059e 	mul	r5, lr, r5
    16dc:	e1a053a5 	lsr	r5, r5, #7
			d2 = d2 - 10*q;
			*buf++ = d2 + '0';

			d3 = q + 4*d3;
    16e0:	e085c10c 	add	ip, r5, ip, lsl #2
				q = (d3 * 0xcd) >> 11; /* - shorter code */
    16e4:	e004049c 	mul	r4, ip, r4
		d1 = d1 - 10*q;
		*buf++ = d1 + '0';

		d2 = q + 2*d2;
			q = (d2 * 0xd) >> 7;
			d2 = d2 - 10*q;
    16e8:	e0010590 	mul	r1, r0, r5
			*buf++ = d2 + '0';

			d3 = q + 4*d3;
				q = (d3 * 0xcd) >> 11; /* - shorter code */
    16ec:	e1a045a4 	lsr	r4, r4, #11
				/* q = (d3 * 0x67) >> 10; - would also work */
				d3 = d3 - 10*q;
    16f0:	e0000094 	mul	r0, r4, r0
		d1 = d1 - 10*q;
		*buf++ = d1 + '0';

		d2 = q + 2*d2;
			q = (d2 * 0xd) >> 7;
			d2 = d2 - 10*q;
    16f4:	e061100e 	rsb	r1, r1, lr
			*buf++ = d2 + '0';

			d3 = q + 4*d3;
				q = (d3 * 0xcd) >> 11; /* - shorter code */
				/* q = (d3 * 0x67) >> 10; - would also work */
				d3 = d3 - 10*q;
    16f8:	e060000c 	rsb	r0, r0, ip
		*buf++ = d1 + '0';

		d2 = q + 2*d2;
			q = (d2 * 0xd) >> 7;
			d2 = d2 - 10*q;
			*buf++ = d2 + '0';
    16fc:	e2811030 	add	r1, r1, #48	; 0x30

			d3 = q + 4*d3;
				q = (d3 * 0xcd) >> 11; /* - shorter code */
				/* q = (d3 * 0x67) >> 10; - would also work */
				d3 = d3 - 10*q;
				*buf++ = d3 + '0';
    1700:	e2800030 	add	r0, r0, #48	; 0x30
					*buf++ = q + '0';
    1704:	e2844030 	add	r4, r4, #48	; 0x30
		*buf++ = d1 + '0';

		d2 = q + 2*d2;
			q = (d2 * 0xd) >> 7;
			d2 = d2 - 10*q;
			*buf++ = d2 + '0';
    1708:	e54b1003 	strb	r1, [fp, #-3]

			d3 = q + 4*d3;
				q = (d3 * 0xcd) >> 11; /* - shorter code */
				/* q = (d3 * 0x67) >> 10; - would also work */
				d3 = d3 - 10*q;
				*buf++ = d3 + '0';
    170c:	e54b0002 	strb	r0, [fp, #-2]
					*buf++ = q + '0';
    1710:	e54b4001 	strb	r4, [fp, #-1]
    1714:	eaffffbf 	b	1618 <number.clone.0+0x130>
    1718:	e59d308c 	ldr	r3, [sp, #140]	; 0x8c
    171c:	e1540003 	cmp	r4, r3
    1720:	a1a03004 	movge	r3, r4
    1724:	b1a03003 	movlt	r3, r3
	/* printing 100 using %2d gives "100", not "00" */
	if (i > spec.precision)
		spec.precision = i;
	/* leading space padding */
	spec.field_width -= spec.precision;
	if (!(spec.flags & (ZEROPAD+LEFT))) {
    1728:	e3170011 	tst	r7, #17

	/* printing 100 using %2d gives "100", not "00" */
	if (i > spec.precision)
		spec.precision = i;
	/* leading space padding */
	spec.field_width -= spec.precision;
    172c:	e0636006 	rsb	r6, r3, r6
	if (!(spec.flags & (ZEROPAD+LEFT))) {
    1730:	1a000007 	bne	1754 <number.clone.0+0x26c>
    1734:	ea000004 	b	174c <number.clone.0+0x264>
		while(--spec.field_width >= 0) {
			if (buf < end)
    1738:	e59d2004 	ldr	r2, [sp, #4]
    173c:	e1550002 	cmp	r5, r2
				*buf = ' ';
    1740:	33a02020 	movcc	r2, #32
    1744:	35c52000 	strbcc	r2, [r5]
			++buf;
    1748:	e2855001 	add	r5, r5, #1
	if (i > spec.precision)
		spec.precision = i;
	/* leading space padding */
	spec.field_width -= spec.precision;
	if (!(spec.flags & (ZEROPAD+LEFT))) {
		while(--spec.field_width >= 0) {
    174c:	e2566001 	subs	r6, r6, #1
    1750:	5afffff8 	bpl	1738 <number.clone.0+0x250>
				*buf = ' ';
			++buf;
		}
	}
	/* sign */
	if (sign) {
    1754:	e59d1008 	ldr	r1, [sp, #8]
    1758:	e3510000 	cmp	r1, #0
    175c:	0a000003 	beq	1770 <number.clone.0+0x288>
		if (buf < end)
    1760:	e59d2004 	ldr	r2, [sp, #4]
    1764:	e1550002 	cmp	r5, r2
			*buf = sign;
    1768:	35c51000 	strbcc	r1, [r5]
		++buf;
    176c:	e2855001 	add	r5, r5, #1
	}
	/* "0x" / "0" prefix */
	if (need_pfx) {
    1770:	e59d100c 	ldr	r1, [sp, #12]
    1774:	e3510000 	cmp	r1, #0
    1778:	0a00000d 	beq	17b4 <number.clone.0+0x2cc>
		if (buf < end)
    177c:	e59d2004 	ldr	r2, [sp, #4]
    1780:	e1550002 	cmp	r5, r2
			*buf = '0';
    1784:	33a02030 	movcc	r2, #48	; 0x30
    1788:	35c52000 	strbcc	r2, [r5]
		++buf;
		if (spec.base == 16) {
    178c:	e59d1088 	ldr	r1, [sp, #136]	; 0x88
	}
	/* "0x" / "0" prefix */
	if (need_pfx) {
		if (buf < end)
			*buf = '0';
		++buf;
    1790:	e2855001 	add	r5, r5, #1
		if (spec.base == 16) {
    1794:	e3510010 	cmp	r1, #16
    1798:	1a000005 	bne	17b4 <number.clone.0+0x2cc>
			if (buf < end)
    179c:	e59d2004 	ldr	r2, [sp, #4]
    17a0:	e1550002 	cmp	r5, r2
				*buf = ('X' | locase);
    17a4:	359d1010 	ldrcc	r1, [sp, #16]
    17a8:	33812058 	orrcc	r2, r1, #88	; 0x58
    17ac:	35c52000 	strbcc	r2, [r5]
			++buf;
    17b0:	e2855001 	add	r5, r5, #1
		}
	}
	/* zero or space padding */
	if (!(spec.flags & LEFT)) {
    17b4:	e3170010 	tst	r7, #16
    17b8:	1a00000f 	bne	17fc <number.clone.0+0x314>
		char c = (spec.flags & ZEROPAD) ? '0' : ' ';
    17bc:	e3170001 	tst	r7, #1
    17c0:	03a02020 	moveq	r2, #32
    17c4:	13a02030 	movne	r2, #48	; 0x30
    17c8:	ea000003 	b	17dc <number.clone.0+0x2f4>
		while (--spec.field_width >= 0) {
			if (buf < end)
    17cc:	e59d1004 	ldr	r1, [sp, #4]
    17d0:	e1550001 	cmp	r5, r1
				*buf = c;
    17d4:	35c52000 	strbcc	r2, [r5]
			++buf;
    17d8:	e2855001 	add	r5, r5, #1
		}
	}
	/* zero or space padding */
	if (!(spec.flags & LEFT)) {
		char c = (spec.flags & ZEROPAD) ? '0' : ' ';
		while (--spec.field_width >= 0) {
    17dc:	e2566001 	subs	r6, r6, #1
    17e0:	5afffff9 	bpl	17cc <number.clone.0+0x2e4>
    17e4:	ea000004 	b	17fc <number.clone.0+0x314>
			++buf;
		}
	}
	/* hmm even more zero padding? */
	while (i <= --spec.precision) {
		if (buf < end)
    17e8:	e59d2004 	ldr	r2, [sp, #4]
    17ec:	e1550002 	cmp	r5, r2
			*buf = '0';
    17f0:	33a02030 	movcc	r2, #48	; 0x30
    17f4:	35c52000 	strbcc	r2, [r5]
		++buf;
    17f8:	e2855001 	add	r5, r5, #1
				*buf = c;
			++buf;
		}
	}
	/* hmm even more zero padding? */
	while (i <= --spec.precision) {
    17fc:	e2433001 	sub	r3, r3, #1
    1800:	e1540003 	cmp	r4, r3
    1804:	dafffff7 	ble	17e8 <number.clone.0+0x300>
    1808:	ea000005 	b	1824 <number.clone.0+0x33c>
			*buf = '0';
		++buf;
	}
	/* actual digits of result */
	while (--i >= 0) {
		if (buf < end)
    180c:	e59d3004 	ldr	r3, [sp, #4]
    1810:	e1550003 	cmp	r5, r3
			*buf = tmp[i];
    1814:	328d301c 	addcc	r3, sp, #28
    1818:	37d33004 	ldrbcc	r3, [r3, r4]
    181c:	35c53000 	strbcc	r3, [r5]
		++buf;
    1820:	e2855001 	add	r5, r5, #1
		if (buf < end)
			*buf = '0';
		++buf;
	}
	/* actual digits of result */
	while (--i >= 0) {
    1824:	e2544001 	subs	r4, r4, #1
    1828:	5afffff7 	bpl	180c <number.clone.0+0x324>
    182c:	ea000004 	b	1844 <number.clone.0+0x35c>
			*buf = tmp[i];
		++buf;
	}
	/* trailing space padding */
	while (--spec.field_width >= 0) {
		if (buf < end)
    1830:	e59d1004 	ldr	r1, [sp, #4]
    1834:	e1550001 	cmp	r5, r1
			*buf = ' ';
    1838:	33a03020 	movcc	r3, #32
    183c:	35c53000 	strbcc	r3, [r5]
		++buf;
    1840:	e2855001 	add	r5, r5, #1
		if (buf < end)
			*buf = tmp[i];
		++buf;
	}
	/* trailing space padding */
	while (--spec.field_width >= 0) {
    1844:	e2566001 	subs	r6, r6, #1
    1848:	5afffff8 	bpl	1830 <number.clone.0+0x348>
		if (buf < end)
			*buf = ' ';
		++buf;
	}
	return buf;
}
    184c:	e1a00005 	mov	r0, r5
    1850:	e28dd060 	add	sp, sp, #96	; 0x60
    1854:	e8bd8bf0 	pop	{r4, r5, r6, r7, r8, r9, fp, pc}
    1858:	000019eb 	.word	0x000019eb
    185c:	0001869f 	.word	0x0001869f
    1860:	000186a0 	.word	0x000186a0

00001864 <string.clone.2>:

static char *string(char *buf, char *end, char *s, struct printf_spec spec)
    1864:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    1868:	e59d7018 	ldr	r7, [sp, #24]
{
	int len, i;

	if ((unsigned long)s < PAGE_SIZE)
    186c:	e352001f 	cmp	r2, #31
		++buf;
	}
	return buf;
}

static char *string(char *buf, char *end, char *s, struct printf_spec spec)
    1870:	e1a04000 	mov	r4, r0
    1874:	e1a05001 	mov	r5, r1
    1878:	e1a06002 	mov	r6, r2
    187c:	e1a08003 	mov	r8, r3
{
	int len, i;

	if ((unsigned long)s < PAGE_SIZE)
		s = "<NULL>";
    1880:	959f6088 	ldrls	r6, [pc, #136]	; 1910 <string.clone.2+0xac>
    1884:	908f6006 	addls	r6, pc, r6

	len = strnlen(s, spec.precision);
    1888:	e1a00006 	mov	r0, r6
    188c:	e59d101c 	ldr	r1, [sp, #28]
    1890:	ebfffe07 	bl	10b4 <strnlen>

	if (!(spec.flags & LEFT)) {
    1894:	e3180010 	tst	r8, #16
    1898:	1a000008 	bne	18c0 <string.clone.2+0x5c>
    189c:	ea000003 	b	18b0 <string.clone.2+0x4c>
		while (len < spec.field_width--) {
			if (buf < end)
    18a0:	e1540005 	cmp	r4, r5
				*buf = ' ';
    18a4:	33a03020 	movcc	r3, #32
    18a8:	35c43000 	strbcc	r3, [r4]
			++buf;
    18ac:	e2844001 	add	r4, r4, #1
		s = "<NULL>";

	len = strnlen(s, spec.precision);

	if (!(spec.flags & LEFT)) {
		while (len < spec.field_width--) {
    18b0:	e2477001 	sub	r7, r7, #1
		++buf;
	}
	return buf;
}

static char *string(char *buf, char *end, char *s, struct printf_spec spec)
    18b4:	e2873001 	add	r3, r7, #1
		s = "<NULL>";

	len = strnlen(s, spec.precision);

	if (!(spec.flags & LEFT)) {
		while (len < spec.field_width--) {
    18b8:	e1500003 	cmp	r0, r3
    18bc:	bafffff7 	blt	18a0 <string.clone.2+0x3c>
static char *string(char *buf, char *end, char *s, struct printf_spec spec)
{
	int len, i;

	if ((unsigned long)s < PAGE_SIZE)
		s = "<NULL>";
    18c0:	e1a03004 	mov	r3, r4
			if (buf < end)
				*buf = ' ';
			++buf;
		}
	}
	for (i = 0; i < len; ++i) {
    18c4:	e3a02000 	mov	r2, #0
    18c8:	ea000004 	b	18e0 <string.clone.2+0x7c>
		if (buf < end)
    18cc:	e1530005 	cmp	r3, r5
			*buf = *s;
    18d0:	37d61002 	ldrbcc	r1, [r6, r2]
		++buf; ++s;
    18d4:	e2833001 	add	r3, r3, #1
			++buf;
		}
	}
	for (i = 0; i < len; ++i) {
		if (buf < end)
			*buf = *s;
    18d8:	37c41002 	strbcc	r1, [r4, r2]
			if (buf < end)
				*buf = ' ';
			++buf;
		}
	}
	for (i = 0; i < len; ++i) {
    18dc:	e2822001 	add	r2, r2, #1
    18e0:	e1520000 	cmp	r2, r0
    18e4:	bafffff8 	blt	18cc <string.clone.2+0x68>
    18e8:	ea000004 	b	1900 <string.clone.2+0x9c>
		if (buf < end)
			*buf = *s;
		++buf; ++s;
	}
	while (len < spec.field_width--) {
		if (buf < end)
    18ec:	e1530005 	cmp	r3, r5
			*buf = ' ';
    18f0:	33a02020 	movcc	r2, #32
    18f4:	35c32000 	strbcc	r2, [r3]
		++buf;
    18f8:	e2477001 	sub	r7, r7, #1
    18fc:	e2833001 	add	r3, r3, #1
	for (i = 0; i < len; ++i) {
		if (buf < end)
			*buf = *s;
		++buf; ++s;
	}
	while (len < spec.field_width--) {
    1900:	e1500007 	cmp	r0, r7
    1904:	bafffff8 	blt	18ec <string.clone.2+0x88>
		if (buf < end)
			*buf = ' ';
		++buf;
	}
	return buf;
}
    1908:	e1a00003 	mov	r0, r3
    190c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    1910:	00001758 	.word	0x00001758

00001914 <simple_strtoul>:
 */
unsigned long simple_strtoul(const char *cp, char **endp, unsigned int base)
{
	unsigned long result = 0;

	if (!base)
    1914:	e3520000 	cmp	r2, #0
 * @cp: The start of the string
 * @endp: A pointer to the end of the parsed string will be placed here
 * @base: The number base to use
 */
unsigned long simple_strtoul(const char *cp, char **endp, unsigned int base)
{
    1918:	e92d4038 	push	{r3, r4, r5, lr}
    191c:	e1a04000 	mov	r4, r0
    1920:	e1a05001 	mov	r5, r1
	unsigned long result = 0;

	if (!base)
    1924:	1a000001 	bne	1930 <simple_strtoul+0x1c>
		base = simple_guess_base(cp);
    1928:	ebfffe92 	bl	1378 <simple_guess_base>
    192c:	e1a02000 	mov	r2, r0

	if (base == 16 && cp[0] == '0' && TOLOWER(cp[1]) == 'x')
    1930:	e3520010 	cmp	r2, #16
    1934:	1a000006 	bne	1954 <simple_strtoul+0x40>
    1938:	e5d43000 	ldrb	r3, [r4]
    193c:	e3530030 	cmp	r3, #48	; 0x30
    1940:	1a000003 	bne	1954 <simple_strtoul+0x40>
    1944:	e5d43001 	ldrb	r3, [r4, #1]
    1948:	e3833020 	orr	r3, r3, #32
    194c:	e3530078 	cmp	r3, #120	; 0x78
		cp += 2;
    1950:	02844002 	addeq	r4, r4, #2
 * @cp: The start of the string
 * @endp: A pointer to the end of the parsed string will be placed here
 * @base: The number base to use
 */
unsigned long simple_strtoul(const char *cp, char **endp, unsigned int base)
{
    1954:	e3a00000 	mov	r0, #0
    1958:	ea000006 	b	1978 <simple_strtoul+0x64>
		cp += 2;

	while (isxdigit(*cp)) {
		unsigned int value;

		value = isdigit(*cp) ? *cp - '0' : TOLOWER(*cp) - 'a' + 10;
    195c:	e3110004 	tst	r1, #4
    1960:	03833020 	orreq	r3, r3, #32
    1964:	12433030 	subne	r3, r3, #48	; 0x30
    1968:	02433057 	subeq	r3, r3, #87	; 0x57
		if (value >= base)
    196c:	e1530002 	cmp	r3, r2
    1970:	2a000007 	bcs	1994 <simple_strtoul+0x80>
			break;
		result = result * base + value;
    1974:	e0203092 	mla	r0, r2, r0, r3
		base = simple_guess_base(cp);

	if (base == 16 && cp[0] == '0' && TOLOWER(cp[1]) == 'x')
		cp += 2;

	while (isxdigit(*cp)) {
    1978:	e59f1020 	ldr	r1, [pc, #32]	; 19a0 <simple_strtoul+0x8c>
		unsigned int value;

		value = isdigit(*cp) ? *cp - '0' : TOLOWER(*cp) - 'a' + 10;
		if (value >= base)
			break;
		result = result * base + value;
    197c:	e1a0c004 	mov	ip, r4
		base = simple_guess_base(cp);

	if (base == 16 && cp[0] == '0' && TOLOWER(cp[1]) == 'x')
		cp += 2;

	while (isxdigit(*cp)) {
    1980:	e79a1001 	ldr	r1, [sl, r1]
    1984:	e4d43001 	ldrb	r3, [r4], #1
    1988:	e7d11003 	ldrb	r1, [r1, r3]
    198c:	e3110044 	tst	r1, #68	; 0x44
    1990:	1afffff1 	bne	195c <simple_strtoul+0x48>
			break;
		result = result * base + value;
		cp++;
	}

	if (endp)
    1994:	e3550000 	cmp	r5, #0
		*endp = (char *)cp;
    1998:	1585c000 	strne	ip, [r5]
	return result;
}
    199c:	e8bd8038 	pop	{r3, r4, r5, pc}
    19a0:	000031c0 	.word	0x000031c0

000019a4 <simple_strtol>:
 * @cp: The start of the string
 * @endp: A pointer to the end of the parsed string will be placed here
 * @base: The number base to use
 */
long simple_strtol(const char *cp, char **endp, unsigned int base)
{
    19a4:	e92d4010 	push	{r4, lr}
	if(*cp == '-')
    19a8:	e5d0c000 	ldrb	ip, [r0]
    19ac:	e35c002d 	cmp	ip, #45	; 0x2d
    19b0:	1a000003 	bne	19c4 <simple_strtol+0x20>
		return -simple_strtoul(cp + 1, endp, base);
    19b4:	e2800001 	add	r0, r0, #1
    19b8:	ebffffd5 	bl	1914 <simple_strtoul>
	return simple_strtoul(cp, endp, base);
}
    19bc:	e2600000 	rsb	r0, r0, #0
    19c0:	e8bd8010 	pop	{r4, pc}
    19c4:	e8bd4010 	pop	{r4, lr}
 */
long simple_strtol(const char *cp, char **endp, unsigned int base)
{
	if(*cp == '-')
		return -simple_strtoul(cp + 1, endp, base);
	return simple_strtoul(cp, endp, base);
    19c8:	eaffffd1 	b	1914 <simple_strtoul>

000019cc <simple_strtoull>:
 */
unsigned long long simple_strtoull(const char *cp, char **endp, unsigned int base)
{
	unsigned long long result = 0;

	if (!base)
    19cc:	e3520000 	cmp	r2, #0
 * @cp: The start of the string
 * @endp: A pointer to the end of the parsed string will be placed here
 * @base: The number base to use
 */
unsigned long long simple_strtoull(const char *cp, char **endp, unsigned int base)
{
    19d0:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    19d4:	e1a04000 	mov	r4, r0
    19d8:	e1a08001 	mov	r8, r1
	unsigned long long result = 0;

	if (!base)
    19dc:	1a000001 	bne	19e8 <simple_strtoull+0x1c>
		base = simple_guess_base(cp);
    19e0:	ebfffe64 	bl	1378 <simple_guess_base>
    19e4:	e1a02000 	mov	r2, r0

	if (base == 16 && cp[0] == '0' && TOLOWER(cp[1]) == 'x')
    19e8:	e3520010 	cmp	r2, #16
    19ec:	1a000006 	bne	1a0c <simple_strtoull+0x40>
    19f0:	e5d43000 	ldrb	r3, [r4]
    19f4:	e3530030 	cmp	r3, #48	; 0x30
    19f8:	1a000003 	bne	1a0c <simple_strtoull+0x40>
    19fc:	e5d43001 	ldrb	r3, [r4, #1]
    1a00:	e3833020 	orr	r3, r3, #32
    1a04:	e3530078 	cmp	r3, #120	; 0x78
		cp += 2;
    1a08:	02844002 	addeq	r4, r4, #2
    1a0c:	e1a03004 	mov	r3, r4
 * @cp: The start of the string
 * @endp: A pointer to the end of the parsed string will be placed here
 * @base: The number base to use
 */
unsigned long long simple_strtoull(const char *cp, char **endp, unsigned int base)
{
    1a10:	e3a05000 	mov	r5, #0
    1a14:	e3a04000 	mov	r4, #0
    1a18:	ea000009 	b	1a44 <simple_strtoull+0x78>
		cp += 2;

	while (isxdigit(*cp)) {
		unsigned int value;

		value = isdigit(*cp) ? *cp - '0' : TOLOWER(*cp) - 'a' + 10;
    1a1c:	e3100004 	tst	r0, #4
    1a20:	03811020 	orreq	r1, r1, #32
    1a24:	12411030 	subne	r1, r1, #48	; 0x30
    1a28:	02411057 	subeq	r1, r1, #87	; 0x57
		if (value >= base)
    1a2c:	e1510002 	cmp	r1, r2
    1a30:	2a00000a 	bcs	1a60 <simple_strtoull+0x94>
			break;
		result = result * base + value;
    1a34:	e0876294 	umull	r6, r7, r4, r2
    1a38:	e0277592 	mla	r7, r2, r5, r7
    1a3c:	e0964001 	adds	r4, r6, r1
    1a40:	e2a75000 	adc	r5, r7, #0
		base = simple_guess_base(cp);

	if (base == 16 && cp[0] == '0' && TOLOWER(cp[1]) == 'x')
		cp += 2;

	while (isxdigit(*cp)) {
    1a44:	e59f0028 	ldr	r0, [pc, #40]	; 1a74 <simple_strtoull+0xa8>
		unsigned int value;

		value = isdigit(*cp) ? *cp - '0' : TOLOWER(*cp) - 'a' + 10;
		if (value >= base)
			break;
		result = result * base + value;
    1a48:	e1a0c003 	mov	ip, r3
		base = simple_guess_base(cp);

	if (base == 16 && cp[0] == '0' && TOLOWER(cp[1]) == 'x')
		cp += 2;

	while (isxdigit(*cp)) {
    1a4c:	e79a0000 	ldr	r0, [sl, r0]
    1a50:	e4d31001 	ldrb	r1, [r3], #1
    1a54:	e7d00001 	ldrb	r0, [r0, r1]
    1a58:	e3100044 	tst	r0, #68	; 0x44
    1a5c:	1affffee 	bne	1a1c <simple_strtoull+0x50>
			break;
		result = result * base + value;
		cp++;
	}

	if (endp)
    1a60:	e3580000 	cmp	r8, #0
		*endp = (char *)cp;
    1a64:	1588c000 	strne	ip, [r8]
	return result;
}
    1a68:	e1a00004 	mov	r0, r4
    1a6c:	e1a01005 	mov	r1, r5
    1a70:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    1a74:	000031c0 	.word	0x000031c0

00001a78 <simple_strtoll>:
 * @cp: The start of the string
 * @endp: A pointer to the end of the parsed string will be placed here
 * @base: The number base to use
 */
long long simple_strtoll(const char *cp, char **endp, unsigned int base)
{
    1a78:	e92d4010 	push	{r4, lr}
	if(*cp=='-')
    1a7c:	e5d0c000 	ldrb	ip, [r0]
    1a80:	e35c002d 	cmp	ip, #45	; 0x2d
    1a84:	1a000006 	bne	1aa4 <simple_strtoll+0x2c>
		return -simple_strtoull(cp + 1, endp, base);
    1a88:	e2800001 	add	r0, r0, #1
    1a8c:	ebffffce 	bl	19cc <simple_strtoull>
    1a90:	e2702000 	rsbs	r2, r0, #0
    1a94:	e2e13000 	rsc	r3, r1, #0
	return simple_strtoull(cp, endp, base);
}
    1a98:	e1a00002 	mov	r0, r2
    1a9c:	e1a01003 	mov	r1, r3
    1aa0:	e8bd8010 	pop	{r4, pc}
    1aa4:	e8bd4010 	pop	{r4, lr}
 */
long long simple_strtoll(const char *cp, char **endp, unsigned int base)
{
	if(*cp=='-')
		return -simple_strtoull(cp + 1, endp, base);
	return simple_strtoull(cp, endp, base);
    1aa8:	eaffffc7 	b	19cc <simple_strtoull>

00001aac <strict_strtoul>:
{
	char *tail;
	unsigned long val;
	size_t len;

	*res = 0;
    1aac:	e3a03000 	mov	r3, #0
 *
 * simple_strtoul just ignores the successive invalid characters and
 * return the converted value of prefix part of the string.
 */
int strict_strtoul(const char *cp, unsigned int base, unsigned long *res)
{
    1ab0:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	char *tail;
	unsigned long val;
	size_t len;

	*res = 0;
    1ab4:	e5823000 	str	r3, [r2]
 *
 * simple_strtoul just ignores the successive invalid characters and
 * return the converted value of prefix part of the string.
 */
int strict_strtoul(const char *cp, unsigned int base, unsigned long *res)
{
    1ab8:	e1a04000 	mov	r4, r0
    1abc:	e1a07001 	mov	r7, r1
    1ac0:	e1a05002 	mov	r5, r2
	char *tail;
	unsigned long val;
	size_t len;

	*res = 0;
	len = strlen(cp);
    1ac4:	ebfffd71 	bl	1090 <strlen>
	if (len == 0)
    1ac8:	e2506000 	subs	r6, r0, #0
    1acc:	0a000012 	beq	1b1c <strict_strtoul+0x70>
		return -EINVAL;

	val = simple_strtoul(cp, &tail, base);
    1ad0:	e1a00004 	mov	r0, r4
    1ad4:	e28d1004 	add	r1, sp, #4
    1ad8:	e1a02007 	mov	r2, r7
    1adc:	ebffff8c 	bl	1914 <simple_strtoul>
	if (tail == cp)
    1ae0:	e59d3004 	ldr	r3, [sp, #4]
    1ae4:	e1530004 	cmp	r3, r4
    1ae8:	0a00000b 	beq	1b1c <strict_strtoul+0x70>
		return -EINVAL;
	if ((*tail == '\0') ||
    1aec:	e5d32000 	ldrb	r2, [r3]
    1af0:	e3520000 	cmp	r2, #0
    1af4:	0a000005 	beq	1b10 <strict_strtoul+0x64>
		((len == (size_t)(tail - cp) + 1) && (*tail == '\n'))) {
    1af8:	e0643003 	rsb	r3, r4, r3
    1afc:	e2833001 	add	r3, r3, #1
		return -EINVAL;

	val = simple_strtoul(cp, &tail, base);
	if (tail == cp)
		return -EINVAL;
	if ((*tail == '\0') ||
    1b00:	e1560003 	cmp	r6, r3
    1b04:	1a000004 	bne	1b1c <strict_strtoul+0x70>
		((len == (size_t)(tail - cp) + 1) && (*tail == '\n'))) {
    1b08:	e352000a 	cmp	r2, #10
    1b0c:	1a000002 	bne	1b1c <strict_strtoul+0x70>
		*res = val;
    1b10:	e5850000 	str	r0, [r5]
		return 0;
    1b14:	e3a00000 	mov	r0, #0
    1b18:	ea000000 	b	1b20 <strict_strtoul+0x74>
	}

	return -EINVAL;
    1b1c:	e3e00000 	mvn	r0, #0
}
    1b20:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

00001b24 <strict_strtol>:
 *
 * It returns 0 if conversion is successful and *res is set to the converted
 * value, otherwise it returns -EINVAL and *res is set to 0.
 */
int strict_strtol(const char *cp, unsigned int base, long *res)
{
    1b24:	e92d4010 	push	{r4, lr}
	int ret;
	if (*cp == '-') {
    1b28:	e5d0c000 	ldrb	ip, [r0]
 *
 * It returns 0 if conversion is successful and *res is set to the converted
 * value, otherwise it returns -EINVAL and *res is set to 0.
 */
int strict_strtol(const char *cp, unsigned int base, long *res)
{
    1b2c:	e1a04002 	mov	r4, r2
	int ret;
	if (*cp == '-') {
    1b30:	e35c002d 	cmp	ip, #45	; 0x2d
    1b34:	1a000006 	bne	1b54 <strict_strtol+0x30>
		ret = strict_strtoul(cp + 1, base, (unsigned long *)res);
    1b38:	e2800001 	add	r0, r0, #1
    1b3c:	ebffffda 	bl	1aac <strict_strtoul>
		if (!ret)
    1b40:	e3500000 	cmp	r0, #0
			*res = -(*res);
    1b44:	05943000 	ldreq	r3, [r4]
    1b48:	02633000 	rsbeq	r3, r3, #0
    1b4c:	05843000 	streq	r3, [r4]
    1b50:	e8bd8010 	pop	{r4, pc}
	} else {
		ret = strict_strtoul(cp, base, (unsigned long *)res);
	}

	return ret;
}
    1b54:	e8bd4010 	pop	{r4, lr}
	if (*cp == '-') {
		ret = strict_strtoul(cp + 1, base, (unsigned long *)res);
		if (!ret)
			*res = -(*res);
	} else {
		ret = strict_strtoul(cp, base, (unsigned long *)res);
    1b58:	eaffffd3 	b	1aac <strict_strtoul>

00001b5c <strict_strtoull>:
 *
 * simple_strtoull just ignores the successive invalid characters and
 * return the converted value of prefix part of the string.
 */
int strict_strtoull(const char *cp, unsigned int base, unsigned long long *res)
{
    1b5c:	e92d41f3 	push	{r0, r1, r4, r5, r6, r7, r8, lr}
	char *tail;
	unsigned long long val;
	size_t len;

	*res = 0;
    1b60:	e3a03000 	mov	r3, #0
 *
 * simple_strtoull just ignores the successive invalid characters and
 * return the converted value of prefix part of the string.
 */
int strict_strtoull(const char *cp, unsigned int base, unsigned long long *res)
{
    1b64:	e1a07002 	mov	r7, r2
	char *tail;
	unsigned long long val;
	size_t len;

	*res = 0;
    1b68:	e3a02000 	mov	r2, #0
    1b6c:	e1c720f0 	strd	r2, [r7]
 *
 * simple_strtoull just ignores the successive invalid characters and
 * return the converted value of prefix part of the string.
 */
int strict_strtoull(const char *cp, unsigned int base, unsigned long long *res)
{
    1b70:	e1a06000 	mov	r6, r0
    1b74:	e1a04001 	mov	r4, r1
	char *tail;
	unsigned long long val;
	size_t len;

	*res = 0;
	len = strlen(cp);
    1b78:	ebfffd44 	bl	1090 <strlen>
	if (len == 0)
    1b7c:	e2508000 	subs	r8, r0, #0
    1b80:	0a000014 	beq	1bd8 <strict_strtoull+0x7c>
		return -EINVAL;

	val = simple_strtoull(cp, &tail, base);
    1b84:	e1a02004 	mov	r2, r4
    1b88:	e1a00006 	mov	r0, r6
    1b8c:	e28d1004 	add	r1, sp, #4
    1b90:	ebffff8d 	bl	19cc <simple_strtoull>
	if (tail == cp)
    1b94:	e59d3004 	ldr	r3, [sp, #4]
    1b98:	e1530006 	cmp	r3, r6
	*res = 0;
	len = strlen(cp);
	if (len == 0)
		return -EINVAL;

	val = simple_strtoull(cp, &tail, base);
    1b9c:	e1a04000 	mov	r4, r0
    1ba0:	e1a05001 	mov	r5, r1
	if (tail == cp)
    1ba4:	0a00000b 	beq	1bd8 <strict_strtoull+0x7c>
		return -EINVAL;
	if ((*tail == '\0') ||
    1ba8:	e5d32000 	ldrb	r2, [r3]
    1bac:	e3520000 	cmp	r2, #0
    1bb0:	0a000005 	beq	1bcc <strict_strtoull+0x70>
		((len == (size_t)(tail - cp) + 1) && (*tail == '\n'))) {
    1bb4:	e0663003 	rsb	r3, r6, r3
    1bb8:	e2833001 	add	r3, r3, #1
		return -EINVAL;

	val = simple_strtoull(cp, &tail, base);
	if (tail == cp)
		return -EINVAL;
	if ((*tail == '\0') ||
    1bbc:	e1580003 	cmp	r8, r3
    1bc0:	1a000004 	bne	1bd8 <strict_strtoull+0x7c>
		((len == (size_t)(tail - cp) + 1) && (*tail == '\n'))) {
    1bc4:	e352000a 	cmp	r2, #10
    1bc8:	1a000002 	bne	1bd8 <strict_strtoull+0x7c>
		*res = val;
    1bcc:	e1c740f0 	strd	r4, [r7]
		return 0;
    1bd0:	e3a00000 	mov	r0, #0
    1bd4:	ea000000 	b	1bdc <strict_strtoull+0x80>
	}

	return -EINVAL;
    1bd8:	e3e00000 	mvn	r0, #0
}
    1bdc:	e8bd81fc 	pop	{r2, r3, r4, r5, r6, r7, r8, pc}

00001be0 <strict_strtoll>:
 *
 * It returns 0 if conversion is successful and *res is set to the converted
 * value, otherwise it returns -EINVAL and *res is set to 0.
 */
int strict_strtoll(const char *cp, unsigned int base, long long *res)
{
    1be0:	e92d4070 	push	{r4, r5, r6, lr}
	int ret;
	if (*cp == '-') {
    1be4:	e5d0c000 	ldrb	ip, [r0]
 *
 * It returns 0 if conversion is successful and *res is set to the converted
 * value, otherwise it returns -EINVAL and *res is set to 0.
 */
int strict_strtoll(const char *cp, unsigned int base, long long *res)
{
    1be8:	e1a06002 	mov	r6, r2
	int ret;
	if (*cp == '-') {
    1bec:	e35c002d 	cmp	ip, #45	; 0x2d
    1bf0:	1a000008 	bne	1c18 <strict_strtoll+0x38>
		ret = strict_strtoull(cp + 1, base, (unsigned long long *)res);
    1bf4:	e2800001 	add	r0, r0, #1
    1bf8:	ebffffd7 	bl	1b5c <strict_strtoull>
		if (!ret)
    1bfc:	e3500000 	cmp	r0, #0
    1c00:	18bd8070 	popne	{r4, r5, r6, pc}
			*res = -(*res);
    1c04:	e1c640d0 	ldrd	r4, [r6]
    1c08:	e2744000 	rsbs	r4, r4, #0
    1c0c:	e2e55000 	rsc	r5, r5, #0
    1c10:	e1c640f0 	strd	r4, [r6]
    1c14:	e8bd8070 	pop	{r4, r5, r6, pc}
	} else {
		ret = strict_strtoull(cp, base, (unsigned long long *)res);
	}

	return ret;
}
    1c18:	e8bd4070 	pop	{r4, r5, r6, lr}
	if (*cp == '-') {
		ret = strict_strtoull(cp + 1, base, (unsigned long long *)res);
		if (!ret)
			*res = -(*res);
	} else {
		ret = strict_strtoull(cp, base, (unsigned long long *)res);
    1c1c:	eaffffce 	b	1b5c <strict_strtoull>

00001c20 <vsnprintf>:
 *
 * Call this function if you are already dealing with a va_list.
 * You probably want snprintf() instead.
 */
int vsnprintf(char *buf, size_t size, const char *fmt, va_list args)
{
    1c20:	e92d4bf0 	push	{r4, r5, r6, r7, r8, r9, fp, lr}
	int read;
	struct printf_spec spec = {0};

	/* Reject out-of-range values early.  Large positive sizes are
	   used for unknown buffer sizes. */
	if (unlikely((int) size < 0)) {
    1c24:	e3510000 	cmp	r1, #0
 *
 * Call this function if you are already dealing with a va_list.
 * You probably want snprintf() instead.
 */
int vsnprintf(char *buf, size_t size, const char *fmt, va_list args)
{
    1c28:	e24dd050 	sub	sp, sp, #80	; 0x50
    1c2c:	e58d0024 	str	r0, [sp, #36]	; 0x24
    1c30:	e1a09002 	mov	r9, r2
    1c34:	e1a04003 	mov	r4, r3
	int read;
	struct printf_spec spec = {0};

	/* Reject out-of-range values early.  Large positive sizes are
	   used for unknown buffer sizes. */
	if (unlikely((int) size < 0)) {
    1c38:	e58d102c 	str	r1, [sp, #44]	; 0x2c
		/* There can be only one.. */
		static char warn = 1;
		WARN_ON(warn);
		warn = 0;
    1c3c:	b59f38b0 	ldrlt	r3, [pc, #2224]	; 24f4 <vsnprintf+0x8d4>
    1c40:	b3a00000 	movlt	r0, #0
    1c44:	b08f3003 	addlt	r3, pc, r3
    1c48:	b5c30000 	strblt	r0, [r3]
		return 0;
    1c4c:	ba000226 	blt	24ec <vsnprintf+0x8cc>

	str = buf;
	end = buf + size;

	/* Make sure end is always >= buf */
	if (end < buf) {
    1c50:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
    1c54:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
		case FORMAT_TYPE_WIDTH:
			spec.field_width = va_arg(args, int);
			break;

		case FORMAT_TYPE_PRECISION:
			spec.precision = va_arg(args, int);
    1c58:	e3a07000 	mov	r7, #0

	str = buf;
	end = buf + size;

	/* Make sure end is always >= buf */
	if (end < buf) {
    1c5c:	e0900001 	adds	r0, r0, r1
		end = ((void *)-1);
		size = end - buf;
    1c60:	259d2024 	ldrcs	r2, [sp, #36]	; 0x24
	str = buf;
	end = buf + size;

	/* Make sure end is always >= buf */
	if (end < buf) {
		end = ((void *)-1);
    1c64:	23e03000 	mvncs	r3, #0
		size = end - buf;
    1c68:	21e02002 	mvncs	r2, r2

	str = buf;
	end = buf + size;

	/* Make sure end is always >= buf */
	if (end < buf) {
    1c6c:	e58d0018 	str	r0, [sp, #24]
		end = ((void *)-1);
		size = end - buf;
    1c70:	258d202c 	strcs	r2, [sp, #44]	; 0x2c
	str = buf;
	end = buf + size;

	/* Make sure end is always >= buf */
	if (end < buf) {
		end = ((void *)-1);
    1c74:	258d3018 	strcs	r3, [sp, #24]
		case FORMAT_TYPE_WIDTH:
			spec.field_width = va_arg(args, int);
			break;

		case FORMAT_TYPE_PRECISION:
			spec.precision = va_arg(args, int);
    1c78:	e59d6024 	ldr	r6, [sp, #36]	; 0x24
    1c7c:	e58d701c 	str	r7, [sp, #28]
    1c80:	e58d7020 	str	r7, [sp, #32]
    1c84:	e1a0b007 	mov	fp, r7
    1c88:	e1a05007 	mov	r5, r7
    1c8c:	e1a08007 	mov	r8, r7
    1c90:	e1a01009 	mov	r1, r9
    1c94:	ea000207 	b	24b8 <vsnprintf+0x898>
static int format_decode(const char *fmt, struct printf_spec *spec)
{
	const char *start = fmt;

	/* we finished early by reading the field width */
	if (spec->type == FORMAT_TYPE_WIDTH) {
    1c98:	e3580001 	cmp	r8, #1
	end = buf + size;

	/* Make sure end is always >= buf */
	if (end < buf) {
		end = ((void *)-1);
		size = end - buf;
    1c9c:	e58d1048 	str	r1, [sp, #72]	; 0x48
static int format_decode(const char *fmt, struct printf_spec *spec)
{
	const char *start = fmt;

	/* we finished early by reading the field width */
	if (spec->type == FORMAT_TYPE_WIDTH) {
    1ca0:	1a000003 	bne	1cb4 <vsnprintf+0x94>
		if (spec->field_width < 0) {
    1ca4:	e35b0000 	cmp	fp, #0
			spec->field_width = -spec->field_width;
    1ca8:	b26bb000 	rsblt	fp, fp, #0
			spec->flags |= LEFT;
    1cac:	b3855010 	orrlt	r5, r5, #16
    1cb0:	ea000044 	b	1dc8 <vsnprintf+0x1a8>
		spec->type = FORMAT_TYPE_NONE;
		goto precision;
	}

	/* we finished early by reading the precision */
	if (spec->type == FORMAT_TYPE_PRECISION) {
    1cb4:	e3580002 	cmp	r8, #2
    1cb8:	059dc01c 	ldreq	ip, [sp, #28]
    1cbc:	01cccfcc 	biceq	ip, ip, ip, asr #31
    1cc0:	058dc01c 	streq	ip, [sp, #28]
    1cc4:	1a000004 	bne	1cdc <vsnprintf+0xbc>
    1cc8:	ea00005e 	b	1e48 <vsnprintf+0x228>

	/* By default */
	spec->type = FORMAT_TYPE_NONE;

	for (; *fmt ; ++fmt) {
		if (*fmt == '%')
    1ccc:	e3530025 	cmp	r3, #37	; 0x25
    1cd0:	0a000005 	beq	1cec <vsnprintf+0xcc>
	}

	/* By default */
	spec->type = FORMAT_TYPE_NONE;

	for (; *fmt ; ++fmt) {
    1cd4:	e2899001 	add	r9, r9, #1
    1cd8:	e58d9048 	str	r9, [sp, #72]	; 0x48
    1cdc:	e59d9048 	ldr	r9, [sp, #72]	; 0x48
    1ce0:	e5d93000 	ldrb	r3, [r9]
    1ce4:	e3530000 	cmp	r3, #0
    1ce8:	1afffff7 	bne	1ccc <vsnprintf+0xac>
		if (*fmt == '%')
			break;
	}

	/* Return the current non-format string */
	if (fmt != start || !*fmt)
    1cec:	e1590001 	cmp	r9, r1
    1cf0:	1a000002 	bne	1d00 <vsnprintf+0xe0>
    1cf4:	e3530000 	cmp	r3, #0
    1cf8:	13a05000 	movne	r5, #0
    1cfc:	1a000002 	bne	1d0c <vsnprintf+0xec>
		return fmt - start;
    1d00:	e0619009 	rsb	r9, r1, r9
		spec->type = FORMAT_TYPE_NONE;
		goto qualifier;
	}

	/* By default */
	spec->type = FORMAT_TYPE_NONE;
    1d04:	e3a08000 	mov	r8, #0
    1d08:	ea0000de 	b	2088 <vsnprintf+0x468>
	spec->flags = 0;

	while (1) { /* this also skips first '%' */
		int found = 1;

		++fmt;
    1d0c:	e59d3048 	ldr	r3, [sp, #72]	; 0x48
    1d10:	e2832001 	add	r2, r3, #1
    1d14:	e58d2048 	str	r2, [sp, #72]	; 0x48

		switch (*fmt) {
    1d18:	e5d33001 	ldrb	r3, [r3, #1]
    1d1c:	e353002b 	cmp	r3, #43	; 0x2b
    1d20:	0a00000c 	beq	1d58 <vsnprintf+0x138>
    1d24:	8a000004 	bhi	1d3c <vsnprintf+0x11c>
    1d28:	e3530020 	cmp	r3, #32
    1d2c:	0a00000b 	beq	1d60 <vsnprintf+0x140>
    1d30:	e3530023 	cmp	r3, #35	; 0x23
    1d34:	1a00000f 	bne	1d78 <vsnprintf+0x158>
    1d38:	ea00000a 	b	1d68 <vsnprintf+0x148>
    1d3c:	e353002d 	cmp	r3, #45	; 0x2d
    1d40:	0a000002 	beq	1d50 <vsnprintf+0x130>
    1d44:	e3530030 	cmp	r3, #48	; 0x30
    1d48:	1a00000a 	bne	1d78 <vsnprintf+0x158>
    1d4c:	ea000007 	b	1d70 <vsnprintf+0x150>
		case '-': spec->flags |= LEFT;    break;
    1d50:	e3855010 	orr	r5, r5, #16
    1d54:	eaffffec 	b	1d0c <vsnprintf+0xec>
		case '+': spec->flags |= PLUS;    break;
    1d58:	e3855004 	orr	r5, r5, #4
    1d5c:	eaffffea 	b	1d0c <vsnprintf+0xec>
		case ' ': spec->flags |= SPACE;   break;
    1d60:	e3855008 	orr	r5, r5, #8
    1d64:	eaffffe8 	b	1d0c <vsnprintf+0xec>
		case '#': spec->flags |= SPECIAL; break;
    1d68:	e3855040 	orr	r5, r5, #64	; 0x40
    1d6c:	eaffffe6 	b	1d0c <vsnprintf+0xec>
		case '0': spec->flags |= ZEROPAD; break;
    1d70:	e3855001 	orr	r5, r5, #1
    1d74:	eaffffe4 	b	1d0c <vsnprintf+0xec>
	}

	/* get field width */
	spec->field_width = -1;

	if (isdigit(*fmt))
    1d78:	e59f0778 	ldr	r0, [pc, #1912]	; 24f8 <vsnprintf+0x8d8>
    1d7c:	e79a0000 	ldr	r0, [sl, r0]
    1d80:	e7d00003 	ldrb	r0, [r0, r3]
    1d84:	e3100004 	tst	r0, #4
    1d88:	0a000005 	beq	1da4 <vsnprintf+0x184>
		spec->field_width = skip_atoi(&fmt);
    1d8c:	e28d0048 	add	r0, sp, #72	; 0x48
    1d90:	e58d1014 	str	r1, [sp, #20]
    1d94:	ebfffd8a 	bl	13c4 <skip_atoi>
    1d98:	e59d1014 	ldr	r1, [sp, #20]
    1d9c:	e1a0b000 	mov	fp, r0
    1da0:	ea000008 	b	1dc8 <vsnprintf+0x1a8>
	else if (*fmt == '*') {
    1da4:	e353002a 	cmp	r3, #42	; 0x2a
		if (!found)
			break;
	}

	/* get field width */
	spec->field_width = -1;
    1da8:	13e0b000 	mvnne	fp, #0

	if (isdigit(*fmt))
		spec->field_width = skip_atoi(&fmt);
	else if (*fmt == '*') {
    1dac:	1a000005 	bne	1dc8 <vsnprintf+0x1a8>
		/* it's the next argument */
		spec->type = FORMAT_TYPE_WIDTH;
		return ++fmt - start;
    1db0:	e2822001 	add	r2, r2, #1
    1db4:	e58d2048 	str	r2, [sp, #72]	; 0x48
    1db8:	e0699002 	rsb	r9, r9, r2
		if (!found)
			break;
	}

	/* get field width */
	spec->field_width = -1;
    1dbc:	e3e0b000 	mvn	fp, #0

	if (isdigit(*fmt))
		spec->field_width = skip_atoi(&fmt);
	else if (*fmt == '*') {
		/* it's the next argument */
		spec->type = FORMAT_TYPE_WIDTH;
    1dc0:	e3a08001 	mov	r8, #1
    1dc4:	ea0000af 	b	2088 <vsnprintf+0x468>
	}

precision:
	/* get the precision */
	spec->precision = -1;
	if (*fmt == '.') {
    1dc8:	e59d3048 	ldr	r3, [sp, #72]	; 0x48
    1dcc:	e5d32000 	ldrb	r2, [r3]
    1dd0:	e352002e 	cmp	r2, #46	; 0x2e
		return ++fmt - start;
	}

precision:
	/* get the precision */
	spec->precision = -1;
    1dd4:	13e02000 	mvnne	r2, #0
    1dd8:	158d201c 	strne	r2, [sp, #28]
	if (*fmt == '.') {
    1ddc:	1a000019 	bne	1e48 <vsnprintf+0x228>
		++fmt;
		if (isdigit(*fmt)) {
    1de0:	e59f2710 	ldr	r2, [pc, #1808]	; 24f8 <vsnprintf+0x8d8>

precision:
	/* get the precision */
	spec->precision = -1;
	if (*fmt == '.') {
		++fmt;
    1de4:	e2839001 	add	r9, r3, #1
    1de8:	e58d9048 	str	r9, [sp, #72]	; 0x48
		if (isdigit(*fmt)) {
    1dec:	e5d33001 	ldrb	r3, [r3, #1]
    1df0:	e79a2002 	ldr	r2, [sl, r2]
    1df4:	e7d22003 	ldrb	r2, [r2, r3]
    1df8:	e3120004 	tst	r2, #4
    1dfc:	0a000006 	beq	1e1c <vsnprintf+0x1fc>
			spec->precision = skip_atoi(&fmt);
    1e00:	e28d0048 	add	r0, sp, #72	; 0x48
    1e04:	e58d1014 	str	r1, [sp, #20]
    1e08:	ebfffd6d 	bl	13c4 <skip_atoi>
    1e0c:	e59d1014 	ldr	r1, [sp, #20]
			if (spec->precision < 0)
				spec->precision = 0;
    1e10:	e1c00fc0 	bic	r0, r0, r0, asr #31
    1e14:	e58d001c 	str	r0, [sp, #28]
    1e18:	ea00000a 	b	1e48 <vsnprintf+0x228>
		} else if (*fmt == '*') {
    1e1c:	e353002a 	cmp	r3, #42	; 0x2a
		return ++fmt - start;
	}

precision:
	/* get the precision */
	spec->precision = -1;
    1e20:	13e03000 	mvnne	r3, #0
    1e24:	158d301c 	strne	r3, [sp, #28]
		++fmt;
		if (isdigit(*fmt)) {
			spec->precision = skip_atoi(&fmt);
			if (spec->precision < 0)
				spec->precision = 0;
		} else if (*fmt == '*') {
    1e28:	1a000006 	bne	1e48 <vsnprintf+0x228>
			/* it's the next argument */
			spec->type = FORMAT_TYPE_PRECISION;
			return ++fmt - start;
    1e2c:	e2899001 	add	r9, r9, #1
		return ++fmt - start;
	}

precision:
	/* get the precision */
	spec->precision = -1;
    1e30:	e3e00000 	mvn	r0, #0
			if (spec->precision < 0)
				spec->precision = 0;
		} else if (*fmt == '*') {
			/* it's the next argument */
			spec->type = FORMAT_TYPE_PRECISION;
			return ++fmt - start;
    1e34:	e58d9048 	str	r9, [sp, #72]	; 0x48
		return ++fmt - start;
	}

precision:
	/* get the precision */
	spec->precision = -1;
    1e38:	e58d001c 	str	r0, [sp, #28]
			if (spec->precision < 0)
				spec->precision = 0;
		} else if (*fmt == '*') {
			/* it's the next argument */
			spec->type = FORMAT_TYPE_PRECISION;
			return ++fmt - start;
    1e3c:	e0619009 	rsb	r9, r1, r9
			spec->precision = skip_atoi(&fmt);
			if (spec->precision < 0)
				spec->precision = 0;
		} else if (*fmt == '*') {
			/* it's the next argument */
			spec->type = FORMAT_TYPE_PRECISION;
    1e40:	e3a08002 	mov	r8, #2
    1e44:	ea00008f 	b	2088 <vsnprintf+0x468>
	}

qualifier:
	/* get the conversion qualifier */
	spec->qualifier = -1;
	if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' ||
    1e48:	e59d2048 	ldr	r2, [sp, #72]	; 0x48
    1e4c:	e5d27000 	ldrb	r7, [r2]
    1e50:	e3570068 	cmp	r7, #104	; 0x68
    1e54:	1357006c 	cmpne	r7, #108	; 0x6c
    1e58:	0a000008 	beq	1e80 <vsnprintf+0x260>
    1e5c:	e357004c 	cmp	r7, #76	; 0x4c
    1e60:	0a000006 	beq	1e80 <vsnprintf+0x260>
    1e64:	e357005a 	cmp	r7, #90	; 0x5a
    1e68:	0a000004 	beq	1e80 <vsnprintf+0x260>
	    *fmt == 'Z' || *fmt == 'z' || *fmt == 't') {
    1e6c:	e357007a 	cmp	r7, #122	; 0x7a
    1e70:	0a000002 	beq	1e80 <vsnprintf+0x260>
    1e74:	e3570074 	cmp	r7, #116	; 0x74
		}
	}

qualifier:
	/* get the conversion qualifier */
	spec->qualifier = -1;
    1e78:	13e07000 	mvnne	r7, #0
	if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' ||
	    *fmt == 'Z' || *fmt == 'z' || *fmt == 't') {
    1e7c:	1a00000d 	bne	1eb8 <vsnprintf+0x298>
		spec->qualifier = *fmt++;
    1e80:	e2823001 	add	r3, r2, #1
    1e84:	e58d3048 	str	r3, [sp, #72]	; 0x48
		if (unlikely(spec->qualifier == *fmt)) {
    1e88:	e5d22001 	ldrb	r2, [r2, #1]
    1e8c:	e1570002 	cmp	r7, r2
    1e90:	1a000008 	bne	1eb8 <vsnprintf+0x298>
			if (spec->qualifier == 'l') {
    1e94:	e357006c 	cmp	r7, #108	; 0x6c
				spec->qualifier = 'L';
				++fmt;
    1e98:	02833001 	addeq	r3, r3, #1
    1e9c:	058d3048 	streq	r3, [sp, #72]	; 0x48
	if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' ||
	    *fmt == 'Z' || *fmt == 'z' || *fmt == 't') {
		spec->qualifier = *fmt++;
		if (unlikely(spec->qualifier == *fmt)) {
			if (spec->qualifier == 'l') {
				spec->qualifier = 'L';
    1ea0:	03a0704c 	moveq	r7, #76	; 0x4c
	spec->qualifier = -1;
	if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' ||
	    *fmt == 'Z' || *fmt == 'z' || *fmt == 't') {
		spec->qualifier = *fmt++;
		if (unlikely(spec->qualifier == *fmt)) {
			if (spec->qualifier == 'l') {
    1ea4:	0a000003 	beq	1eb8 <vsnprintf+0x298>
				spec->qualifier = 'L';
				++fmt;
			} else if (spec->qualifier == 'h') {
    1ea8:	e3570068 	cmp	r7, #104	; 0x68
				spec->qualifier = 'H';
				++fmt;
    1eac:	02833001 	addeq	r3, r3, #1
		if (unlikely(spec->qualifier == *fmt)) {
			if (spec->qualifier == 'l') {
				spec->qualifier = 'L';
				++fmt;
			} else if (spec->qualifier == 'h') {
				spec->qualifier = 'H';
    1eb0:	03a07048 	moveq	r7, #72	; 0x48
				++fmt;
    1eb4:	058d3048 	streq	r3, [sp, #72]	; 0x48
		}
	}

	/* default base */
	spec->base = 10;
	switch (*fmt) {
    1eb8:	e59d9048 	ldr	r9, [sp, #72]	; 0x48
    1ebc:	e5d93000 	ldrb	r3, [r9]
    1ec0:	e353006e 	cmp	r3, #110	; 0x6e
    1ec4:	0a00002d 	beq	1f80 <vsnprintf+0x360>
    1ec8:	8a00000c 	bhi	1f00 <vsnprintf+0x2e0>
    1ecc:	e3530063 	cmp	r3, #99	; 0x63
    1ed0:	0a000017 	beq	1f34 <vsnprintf+0x314>
    1ed4:	8a000004 	bhi	1eec <vsnprintf+0x2cc>
    1ed8:	e3530025 	cmp	r3, #37	; 0x25
    1edc:	0a00002e 	beq	1f9c <vsnprintf+0x37c>
    1ee0:	e3530058 	cmp	r3, #88	; 0x58
    1ee4:	1a00003a 	bne	1fd4 <vsnprintf+0x3b4>
    1ee8:	ea000033 	b	1fbc <vsnprintf+0x39c>
    1eec:	e3530064 	cmp	r3, #100	; 0x64
    1ef0:	0a000033 	beq	1fc4 <vsnprintf+0x3a4>
    1ef4:	e3530069 	cmp	r3, #105	; 0x69
    1ef8:	1a000035 	bne	1fd4 <vsnprintf+0x3b4>
    1efc:	ea000030 	b	1fc4 <vsnprintf+0x3a4>
    1f00:	e3530073 	cmp	r3, #115	; 0x73
    1f04:	0a000011 	beq	1f50 <vsnprintf+0x330>
    1f08:	8a000004 	bhi	1f20 <vsnprintf+0x300>
    1f0c:	e353006f 	cmp	r3, #111	; 0x6f
    1f10:	0a000037 	beq	1ff4 <vsnprintf+0x3d4>
    1f14:	e3530070 	cmp	r3, #112	; 0x70
    1f18:	1a00002d 	bne	1fd4 <vsnprintf+0x3b4>
    1f1c:	ea000012 	b	1f6c <vsnprintf+0x34c>
    1f20:	e3530075 	cmp	r3, #117	; 0x75
    1f24:	0a00002f 	beq	1fe8 <vsnprintf+0x3c8>
    1f28:	e3530078 	cmp	r3, #120	; 0x78
    1f2c:	1a000028 	bne	1fd4 <vsnprintf+0x3b4>
    1f30:	ea000020 	b	1fb8 <vsnprintf+0x398>
	case 'c':
		spec->type = FORMAT_TYPE_CHAR;
		return ++fmt - start;
    1f34:	e2899001 	add	r9, r9, #1
			}
		}
	}

	/* default base */
	spec->base = 10;
    1f38:	e3a0c00a 	mov	ip, #10
	switch (*fmt) {
	case 'c':
		spec->type = FORMAT_TYPE_CHAR;
		return ++fmt - start;
    1f3c:	e58d9048 	str	r9, [sp, #72]	; 0x48
			}
		}
	}

	/* default base */
	spec->base = 10;
    1f40:	e58dc020 	str	ip, [sp, #32]
	switch (*fmt) {
	case 'c':
		spec->type = FORMAT_TYPE_CHAR;
		return ++fmt - start;
    1f44:	e0619009 	rsb	r9, r1, r9

	/* default base */
	spec->base = 10;
	switch (*fmt) {
	case 'c':
		spec->type = FORMAT_TYPE_CHAR;
    1f48:	e3a08003 	mov	r8, #3
    1f4c:	ea00004d 	b	2088 <vsnprintf+0x468>
		return ++fmt - start;

	case 's':
		spec->type = FORMAT_TYPE_STR;
		return ++fmt - start;
    1f50:	e2899001 	add	r9, r9, #1
			}
		}
	}

	/* default base */
	spec->base = 10;
    1f54:	e3a0000a 	mov	r0, #10
		spec->type = FORMAT_TYPE_CHAR;
		return ++fmt - start;

	case 's':
		spec->type = FORMAT_TYPE_STR;
		return ++fmt - start;
    1f58:	e58d9048 	str	r9, [sp, #72]	; 0x48
			}
		}
	}

	/* default base */
	spec->base = 10;
    1f5c:	e58d0020 	str	r0, [sp, #32]
		spec->type = FORMAT_TYPE_CHAR;
		return ++fmt - start;

	case 's':
		spec->type = FORMAT_TYPE_STR;
		return ++fmt - start;
    1f60:	e0619009 	rsb	r9, r1, r9
	case 'c':
		spec->type = FORMAT_TYPE_CHAR;
		return ++fmt - start;

	case 's':
		spec->type = FORMAT_TYPE_STR;
    1f64:	e3a08004 	mov	r8, #4
    1f68:	ea000046 	b	2088 <vsnprintf+0x468>
			}
		}
	}

	/* default base */
	spec->base = 10;
    1f6c:	e3a0200a 	mov	r2, #10
		spec->type = FORMAT_TYPE_STR;
		return ++fmt - start;

	case 'p':
		spec->type = FORMAT_TYPE_PTR;
		return fmt - start;
    1f70:	e0619009 	rsb	r9, r1, r9
			}
		}
	}

	/* default base */
	spec->base = 10;
    1f74:	e58d2020 	str	r2, [sp, #32]
	case 's':
		spec->type = FORMAT_TYPE_STR;
		return ++fmt - start;

	case 'p':
		spec->type = FORMAT_TYPE_PTR;
    1f78:	e3a08005 	mov	r8, #5
    1f7c:	ea000041 	b	2088 <vsnprintf+0x468>
		return fmt - start;
		/* skip alnum */

	case 'n':
		spec->type = FORMAT_TYPE_NRCHARS;
		return ++fmt - start;
    1f80:	e2899001 	add	r9, r9, #1
			}
		}
	}

	/* default base */
	spec->base = 10;
    1f84:	e3a0300a 	mov	r3, #10
		return fmt - start;
		/* skip alnum */

	case 'n':
		spec->type = FORMAT_TYPE_NRCHARS;
		return ++fmt - start;
    1f88:	e58d9048 	str	r9, [sp, #72]	; 0x48
			}
		}
	}

	/* default base */
	spec->base = 10;
    1f8c:	e58d3020 	str	r3, [sp, #32]
		return fmt - start;
		/* skip alnum */

	case 'n':
		spec->type = FORMAT_TYPE_NRCHARS;
		return ++fmt - start;
    1f90:	e0619009 	rsb	r9, r1, r9
		spec->type = FORMAT_TYPE_PTR;
		return fmt - start;
		/* skip alnum */

	case 'n':
		spec->type = FORMAT_TYPE_NRCHARS;
    1f94:	e3a08011 	mov	r8, #17
    1f98:	ea00003a 	b	2088 <vsnprintf+0x468>
		return ++fmt - start;

	case '%':
		spec->type = FORMAT_TYPE_PERCENT_CHAR;
		return ++fmt - start;
    1f9c:	e2899001 	add	r9, r9, #1
			}
		}
	}

	/* default base */
	spec->base = 10;
    1fa0:	e3a0c00a 	mov	ip, #10
		spec->type = FORMAT_TYPE_NRCHARS;
		return ++fmt - start;

	case '%':
		spec->type = FORMAT_TYPE_PERCENT_CHAR;
		return ++fmt - start;
    1fa4:	e58d9048 	str	r9, [sp, #72]	; 0x48
			}
		}
	}

	/* default base */
	spec->base = 10;
    1fa8:	e58dc020 	str	ip, [sp, #32]
		spec->type = FORMAT_TYPE_NRCHARS;
		return ++fmt - start;

	case '%':
		spec->type = FORMAT_TYPE_PERCENT_CHAR;
		return ++fmt - start;
    1fac:	e0619009 	rsb	r9, r1, r9
	case 'n':
		spec->type = FORMAT_TYPE_NRCHARS;
		return ++fmt - start;

	case '%':
		spec->type = FORMAT_TYPE_PERCENT_CHAR;
    1fb0:	e3a08006 	mov	r8, #6
    1fb4:	ea000033 	b	2088 <vsnprintf+0x468>
	case 'o':
		spec->base = 8;
		break;

	case 'x':
		spec->flags |= SMALL;
    1fb8:	e3855020 	orr	r5, r5, #32

	case 'X':
		spec->base = 16;
    1fbc:	e3a00010 	mov	r0, #16
    1fc0:	ea00000c 	b	1ff8 <vsnprintf+0x3d8>
			}
		}
	}

	/* default base */
	spec->base = 10;
    1fc4:	e3a0200a 	mov	r2, #10
		spec->base = 16;
		break;

	case 'd':
	case 'i':
		spec->flags |= SIGN;
    1fc8:	e3855002 	orr	r5, r5, #2
			}
		}
	}

	/* default base */
	spec->base = 10;
    1fcc:	e58d2020 	str	r2, [sp, #32]
    1fd0:	ea000009 	b	1ffc <vsnprintf+0x3dc>
    1fd4:	e3a0300a 	mov	r3, #10
	case 'u':
		break;

	default:
		spec->type = FORMAT_TYPE_INVALID;
		return fmt - start;
    1fd8:	e0619009 	rsb	r9, r1, r9
			}
		}
	}

	/* default base */
	spec->base = 10;
    1fdc:	e58d3020 	str	r3, [sp, #32]
		spec->flags |= SIGN;
	case 'u':
		break;

	default:
		spec->type = FORMAT_TYPE_INVALID;
    1fe0:	e3a08007 	mov	r8, #7
    1fe4:	ea000027 	b	2088 <vsnprintf+0x468>
			}
		}
	}

	/* default base */
	spec->base = 10;
    1fe8:	e3a0c00a 	mov	ip, #10
    1fec:	e58dc020 	str	ip, [sp, #32]
    1ff0:	ea000001 	b	1ffc <vsnprintf+0x3dc>
		spec->type = FORMAT_TYPE_PERCENT_CHAR;
		return ++fmt - start;

	/* integer number formats - set up the flags and "break" */
	case 'o':
		spec->base = 8;
    1ff4:	e3a00008 	mov	r0, #8
    1ff8:	e58d0020 	str	r0, [sp, #32]
	default:
		spec->type = FORMAT_TYPE_INVALID;
		return fmt - start;
	}

	if (spec->qualifier == 'L')
    1ffc:	e357004c 	cmp	r7, #76	; 0x4c
		spec->type = FORMAT_TYPE_LONG_LONG;
    2000:	03a08008 	moveq	r8, #8
	default:
		spec->type = FORMAT_TYPE_INVALID;
		return fmt - start;
	}

	if (spec->qualifier == 'L')
    2004:	0a00001c 	beq	207c <vsnprintf+0x45c>
		spec->type = FORMAT_TYPE_LONG_LONG;
	else if (spec->qualifier == 'l') {
    2008:	e357006c 	cmp	r7, #108	; 0x6c
    200c:	1a000003 	bne	2020 <vsnprintf+0x400>
		if (spec->flags & SIGN)
			spec->type = FORMAT_TYPE_LONG;
    2010:	e3150002 	tst	r5, #2
    2014:	03a08009 	moveq	r8, #9
    2018:	13a0800a 	movne	r8, #10
    201c:	ea000016 	b	207c <vsnprintf+0x45c>
		else
			spec->type = FORMAT_TYPE_ULONG;
	} else if (spec->qualifier == 'Z' || spec->qualifier == 'z') {
    2020:	e357005a 	cmp	r7, #90	; 0x5a
    2024:	1357007a 	cmpne	r7, #122	; 0x7a
		spec->type = FORMAT_TYPE_SIZE_T;
    2028:	03a08012 	moveq	r8, #18
	else if (spec->qualifier == 'l') {
		if (spec->flags & SIGN)
			spec->type = FORMAT_TYPE_LONG;
		else
			spec->type = FORMAT_TYPE_ULONG;
	} else if (spec->qualifier == 'Z' || spec->qualifier == 'z') {
    202c:	0a000012 	beq	207c <vsnprintf+0x45c>
		spec->type = FORMAT_TYPE_SIZE_T;
	} else if (spec->qualifier == 't') {
    2030:	e3570074 	cmp	r7, #116	; 0x74
		spec->type = FORMAT_TYPE_PTRDIFF;
    2034:	03a08013 	moveq	r8, #19
			spec->type = FORMAT_TYPE_LONG;
		else
			spec->type = FORMAT_TYPE_ULONG;
	} else if (spec->qualifier == 'Z' || spec->qualifier == 'z') {
		spec->type = FORMAT_TYPE_SIZE_T;
	} else if (spec->qualifier == 't') {
    2038:	0a00000f 	beq	207c <vsnprintf+0x45c>
		spec->type = FORMAT_TYPE_PTRDIFF;
	} else if (spec->qualifier == 'H') {
    203c:	e3570048 	cmp	r7, #72	; 0x48
    2040:	e2058002 	and	r8, r5, #2
    2044:	1a000003 	bne	2058 <vsnprintf+0x438>
		if (spec->flags & SIGN)
			spec->type = FORMAT_TYPE_BYTE;
    2048:	e3580000 	cmp	r8, #0
    204c:	03a0800b 	moveq	r8, #11
    2050:	13a0800c 	movne	r8, #12
    2054:	ea000008 	b	207c <vsnprintf+0x45c>
		else
			spec->type = FORMAT_TYPE_UBYTE;
	} else if (spec->qualifier == 'h') {
    2058:	e3570068 	cmp	r7, #104	; 0x68
    205c:	1a000003 	bne	2070 <vsnprintf+0x450>
		if (spec->flags & SIGN)
			spec->type = FORMAT_TYPE_SHORT;
    2060:	e3580000 	cmp	r8, #0
    2064:	03a0800d 	moveq	r8, #13
    2068:	13a0800e 	movne	r8, #14
    206c:	ea000002 	b	207c <vsnprintf+0x45c>
		else
			spec->type = FORMAT_TYPE_USHORT;
	} else {
		if (spec->flags & SIGN)
			spec->type = FORMAT_TYPE_INT;
    2070:	e3580000 	cmp	r8, #0
    2074:	03a0800f 	moveq	r8, #15
    2078:	13a08010 	movne	r8, #16
		else
			spec->type = FORMAT_TYPE_UINT;
	}

	return ++fmt - start;
    207c:	e2899001 	add	r9, r9, #1
    2080:	e58d9048 	str	r9, [sp, #72]	; 0x48
    2084:	e0619009 	rsb	r9, r1, r9
	while (*fmt) {
		const char *old_fmt = fmt;

		read = format_decode(fmt, &spec);

		fmt += read;
    2088:	e0812009 	add	r2, r1, r9
    208c:	e58d2028 	str	r2, [sp, #40]	; 0x28

		switch (spec.type) {
    2090:	e3580011 	cmp	r8, #17
    2094:	908ff108 	addls	pc, pc, r8, lsl #2
    2098:	ea0000d8 	b	2400 <vsnprintf+0x7e0>
    209c:	ea000010 	b	20e4 <vsnprintf+0x4c4>
    20a0:	ea00001a 	b	2110 <vsnprintf+0x4f0>
    20a4:	ea00001b 	b	2118 <vsnprintf+0x4f8>
    20a8:	ea00001d 	b	2124 <vsnprintf+0x504>
    20ac:	ea000037 	b	2190 <vsnprintf+0x570>
    20b0:	ea000042 	b	21c0 <vsnprintf+0x5a0>
    20b4:	ea0000b9 	b	23a0 <vsnprintf+0x780>
    20b8:	ea0000bb 	b	23ac <vsnprintf+0x78c>
    20bc:	ea0000cf 	b	2400 <vsnprintf+0x7e0>
    20c0:	ea0000ce 	b	2400 <vsnprintf+0x7e0>
    20c4:	ea0000cd 	b	2400 <vsnprintf+0x7e0>
    20c8:	ea0000cc 	b	2400 <vsnprintf+0x7e0>
    20cc:	ea0000cb 	b	2400 <vsnprintf+0x7e0>
    20d0:	ea0000ca 	b	2400 <vsnprintf+0x7e0>
    20d4:	ea0000c9 	b	2400 <vsnprintf+0x7e0>
    20d8:	ea0000c8 	b	2400 <vsnprintf+0x7e0>
    20dc:	ea0000c7 	b	2400 <vsnprintf+0x7e0>
    20e0:	ea0000b7 	b	23c4 <vsnprintf+0x7a4>
		case FORMAT_TYPE_NONE: {
			int copy = read;
			if (str < end) {
    20e4:	e59d3018 	ldr	r3, [sp, #24]
    20e8:	e1560003 	cmp	r6, r3
    20ec:	2a000005 	bcs	2108 <vsnprintf+0x4e8>
				if (copy > end - str)
    20f0:	e0662003 	rsb	r2, r6, r3
					copy = end - str;
				memcpy(str, old_fmt, copy);
    20f4:	e1a00006 	mov	r0, r6
    20f8:	e1590002 	cmp	r9, r2
    20fc:	b1a02009 	movlt	r2, r9
    2100:	a1a02002 	movge	r2, r2
    2104:	ebfffbd8 	bl	106c <memcpy>
			}
			str += read;
    2108:	e0866009 	add	r6, r6, r9
			break;
    210c:	ea0000e8 	b	24b4 <vsnprintf+0x894>
		}

		case FORMAT_TYPE_WIDTH:
			spec.field_width = va_arg(args, int);
    2110:	e594b000 	ldr	fp, [r4]
    2114:	ea0000b0 	b	23dc <vsnprintf+0x7bc>
			break;

		case FORMAT_TYPE_PRECISION:
			spec.precision = va_arg(args, int);
    2118:	e594c000 	ldr	ip, [r4]
    211c:	e58dc01c 	str	ip, [sp, #28]
    2120:	ea0000ad 	b	23dc <vsnprintf+0x7bc>
			break;

		case FORMAT_TYPE_CHAR:
			if (!(spec.flags & LEFT)) {
    2124:	e3150010 	tst	r5, #16
    2128:	1a000008 	bne	2150 <vsnprintf+0x530>
    212c:	ea000004 	b	2144 <vsnprintf+0x524>
				while (--spec.field_width > 0) {
					if (str < end)
    2130:	e59d0018 	ldr	r0, [sp, #24]
    2134:	e1560000 	cmp	r6, r0
						*str = ' ';
    2138:	33a03020 	movcc	r3, #32
    213c:	35c63000 	strbcc	r3, [r6]
					++str;
    2140:	e2866001 	add	r6, r6, #1
			spec.precision = va_arg(args, int);
			break;

		case FORMAT_TYPE_CHAR:
			if (!(spec.flags & LEFT)) {
				while (--spec.field_width > 0) {
    2144:	e24bb001 	sub	fp, fp, #1
    2148:	e35b0000 	cmp	fp, #0
    214c:	cafffff7 	bgt	2130 <vsnprintf+0x510>
					++str;

				}
			}
			c = (unsigned char) va_arg(args, int);
			if (str < end)
    2150:	e59d1018 	ldr	r1, [sp, #24]
						*str = ' ';
					++str;

				}
			}
			c = (unsigned char) va_arg(args, int);
    2154:	e2843004 	add	r3, r4, #4
			if (str < end)
    2158:	e1560001 	cmp	r6, r1
						*str = ' ';
					++str;

				}
			}
			c = (unsigned char) va_arg(args, int);
    215c:	e5942000 	ldr	r2, [r4]
			if (str < end)
    2160:	2a000005 	bcs	217c <vsnprintf+0x55c>
    2164:	ea000003 	b	2178 <vsnprintf+0x558>
				*str = c;
			++str;
			while (--spec.field_width > 0) {
				if (str < end)
    2168:	e59d2018 	ldr	r2, [sp, #24]
    216c:	e1560002 	cmp	r6, r2
    2170:	2a000001 	bcs	217c <vsnprintf+0x55c>
					*str = ' ';
    2174:	e3a02020 	mov	r2, #32
    2178:	e5c62000 	strb	r2, [r6]
			}
			c = (unsigned char) va_arg(args, int);
			if (str < end)
				*str = c;
			++str;
			while (--spec.field_width > 0) {
    217c:	e24bb001 	sub	fp, fp, #1
    2180:	e35b0000 	cmp	fp, #0
				if (str < end)
					*str = ' ';
				++str;
    2184:	e2866001 	add	r6, r6, #1
			}
			c = (unsigned char) va_arg(args, int);
			if (str < end)
				*str = c;
			++str;
			while (--spec.field_width > 0) {
    2188:	cafffff6 	bgt	2168 <vsnprintf+0x548>
    218c:	ea000099 	b	23f8 <vsnprintf+0x7d8>
				++str;
			}
			break;

		case FORMAT_TYPE_STR:
			str = string(str, end, va_arg(args, char *), spec);
    2190:	e59d301c 	ldr	r3, [sp, #28]
    2194:	e58db000 	str	fp, [sp]
    2198:	e58d3004 	str	r3, [sp, #4]
    219c:	e1a00006 	mov	r0, r6
    21a0:	e5942000 	ldr	r2, [r4]
    21a4:	e59d1018 	ldr	r1, [sp, #24]
    21a8:	e1a03005 	mov	r3, r5
    21ac:	ebfffdac 	bl	1864 <string.clone.2>
    21b0:	e2849004 	add	r9, r4, #4
    21b4:	e1a04009 	mov	r4, r9
    21b8:	e1a06000 	mov	r6, r0
			break;
    21bc:	ea0000bc 	b	24b4 <vsnprintf+0x894>

		case FORMAT_TYPE_PTR:
			str = pointer(fmt+1, str, end, va_arg(args, void *),
    21c0:	e5942000 	ldr	r2, [r4]
    21c4:	e284c004 	add	ip, r4, #4
 * pointer to the real address.
 */
static char *pointer(const char *fmt, char *buf, char *end, void *ptr,
			struct printf_spec spec)
{
	if (!ptr)
    21c8:	e3520000 	cmp	r2, #0
		case FORMAT_TYPE_STR:
			str = string(str, end, va_arg(args, char *), spec);
			break;

		case FORMAT_TYPE_PTR:
			str = pointer(fmt+1, str, end, va_arg(args, void *),
    21cc:	e58dc034 	str	ip, [sp, #52]	; 0x34
 * pointer to the real address.
 */
static char *pointer(const char *fmt, char *buf, char *end, void *ptr,
			struct printf_spec spec)
{
	if (!ptr)
    21d0:	1a000008 	bne	21f8 <vsnprintf+0x5d8>
		return string(buf, end, "(null)", spec);
    21d4:	e59d001c 	ldr	r0, [sp, #28]
    21d8:	e59f231c 	ldr	r2, [pc, #796]	; 24fc <vsnprintf+0x8dc>
    21dc:	e58d0004 	str	r0, [sp, #4]
    21e0:	e58db000 	str	fp, [sp]
    21e4:	e1a00006 	mov	r0, r6
    21e8:	e59d1018 	ldr	r1, [sp, #24]
    21ec:	e08f2002 	add	r2, pc, r2
    21f0:	e1a03005 	mov	r3, r5
    21f4:	ea00004a 	b	2324 <vsnprintf+0x704>
		case FORMAT_TYPE_STR:
			str = string(str, end, va_arg(args, char *), spec);
			break;

		case FORMAT_TYPE_PTR:
			str = pointer(fmt+1, str, end, va_arg(args, void *),
    21f8:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
    21fc:	e2813001 	add	r3, r1, #1
			struct printf_spec spec)
{
	if (!ptr)
		return string(buf, end, "(null)", spec);

	switch (*fmt) {
    2200:	e5d11001 	ldrb	r1, [r1, #1]
    2204:	e3510053 	cmp	r1, #83	; 0x53
    2208:	0a000008 	beq	2230 <vsnprintf+0x610>
    220c:	8a000002 	bhi	221c <vsnprintf+0x5fc>
    2210:	e3510049 	cmp	r1, #73	; 0x49
    2214:	1a000044 	bne	232c <vsnprintf+0x70c>
    2218:	ea000013 	b	226c <vsnprintf+0x64c>
    221c:	e3510069 	cmp	r1, #105	; 0x69
    2220:	0a00000d 	beq	225c <vsnprintf+0x63c>
    2224:	e351006d 	cmp	r1, #109	; 0x6d
    2228:	1a00003f 	bne	232c <vsnprintf+0x70c>
    222c:	ea000008 	b	2254 <vsnprintf+0x634>
	else
		kallsyms_lookup(value, NULL, NULL, NULL, sym);
	return string(buf, end, sym, spec);
#else
	spec.field_width = 2*sizeof(void *);
	spec.flags |= SPECIAL | SMALL | ZEROPAD;
    2230:	e3853061 	orr	r3, r5, #97	; 0x61
	spec.base = 16;
	return number(buf, end, value, spec);
    2234:	e58d3000 	str	r3, [sp]
    2238:	e3a03008 	mov	r3, #8
    223c:	e58d3004 	str	r3, [sp, #4]
    2240:	e0833003 	add	r3, r3, r3
    2244:	e58d3008 	str	r3, [sp, #8]
    2248:	e59d301c 	ldr	r3, [sp, #28]
    224c:	e58d300c 	str	r3, [sp, #12]
    2250:	ea000041 	b	235c <vsnprintf+0x73c>

	switch (*fmt) {
	case 'S':
		return symbol_string(buf, end, ptr, spec, *fmt);
	case 'm':
		spec.flags |= SPECIAL;
    2254:	e3851040 	orr	r1, r5, #64	; 0x40
    2258:	ea000000 	b	2260 <vsnprintf+0x640>
			struct printf_spec spec)
{
	if (!ptr)
		return string(buf, end, "(null)", spec);

	switch (*fmt) {
    225c:	e1a01005 	mov	r1, r5
		return symbol_string(buf, end, ptr, spec, *fmt);
	case 'm':
		spec.flags |= SPECIAL;
		/* Fallthrough */
	case 'i':
		spec.flags |= SPECIAL;
    2260:	e3811040 	orr	r1, r1, #64	; 0x40
    2264:	e58d1030 	str	r1, [sp, #48]	; 0x30
    2268:	ea000000 	b	2270 <vsnprintf+0x650>
			struct printf_spec spec)
{
	if (!ptr)
		return string(buf, end, "(null)", spec);

	switch (*fmt) {
    226c:	e58d5030 	str	r5, [sp, #48]	; 0x30
		/* Fallthrough */
	case 'i':
		spec.flags |= SPECIAL;
		/* Fallthrough */
	case 'I':
		if (fmt[1] == '4')
    2270:	e5d33001 	ldrb	r3, [r3, #1]
    2274:	e3530034 	cmp	r3, #52	; 0x34
			return ip4_addr_string(buf, end, ptr, spec);
		spec.flags &= ~SPECIAL;
    2278:	159d0030 	ldrne	r0, [sp, #48]	; 0x30
    227c:	13c03040 	bicne	r3, r0, #64	; 0x40
		/* Fallthrough */
	case 'i':
		spec.flags |= SPECIAL;
		/* Fallthrough */
	case 'I':
		if (fmt[1] == '4')
    2280:	1a00002a 	bne	2330 <vsnprintf+0x710>
    2284:	e1a0300b 	mov	r3, fp
static char *ip4_addr_string(char *buf, char *end, uint8_t *addr,
				struct printf_spec spec)
{
	char ip4_addr[4 * 4]; /* (4 * 3 decimal digits), 3 dots and trailing zero */
	char temp[3];	/* hold each IP quad in reverse order */
	char *p = ip4_addr;
    2288:	e28d4038 	add	r4, sp, #56	; 0x38
    228c:	e1a0b002 	mov	fp, r2
	int i, digits;

	for (i = 0; i < 4; i++) {
    2290:	e3a09000 	mov	r9, #0
    2294:	e1a02006 	mov	r2, r6
		digits = put_dec_trunc(temp, addr[i]) - temp;
    2298:	e28d604c 	add	r6, sp, #76	; 0x4c
    229c:	e7db1009 	ldrb	r1, [fp, r9]
    22a0:	e1a00006 	mov	r0, r6
    22a4:	e58d2014 	str	r2, [sp, #20]
    22a8:	e58d3010 	str	r3, [sp, #16]
    22ac:	ebfffc55 	bl	1408 <put_dec_trunc>
    22b0:	e1a0c004 	mov	ip, r4
    22b4:	e59d2014 	ldr	r2, [sp, #20]
    22b8:	e59d3010 	ldr	r3, [sp, #16]
    22bc:	e0660000 	rsb	r0, r6, r0
    22c0:	e1a01000 	mov	r1, r0
    22c4:	ea000002 	b	22d4 <vsnprintf+0x6b4>
		/* reverse the digits in the quad */
		while (digits--)
    22c8:	e2411001 	sub	r1, r1, #1
			*p++ = temp[digits];
    22cc:	e7d6e001 	ldrb	lr, [r6, r1]
    22d0:	e4cce001 	strb	lr, [ip], #1
	int i, digits;

	for (i = 0; i < 4; i++) {
		digits = put_dec_trunc(temp, addr[i]) - temp;
		/* reverse the digits in the quad */
		while (digits--)
    22d4:	e3510000 	cmp	r1, #0
    22d8:	1afffffa 	bne	22c8 <vsnprintf+0x6a8>
			*p++ = temp[digits];
		if (i != 3)
    22dc:	e3590003 	cmp	r9, #3
			*p++ = '.';
    22e0:	1281102e 	addne	r1, r1, #46	; 0x2e
	int i, digits;

	for (i = 0; i < 4; i++) {
		digits = put_dec_trunc(temp, addr[i]) - temp;
		/* reverse the digits in the quad */
		while (digits--)
    22e4:	e0844000 	add	r4, r4, r0
	char ip4_addr[4 * 4]; /* (4 * 3 decimal digits), 3 dots and trailing zero */
	char temp[3];	/* hold each IP quad in reverse order */
	char *p = ip4_addr;
	int i, digits;

	for (i = 0; i < 4; i++) {
    22e8:	e2899001 	add	r9, r9, #1
		digits = put_dec_trunc(temp, addr[i]) - temp;
		/* reverse the digits in the quad */
		while (digits--)
			*p++ = temp[digits];
		if (i != 3)
			*p++ = '.';
    22ec:	14c41001 	strbne	r1, [r4], #1
	char ip4_addr[4 * 4]; /* (4 * 3 decimal digits), 3 dots and trailing zero */
	char temp[3];	/* hold each IP quad in reverse order */
	char *p = ip4_addr;
	int i, digits;

	for (i = 0; i < 4; i++) {
    22f0:	e3590004 	cmp	r9, #4
    22f4:	1affffe7 	bne	2298 <vsnprintf+0x678>
    22f8:	e1a0b003 	mov	fp, r3
		while (digits--)
			*p++ = temp[digits];
		if (i != 3)
			*p++ = '.';
	}
	*p = '\0';
    22fc:	e3a03000 	mov	r3, #0
    2300:	e5c43000 	strb	r3, [r4]
	spec.flags &= ~SPECIAL;

	return string(buf, end, ip4_addr, spec);
    2304:	e59dc01c 	ldr	ip, [sp, #28]
    2308:	e59d1018 	ldr	r1, [sp, #24]
    230c:	e58dc004 	str	ip, [sp, #4]
    2310:	e59dc030 	ldr	ip, [sp, #48]	; 0x30
    2314:	e1a00002 	mov	r0, r2
    2318:	e3cc3040 	bic	r3, ip, #64	; 0x40
    231c:	e28d2038 	add	r2, sp, #56	; 0x38
    2320:	e58db000 	str	fp, [sp]
    2324:	ebfffd4e 	bl	1864 <string.clone.2>
    2328:	ea00000f 	b	236c <vsnprintf+0x74c>
			struct printf_spec spec)
{
	if (!ptr)
		return string(buf, end, "(null)", spec);

	switch (*fmt) {
    232c:	e1a03005 	mov	r3, r5
			return ip4_addr_string(buf, end, ptr, spec);
		spec.flags &= ~SPECIAL;
		break;
	}
	spec.flags |= SMALL;
	if (spec.field_width == -1) {
    2330:	e37b0001 	cmn	fp, #1
		if (fmt[1] == '4')
			return ip4_addr_string(buf, end, ptr, spec);
		spec.flags &= ~SPECIAL;
		break;
	}
	spec.flags |= SMALL;
    2334:	e3831020 	orr	r1, r3, #32
	if (spec.field_width == -1) {
		spec.field_width = 2*sizeof(void *);
		spec.flags |= ZEROPAD;
    2338:	03831021 	orreq	r1, r3, #33	; 0x21
	}
	spec.base = 16;

	return number(buf, end, (unsigned long) ptr, spec);
    233c:	e58d1000 	str	r1, [sp]
    2340:	e59d101c 	ldr	r1, [sp, #28]
		spec.flags &= ~SPECIAL;
		break;
	}
	spec.flags |= SMALL;
	if (spec.field_width == -1) {
		spec.field_width = 2*sizeof(void *);
    2344:	03a03008 	moveq	r3, #8
			return ip4_addr_string(buf, end, ptr, spec);
		spec.flags &= ~SPECIAL;
		break;
	}
	spec.flags |= SMALL;
	if (spec.field_width == -1) {
    2348:	11a0300b 	movne	r3, fp
		spec.field_width = 2*sizeof(void *);
		spec.flags |= ZEROPAD;
	}
	spec.base = 16;

	return number(buf, end, (unsigned long) ptr, spec);
    234c:	e58d3004 	str	r3, [sp, #4]
    2350:	e3a03010 	mov	r3, #16
    2354:	e58d3008 	str	r3, [sp, #8]
    2358:	e58d100c 	str	r1, [sp, #12]
    235c:	e1a00006 	mov	r0, r6
    2360:	e59d1018 	ldr	r1, [sp, #24]
    2364:	e3a03000 	mov	r3, #0
    2368:	ebfffc5e 	bl	14e8 <number.clone.0>
    236c:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
    2370:	e1a06000 	mov	r6, r0
			break;

		case FORMAT_TYPE_PTR:
			str = pointer(fmt+1, str, end, va_arg(args, void *),
				      spec);
			while (isalnum(*fmt))
    2374:	e59f017c 	ldr	r0, [pc, #380]	; 24f8 <vsnprintf+0x8d8>
    2378:	e5d31000 	ldrb	r1, [r3]
    237c:	e79a0000 	ldr	r0, [sl, r0]
    2380:	e1a02003 	mov	r2, r3
    2384:	e7d01001 	ldrb	r1, [r0, r1]
    2388:	e2833001 	add	r3, r3, #1
    238c:	e3110007 	tst	r1, #7
    2390:	1afffff7 	bne	2374 <vsnprintf+0x754>
    2394:	e58d2028 	str	r2, [sp, #40]	; 0x28
		case FORMAT_TYPE_STR:
			str = string(str, end, va_arg(args, char *), spec);
			break;

		case FORMAT_TYPE_PTR:
			str = pointer(fmt+1, str, end, va_arg(args, void *),
    2398:	e59d4034 	ldr	r4, [sp, #52]	; 0x34
    239c:	ea000044 	b	24b4 <vsnprintf+0x894>
			while (isalnum(*fmt))
				fmt++;
			break;

		case FORMAT_TYPE_PERCENT_CHAR:
			if (str < end)
    23a0:	e59d2018 	ldr	r2, [sp, #24]
    23a4:	e1560002 	cmp	r6, r2
    23a8:	ea000001 	b	23b4 <vsnprintf+0x794>
				*str = '%';
			++str;
			break;

		case FORMAT_TYPE_INVALID:
			if (str < end)
    23ac:	e59d3018 	ldr	r3, [sp, #24]
    23b0:	e1560003 	cmp	r6, r3
				*str = '%';
    23b4:	33a03025 	movcc	r3, #37	; 0x25
    23b8:	35c63000 	strbcc	r3, [r6]
			++str;
    23bc:	e2866001 	add	r6, r6, #1
			break;
    23c0:	ea00003b 	b	24b4 <vsnprintf+0x894>

		case FORMAT_TYPE_NRCHARS: {
			int qualifier = spec.qualifier;

			if (qualifier == 'l') {
    23c4:	e357006c 	cmp	r7, #108	; 0x6c
    23c8:	1a000005 	bne	23e4 <vsnprintf+0x7c4>
				long *ip = va_arg(args, long *);
				*ip = (str - buf);
    23cc:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
    23d0:	e5942000 	ldr	r2, [r4]
    23d4:	e06c3006 	rsb	r3, ip, r6
    23d8:	e5823000 	str	r3, [r2]

		case FORMAT_TYPE_NRCHARS: {
			int qualifier = spec.qualifier;

			if (qualifier == 'l') {
				long *ip = va_arg(args, long *);
    23dc:	e2844004 	add	r4, r4, #4
    23e0:	ea000033 	b	24b4 <vsnprintf+0x894>
    23e4:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
					qualifier == 'z') {
				size_t *ip = va_arg(args, size_t *);
				*ip = (str - buf);
			} else {
				int *ip = va_arg(args, int *);
				*ip = (str - buf);
    23e8:	e5941000 	ldr	r1, [r4]
    23ec:	e0602006 	rsb	r2, r0, r6
    23f0:	e2843004 	add	r3, r4, #4
    23f4:	e5812000 	str	r2, [r1]
			} else if (qualifier == 'Z' ||
					qualifier == 'z') {
				size_t *ip = va_arg(args, size_t *);
				*ip = (str - buf);
			} else {
				int *ip = va_arg(args, int *);
    23f8:	e1a04003 	mov	r4, r3
    23fc:	ea00002c 	b	24b4 <vsnprintf+0x894>
			}
			break;
		}

		default:
			switch (spec.type) {
    2400:	e2483008 	sub	r3, r8, #8
    2404:	e353000b 	cmp	r3, #11
    2408:	908ff103 	addls	pc, pc, r3, lsl #2
    240c:	ea00001c 	b	2484 <vsnprintf+0x864>
    2410:	ea00000a 	b	2440 <vsnprintf+0x820>
    2414:	ea00001a 	b	2484 <vsnprintf+0x864>
    2418:	ea000016 	b	2478 <vsnprintf+0x858>
    241c:	ea00000c 	b	2454 <vsnprintf+0x834>
    2420:	ea00000e 	b	2460 <vsnprintf+0x840>
    2424:	ea00000f 	b	2468 <vsnprintf+0x848>
    2428:	ea000010 	b	2470 <vsnprintf+0x850>
    242c:	ea000014 	b	2484 <vsnprintf+0x864>
    2430:	ea000010 	b	2478 <vsnprintf+0x858>
    2434:	ea000012 	b	2484 <vsnprintf+0x864>
    2438:	ea000011 	b	2484 <vsnprintf+0x864>
    243c:	ea000010 	b	2484 <vsnprintf+0x864>
			case FORMAT_TYPE_LONG_LONG:
				num = va_arg(args, long long);
    2440:	e2844007 	add	r4, r4, #7
    2444:	e3c43007 	bic	r3, r4, #7
    2448:	e2834008 	add	r4, r3, #8
    244c:	e1c320d0 	ldrd	r2, [r3]
				break;
    2450:	ea00000e 	b	2490 <vsnprintf+0x870>
				break;
			case FORMAT_TYPE_PTRDIFF:
				num = va_arg(args, unsigned long);
				break;
			case FORMAT_TYPE_UBYTE:
				num = (unsigned char) va_arg(args, int);
    2454:	e5d42000 	ldrb	r2, [r4]
    2458:	e3a03000 	mov	r3, #0
    245c:	ea00000a 	b	248c <vsnprintf+0x86c>
				break;
			case FORMAT_TYPE_BYTE:
				num = (signed char) va_arg(args, int);
    2460:	e1d420d0 	ldrsb	r2, [r4]
    2464:	ea000004 	b	247c <vsnprintf+0x85c>
				break;
			case FORMAT_TYPE_USHORT:
				num = (unsigned short) va_arg(args, int);
    2468:	e1d420b0 	ldrh	r2, [r4]
    246c:	ea000005 	b	2488 <vsnprintf+0x868>
				break;
			case FORMAT_TYPE_SHORT:
				num = (short) va_arg(args, int);
    2470:	e1d420f0 	ldrsh	r2, [r4]
    2474:	ea000000 	b	247c <vsnprintf+0x85c>
				break;
			case FORMAT_TYPE_INT:
				num = (int) va_arg(args, int);
    2478:	e5942000 	ldr	r2, [r4]
    247c:	e1a03fc2 	asr	r3, r2, #31
    2480:	ea000001 	b	248c <vsnprintf+0x86c>
				break;
			default:
				num = va_arg(args, unsigned int);
    2484:	e5942000 	ldr	r2, [r4]
    2488:	e3a03000 	mov	r3, #0
    248c:	e2844004 	add	r4, r4, #4
			}

			str = number(str, end, num, spec);
    2490:	e59d1020 	ldr	r1, [sp, #32]
    2494:	e59dc01c 	ldr	ip, [sp, #28]
    2498:	e58d1008 	str	r1, [sp, #8]
    249c:	e1a00006 	mov	r0, r6
    24a0:	e59d1018 	ldr	r1, [sp, #24]
    24a4:	e88d0820 	stm	sp, {r5, fp}
    24a8:	e58dc00c 	str	ip, [sp, #12]
    24ac:	ebfffc0d 	bl	14e8 <number.clone.0>
    24b0:	e1a06000 	mov	r6, r0
		case FORMAT_TYPE_WIDTH:
			spec.field_width = va_arg(args, int);
			break;

		case FORMAT_TYPE_PRECISION:
			spec.precision = va_arg(args, int);
    24b4:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
	if (end < buf) {
		end = ((void *)-1);
		size = end - buf;
	}

	while (*fmt) {
    24b8:	e5d13000 	ldrb	r3, [r1]
    24bc:	e3530000 	cmp	r3, #0
    24c0:	1afffdf4 	bne	1c98 <vsnprintf+0x78>

			str = number(str, end, num, spec);
		}
	}

	if (size > 0) {
    24c4:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
    24c8:	e3500000 	cmp	r0, #0
    24cc:	0a000004 	beq	24e4 <vsnprintf+0x8c4>
		if (str < end)
    24d0:	e59d1018 	ldr	r1, [sp, #24]
    24d4:	e1560001 	cmp	r6, r1
			*str = '\0';
		else
			end[-1] = '\0';
    24d8:	259d2018 	ldrcs	r2, [sp, #24]
		}
	}

	if (size > 0) {
		if (str < end)
			*str = '\0';
    24dc:	35c63000 	strbcc	r3, [r6]
		else
			end[-1] = '\0';
    24e0:	25423001 	strbcs	r3, [r2, #-1]
	}

	/* the trailing null byte doesn't count towards the total */
	return str-buf;
    24e4:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
    24e8:	e0630006 	rsb	r0, r3, r6

}
    24ec:	e28dd050 	add	sp, sp, #80	; 0x50
    24f0:	e8bd8bf0 	pop	{r4, r5, r6, r7, r8, r9, fp, pc}
    24f4:	00001684 	.word	0x00001684
    24f8:	000031c0 	.word	0x000031c0
    24fc:	00000df7 	.word	0x00000df7

00002500 <vscnprintf>:
 * You probably want scnprintf() instead.
 *
 * See the vsnprintf() documentation for format string extensions over C99.
 */
int vscnprintf(char *buf, size_t size, const char *fmt, va_list args)
{
    2500:	e92d4010 	push	{r4, lr}
    2504:	e1a04001 	mov	r4, r1
	int i;

	i=vsnprintf(buf,size,fmt,args);
    2508:	ebfffdc4 	bl	1c20 <vsnprintf>
	return (i >= size) ? (size - 1) : i;
    250c:	e1500004 	cmp	r0, r4
    2510:	22440001 	subcs	r0, r4, #1
}
    2514:	e8bd8010 	pop	{r4, pc}

00002518 <snprintf>:
 * @size, the resulting string is truncated.
 *
 * See the vsnprintf() documentation for format string extensions over C99.
 */
int snprintf(char * buf, size_t size, const char *fmt, ...)
{
    2518:	e92d000c 	push	{r2, r3}
    251c:	e92d4007 	push	{r0, r1, r2, lr}
	va_list args;
	int i;

	va_start(args, fmt);
	i=vsnprintf(buf,size,fmt,args);
    2520:	e59d2010 	ldr	r2, [sp, #16]
int snprintf(char * buf, size_t size, const char *fmt, ...)
{
	va_list args;
	int i;

	va_start(args, fmt);
    2524:	e28d3014 	add	r3, sp, #20
    2528:	e58d3004 	str	r3, [sp, #4]
	i=vsnprintf(buf,size,fmt,args);
    252c:	ebfffdbb 	bl	1c20 <vsnprintf>
	va_end(args);
	return i;
}
    2530:	e8bd400e 	pop	{r1, r2, r3, lr}
    2534:	e28dd008 	add	sp, sp, #8
    2538:	e12fff1e 	bx	lr

0000253c <scnprintf>:
 * The return value is the number of characters written into @buf not including
 * the trailing '\0'. If @size is <= 0 the function returns 0.
 */

int scnprintf(char * buf, size_t size, const char *fmt, ...)
{
    253c:	e92d000c 	push	{r2, r3}
    2540:	e92d4013 	push	{r0, r1, r4, lr}
	va_list args;
	int i;

	va_start(args, fmt);
	i = vsnprintf(buf, size, fmt, args);
    2544:	e59d2010 	ldr	r2, [sp, #16]
int scnprintf(char * buf, size_t size, const char *fmt, ...)
{
	va_list args;
	int i;

	va_start(args, fmt);
    2548:	e28d3014 	add	r3, sp, #20
 * The return value is the number of characters written into @buf not including
 * the trailing '\0'. If @size is <= 0 the function returns 0.
 */

int scnprintf(char * buf, size_t size, const char *fmt, ...)
{
    254c:	e1a04001 	mov	r4, r1
	va_list args;
	int i;

	va_start(args, fmt);
    2550:	e58d3004 	str	r3, [sp, #4]
	i = vsnprintf(buf, size, fmt, args);
    2554:	ebfffdb1 	bl	1c20 <vsnprintf>
	va_end(args);
	return (i >= size) ? (size - 1) : i;
    2558:	e1500004 	cmp	r0, r4
    255c:	22440001 	subcs	r0, r4, #1
}
    2560:	e8bd401c 	pop	{r2, r3, r4, lr}
    2564:	e28dd008 	add	sp, sp, #8
    2568:	e12fff1e 	bx	lr

0000256c <vsprintf>:
 * You probably want sprintf() instead.
 *
 * See the vsnprintf() documentation for format string extensions over C99.
 */
int vsprintf(char *buf, const char *fmt, va_list args)
{
    256c:	e1a0c001 	mov	ip, r1
    2570:	e1a03002 	mov	r3, r2
	return vsnprintf(buf, INT_MAX, fmt, args);
    2574:	e3e01102 	mvn	r1, #-2147483648	; 0x80000000
    2578:	e1a0200c 	mov	r2, ip
    257c:	eafffda7 	b	1c20 <vsnprintf>

00002580 <sprintf>:
 * buffer overflows.
 *
 * See the vsnprintf() documentation for format string extensions over C99.
 */
int sprintf(char * buf, const char *fmt, ...)
{
    2580:	e92d000e 	push	{r1, r2, r3}
    2584:	e92d4003 	push	{r0, r1, lr}
	va_list args;
	int i;

	va_start(args, fmt);
	i=vsnprintf(buf, INT_MAX, fmt, args);
    2588:	e59d200c 	ldr	r2, [sp, #12]
int sprintf(char * buf, const char *fmt, ...)
{
	va_list args;
	int i;

	va_start(args, fmt);
    258c:	e28d3010 	add	r3, sp, #16
	i=vsnprintf(buf, INT_MAX, fmt, args);
    2590:	e3e01102 	mvn	r1, #-2147483648	; 0x80000000
int sprintf(char * buf, const char *fmt, ...)
{
	va_list args;
	int i;

	va_start(args, fmt);
    2594:	e58d3004 	str	r3, [sp, #4]
	i=vsnprintf(buf, INT_MAX, fmt, args);
    2598:	ebfffda0 	bl	1c20 <vsnprintf>
	va_end(args);
	return i;
}
    259c:	e8bd400c 	pop	{r2, r3, lr}
    25a0:	e28dd00c 	add	sp, sp, #12
    25a4:	e12fff1e 	bx	lr

000025a8 <vsscanf>:
 * @buf:	input buffer
 * @fmt:	format of buffer
 * @args:	arguments
 */
int vsscanf(const char * buf, const char * fmt, va_list args)
{
    25a8:	e92d4bff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, fp, lr}
    25ac:	e1a0b000 	mov	fp, r0
    25b0:	e58d1004 	str	r1, [sp, #4]
    25b4:	e1a07002 	mov	r7, r2
	const char *str = buf;
    25b8:	e1a04000 	mov	r4, r0
	char *next;
	char digit;
	int num = 0;
    25bc:	e3a05000 	mov	r5, #0
	int qualifier;
	int base;
	int field_width;
	int is_sign = 0;

	while(*fmt && *str) {
    25c0:	ea000133 	b	2a94 <vsscanf+0x4ec>
		/* skip any white space in format */
		/* white space in format matchs any amount of
		 * white space, including none, in the input.
		 */
		if (isspace(*fmt)) {
    25c4:	e59f2514 	ldr	r2, [pc, #1300]	; 2ae0 <vsscanf+0x538>
    25c8:	e79a6002 	ldr	r6, [sl, r2]
    25cc:	e7d63003 	ldrb	r3, [r6, r3]
    25d0:	e1a08006 	mov	r8, r6
    25d4:	e3130020 	tst	r3, #32
    25d8:	1a000002 	bne	25e8 <vsscanf+0x40>
    25dc:	ea00000c 	b	2614 <vsscanf+0x6c>
			while (isspace(*fmt))
				++fmt;
    25e0:	e2833001 	add	r3, r3, #1
    25e4:	e58d3004 	str	r3, [sp, #4]
		/* skip any white space in format */
		/* white space in format matchs any amount of
		 * white space, including none, in the input.
		 */
		if (isspace(*fmt)) {
			while (isspace(*fmt))
    25e8:	e59d3004 	ldr	r3, [sp, #4]
    25ec:	e5d32000 	ldrb	r2, [r3]
    25f0:	e7d82002 	ldrb	r2, [r8, r2]
    25f4:	e3120020 	tst	r2, #32
    25f8:	1afffff8 	bne	25e0 <vsscanf+0x38>
    25fc:	e1a03004 	mov	r3, r4
    2600:	e1a04003 	mov	r4, r3
				++fmt;
			while (isspace(*str))
    2604:	e4d32001 	ldrb	r2, [r3], #1
    2608:	e7d82002 	ldrb	r2, [r8, r2]
    260c:	e3120020 	tst	r2, #32
    2610:	1afffffa 	bne	2600 <vsscanf+0x58>
				++str;
		}

		/* anything that is not a conversion must match exactly */
		if (*fmt != '%' && *fmt) {
    2614:	e59d3004 	ldr	r3, [sp, #4]
    2618:	e5d32000 	ldrb	r2, [r3]
    261c:	e3520000 	cmp	r2, #0
    2620:	13520025 	cmpne	r2, #37	; 0x25
    2624:	0a000005 	beq	2640 <vsscanf+0x98>
			if (*fmt++ != *str++)
    2628:	e4d41001 	ldrb	r1, [r4], #1
    262c:	e2833001 	add	r3, r3, #1
    2630:	e1520001 	cmp	r2, r1
    2634:	e58d3004 	str	r3, [sp, #4]
    2638:	1a00011c 	bne	2ab0 <vsscanf+0x508>
    263c:	ea000114 	b	2a94 <vsscanf+0x4ec>
				break;
			continue;
		}

		if (!*fmt)
    2640:	e3520000 	cmp	r2, #0
    2644:	0a000119 	beq	2ab0 <vsscanf+0x508>
			break;
		++fmt;
    2648:	e2832001 	add	r2, r3, #1
    264c:	e58d2004 	str	r2, [sp, #4]
		
		/* skip this conversion.
		 * advance both strings to next white space
		 */
		if (*fmt == '*') {
    2650:	e5d33001 	ldrb	r3, [r3, #1]
    2654:	e353002a 	cmp	r3, #42	; 0x2a
    2658:	1a000014 	bne	26b0 <vsscanf+0x108>
    265c:	ea000001 	b	2668 <vsscanf+0xc0>
			while (!isspace(*fmt) && *fmt)
				fmt++;
    2660:	e2822001 	add	r2, r2, #1
    2664:	e58d2004 	str	r2, [sp, #4]
		
		/* skip this conversion.
		 * advance both strings to next white space
		 */
		if (*fmt == '*') {
			while (!isspace(*fmt) && *fmt)
    2668:	e59d2004 	ldr	r2, [sp, #4]
    266c:	e5d23000 	ldrb	r3, [r2]
    2670:	e7d81003 	ldrb	r1, [r8, r3]
    2674:	e3110020 	tst	r1, #32
    2678:	0a000001 	beq	2684 <vsscanf+0xdc>
    267c:	e1a03004 	mov	r3, r4
    2680:	ea000002 	b	2690 <vsscanf+0xe8>
    2684:	e3530000 	cmp	r3, #0
    2688:	1afffff4 	bne	2660 <vsscanf+0xb8>
    268c:	eafffffa 	b	267c <vsscanf+0xd4>
    2690:	e1a04003 	mov	r4, r3
				fmt++;
			while (!isspace(*str) && *str)
    2694:	e4d32001 	ldrb	r2, [r3], #1
    2698:	e7d81002 	ldrb	r1, [r8, r2]
    269c:	e3110020 	tst	r1, #32
    26a0:	1a0000fb 	bne	2a94 <vsscanf+0x4ec>
    26a4:	e3520000 	cmp	r2, #0
    26a8:	1afffff8 	bne	2690 <vsscanf+0xe8>
    26ac:	ea0000f8 	b	2a94 <vsscanf+0x4ec>
			continue;
		}

		/* get field width */
		field_width = -1;
		if (isdigit(*fmt))
    26b0:	e7d63003 	ldrb	r3, [r6, r3]
    26b4:	e3130004 	tst	r3, #4
				str++;
			continue;
		}

		/* get field width */
		field_width = -1;
    26b8:	03e00000 	mvneq	r0, #0
		if (isdigit(*fmt))
    26bc:	0a000001 	beq	26c8 <vsscanf+0x120>
			field_width = skip_atoi(&fmt);
    26c0:	e28d0004 	add	r0, sp, #4
    26c4:	ebfffb3e 	bl	13c4 <skip_atoi>

		/* get conversion qualifier */
		qualifier = -1;
		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' ||
    26c8:	e59d1004 	ldr	r1, [sp, #4]
    26cc:	e5d13000 	ldrb	r3, [r1]
    26d0:	e3530068 	cmp	r3, #104	; 0x68
    26d4:	1353006c 	cmpne	r3, #108	; 0x6c
    26d8:	0a000006 	beq	26f8 <vsscanf+0x150>
    26dc:	e353004c 	cmp	r3, #76	; 0x4c
    26e0:	0a000004 	beq	26f8 <vsscanf+0x150>
    26e4:	e353005a 	cmp	r3, #90	; 0x5a
    26e8:	0a000002 	beq	26f8 <vsscanf+0x150>
		    *fmt == 'Z' || *fmt == 'z') {
    26ec:	e353007a 	cmp	r3, #122	; 0x7a
		field_width = -1;
		if (isdigit(*fmt))
			field_width = skip_atoi(&fmt);

		/* get conversion qualifier */
		qualifier = -1;
    26f0:	13e03000 	mvnne	r3, #0
		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' ||
		    *fmt == 'Z' || *fmt == 'z') {
    26f4:	1a00000d 	bne	2730 <vsscanf+0x188>
			qualifier = *fmt++;
    26f8:	e2812001 	add	r2, r1, #1
    26fc:	e58d2004 	str	r2, [sp, #4]
			if (unlikely(qualifier == *fmt)) {
    2700:	e5d11001 	ldrb	r1, [r1, #1]
    2704:	e1530001 	cmp	r3, r1
    2708:	1a000008 	bne	2730 <vsscanf+0x188>
				if (qualifier == 'h') {
    270c:	e3530068 	cmp	r3, #104	; 0x68
					qualifier = 'H';
					fmt++;
    2710:	02822001 	addeq	r2, r2, #1
    2714:	058d2004 	streq	r2, [sp, #4]
		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' ||
		    *fmt == 'Z' || *fmt == 'z') {
			qualifier = *fmt++;
			if (unlikely(qualifier == *fmt)) {
				if (qualifier == 'h') {
					qualifier = 'H';
    2718:	03a03048 	moveq	r3, #72	; 0x48
		qualifier = -1;
		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' ||
		    *fmt == 'Z' || *fmt == 'z') {
			qualifier = *fmt++;
			if (unlikely(qualifier == *fmt)) {
				if (qualifier == 'h') {
    271c:	0a000003 	beq	2730 <vsscanf+0x188>
					qualifier = 'H';
					fmt++;
				} else if (qualifier == 'l') {
    2720:	e353006c 	cmp	r3, #108	; 0x6c
					qualifier = 'L';
					fmt++;
    2724:	02822001 	addeq	r2, r2, #1
			if (unlikely(qualifier == *fmt)) {
				if (qualifier == 'h') {
					qualifier = 'H';
					fmt++;
				} else if (qualifier == 'l') {
					qualifier = 'L';
    2728:	03a0304c 	moveq	r3, #76	; 0x4c
					fmt++;
    272c:	058d2004 	streq	r2, [sp, #4]
			}
		}
		base = 10;
		is_sign = 0;

		if (!*fmt || !*str)
    2730:	e59d1004 	ldr	r1, [sp, #4]
    2734:	e5d12000 	ldrb	r2, [r1]
    2738:	e3520000 	cmp	r2, #0
    273c:	0a0000db 	beq	2ab0 <vsscanf+0x508>
    2740:	e5d4c000 	ldrb	ip, [r4]
    2744:	e35c0000 	cmp	ip, #0
    2748:	0a0000d8 	beq	2ab0 <vsscanf+0x508>
			break;

		switch(*fmt++) {
    274c:	e2811001 	add	r1, r1, #1
    2750:	e352006e 	cmp	r2, #110	; 0x6e
    2754:	e58d1004 	str	r1, [sp, #4]
    2758:	0a000047 	beq	287c <vsscanf+0x2d4>
    275c:	8a00000b 	bhi	2790 <vsscanf+0x1e8>
    2760:	e3520063 	cmp	r2, #99	; 0x63
    2764:	0a00001a 	beq	27d4 <vsscanf+0x22c>
    2768:	8a000003 	bhi	277c <vsscanf+0x1d4>
    276c:	e3520025 	cmp	r2, #37	; 0x25
    2770:	0a00004f 	beq	28b4 <vsscanf+0x30c>
    2774:	e3520058 	cmp	r2, #88	; 0x58
    2778:	ea00000d 	b	27b4 <vsscanf+0x20c>
    277c:	e3520064 	cmp	r2, #100	; 0x64
    2780:	0a00000f 	beq	27c4 <vsscanf+0x21c>
    2784:	e3520069 	cmp	r2, #105	; 0x69
    2788:	1a0000d1 	bne	2ad4 <vsscanf+0x52c>
    278c:	ea000045 	b	28a8 <vsscanf+0x300>
    2790:	e3520073 	cmp	r2, #115	; 0x73
    2794:	0a00001e 	beq	2814 <vsscanf+0x26c>
    2798:	8a000002 	bhi	27a8 <vsscanf+0x200>
    279c:	e352006f 	cmp	r2, #111	; 0x6f
    27a0:	1a0000cb 	bne	2ad4 <vsscanf+0x52c>
    27a4:	ea000039 	b	2890 <vsscanf+0x2e8>
    27a8:	e3520075 	cmp	r2, #117	; 0x75
    27ac:	0a000002 	beq	27bc <vsscanf+0x214>
    27b0:	e3520078 	cmp	r2, #120	; 0x78
    27b4:	1a0000c6 	bne	2ad4 <vsscanf+0x52c>
    27b8:	ea000037 	b	289c <vsscanf+0x2f4>
					fmt++;
				}
			}
		}
		base = 10;
		is_sign = 0;
    27bc:	e3a01000 	mov	r1, #0
    27c0:	ea000000 	b	27c8 <vsscanf+0x220>
			base = 16;
			break;
		case 'i':
                        base = 0;
		case 'd':
			is_sign = 1;
    27c4:	e3a01001 	mov	r1, #1
					qualifier = 'L';
					fmt++;
				}
			}
		}
		base = 10;
    27c8:	e3a0200a 	mov	r2, #10
		is_sign = 0;

		if (!*fmt || !*str)
			break;

		switch(*fmt++) {
    27cc:	e1a0c004 	mov	ip, r4
    27d0:	ea00003c 	b	28c8 <vsscanf+0x320>
		case 'c':
		{
			char *s = (char *) va_arg(args,char*);
    27d4:	e5971000 	ldr	r1, [r7]
			if (field_width == -1)
				field_width = 1;
    27d8:	e3700001 	cmn	r0, #1
			break;

		switch(*fmt++) {
		case 'c':
		{
			char *s = (char *) va_arg(args,char*);
    27dc:	e287c004 	add	ip, r7, #4
			if (field_width == -1)
				field_width = 1;
    27e0:	03a00001 	moveq	r0, #1

		switch(*fmt++) {
		case 'c':
		{
			char *s = (char *) va_arg(args,char*);
			if (field_width == -1)
    27e4:	e1a03004 	mov	r3, r4
				field_width = 1;
    27e8:	e1a02004 	mov	r2, r4
			do {
				*s++ = *str++;
    27ec:	e4d34001 	ldrb	r4, [r3], #1
			} while (--field_width > 0 && *str);
    27f0:	e2400001 	sub	r0, r0, #1
    27f4:	e3500000 	cmp	r0, #0
		{
			char *s = (char *) va_arg(args,char*);
			if (field_width == -1)
				field_width = 1;
			do {
				*s++ = *str++;
    27f8:	e4c14001 	strb	r4, [r1], #1
    27fc:	e1a04003 	mov	r4, r3
			} while (--field_width > 0 && *str);
    2800:	da00001a 	ble	2870 <vsscanf+0x2c8>
    2804:	e5f26001 	ldrb	r6, [r2, #1]!
    2808:	e3560000 	cmp	r6, #0
    280c:	1afffff6 	bne	27ec <vsscanf+0x244>
    2810:	ea000016 	b	2870 <vsscanf+0x2c8>
			num++;
		}
		continue;
		case 's':
		{
			char *s = (char *) va_arg(args, char *);
    2814:	e5973000 	ldr	r3, [r7]
			if(field_width == -1)
				field_width = INT_MAX;
    2818:	e3700001 	cmn	r0, #1
			num++;
		}
		continue;
		case 's':
		{
			char *s = (char *) va_arg(args, char *);
    281c:	e287c004 	add	ip, r7, #4
			if(field_width == -1)
				field_width = INT_MAX;
    2820:	03e00102 	mvneq	r0, #-2147483648	; 0x80000000
		}
		continue;
		case 's':
		{
			char *s = (char *) va_arg(args, char *);
			if(field_width == -1)
    2824:	e1a02004 	mov	r2, r4
				field_width = INT_MAX;
			/* first, skip leading white space in buffer */
			while (isspace(*str))
    2828:	e4d41001 	ldrb	r1, [r4], #1
    282c:	e7d81001 	ldrb	r1, [r8, r1]
    2830:	e3110020 	tst	r1, #32
    2834:	1afffffa 	bne	2824 <vsscanf+0x27c>
    2838:	ea000001 	b	2844 <vsscanf+0x29c>
				str++;

			/* now copy until next white space */
			while (*str && !isspace(*str) && field_width--) {
    283c:	e2400001 	sub	r0, r0, #1
				*s++ = *str++;
    2840:	e4c31001 	strb	r1, [r3], #1
    2844:	e1a04002 	mov	r4, r2
			/* first, skip leading white space in buffer */
			while (isspace(*str))
				str++;

			/* now copy until next white space */
			while (*str && !isspace(*str) && field_width--) {
    2848:	e4d21001 	ldrb	r1, [r2], #1
    284c:	e3510000 	cmp	r1, #0
    2850:	0a000004 	beq	2868 <vsscanf+0x2c0>
    2854:	e7d86001 	ldrb	r6, [r8, r1]
    2858:	e3160020 	tst	r6, #32
    285c:	1a000001 	bne	2868 <vsscanf+0x2c0>
    2860:	e3500000 	cmp	r0, #0
    2864:	1afffff4 	bne	283c <vsscanf+0x294>
				*s++ = *str++;
			}
			*s = '\0';
    2868:	e3a02000 	mov	r2, #0
    286c:	e5c32000 	strb	r2, [r3]
			num++;
    2870:	e2855001 	add	r5, r5, #1
			num++;
		}
		continue;
		case 's':
		{
			char *s = (char *) va_arg(args, char *);
    2874:	e1a0700c 	mov	r7, ip
				*s++ = *str++;
			}
			*s = '\0';
			num++;
		}
		continue;
    2878:	ea000085 	b	2a94 <vsscanf+0x4ec>
		case 'n':
			/* return number of characters read so far */
		{
			int *i = (int *)va_arg(args,int*);
			*i = str - buf;
    287c:	e5973000 	ldr	r3, [r7]
    2880:	e06b2004 	rsb	r2, fp, r4
    2884:	e5832000 	str	r2, [r3]
		}
		continue;
		case 'n':
			/* return number of characters read so far */
		{
			int *i = (int *)va_arg(args,int*);
    2888:	e2877004 	add	r7, r7, #4
			*i = str - buf;
		}
		continue;
    288c:	ea000080 	b	2a94 <vsscanf+0x4ec>
					fmt++;
				}
			}
		}
		base = 10;
		is_sign = 0;
    2890:	e3a01000 	mov	r1, #0
			int *i = (int *)va_arg(args,int*);
			*i = str - buf;
		}
		continue;
		case 'o':
			base = 8;
    2894:	e3a02008 	mov	r2, #8
			break;
    2898:	eaffffcb 	b	27cc <vsscanf+0x224>
					fmt++;
				}
			}
		}
		base = 10;
		is_sign = 0;
    289c:	e3a01000 	mov	r1, #0
		case 'o':
			base = 8;
			break;
		case 'x':
		case 'X':
			base = 16;
    28a0:	e3a02010 	mov	r2, #16
			break;
    28a4:	eaffffc8 	b	27cc <vsscanf+0x224>
		case 'i':
                        base = 0;
		case 'd':
			is_sign = 1;
    28a8:	e3a01001 	mov	r1, #1
		case 'x':
		case 'X':
			base = 16;
			break;
		case 'i':
                        base = 0;
    28ac:	e3a02000 	mov	r2, #0
    28b0:	eaffffc5 	b	27cc <vsscanf+0x224>
			is_sign = 1;
		case 'u':
			break;
		case '%':
			/* looking for '%' in str */
			if (*str++ != '%') 
    28b4:	e5d43000 	ldrb	r3, [r4]
    28b8:	e3530025 	cmp	r3, #37	; 0x25
    28bc:	1a000084 	bne	2ad4 <vsscanf+0x52c>
    28c0:	e2844001 	add	r4, r4, #1
    28c4:	ea000072 	b	2a94 <vsscanf+0x4ec>
		}

		/* have some sort of integer conversion.
		 * first, skip white space in buffer.
		 */
		while (isspace(*str))
    28c8:	e5dc0000 	ldrb	r0, [ip]
			is_sign = 1;
		case 'u':
			break;
		case '%':
			/* looking for '%' in str */
			if (*str++ != '%') 
    28cc:	e1a0400c 	mov	r4, ip
		}

		/* have some sort of integer conversion.
		 * first, skip white space in buffer.
		 */
		while (isspace(*str))
    28d0:	e7d89000 	ldrb	r9, [r8, r0]
    28d4:	e28cc001 	add	ip, ip, #1
    28d8:	e3190020 	tst	r9, #32
    28dc:	1afffff9 	bne	28c8 <vsscanf+0x320>
			str++;

		digit = *str;
		if (is_sign && digit == '-')
    28e0:	e350002d 	cmp	r0, #45	; 0x2d
    28e4:	13a0c000 	movne	ip, #0
    28e8:	0201c001 	andeq	ip, r1, #1
    28ec:	e35c0000 	cmp	ip, #0
			digit = *(str + 1);
    28f0:	15d40001 	ldrbne	r0, [r4, #1]

		if (!digit
    28f4:	e3500000 	cmp	r0, #0
    28f8:	0a00006c 	beq	2ab0 <vsscanf+0x508>
                    || (base == 16 && !isxdigit(digit))
    28fc:	e3520010 	cmp	r2, #16
    2900:	1a000002 	bne	2910 <vsscanf+0x368>
    2904:	e7d60000 	ldrb	r0, [r6, r0]
    2908:	e3100044 	tst	r0, #68	; 0x44
    290c:	ea000011 	b	2958 <vsscanf+0x3b0>
                    || (base == 10 && !isdigit(digit))
    2910:	e352000a 	cmp	r2, #10
    2914:	0a00000d 	beq	2950 <vsscanf+0x3a8>
                    || (base == 8 && (!isdigit(digit) || digit > '7'))
    2918:	e3520008 	cmp	r2, #8
    291c:	1a000009 	bne	2948 <vsscanf+0x3a0>
    2920:	e7d6c000 	ldrb	ip, [r6, r0]
    2924:	e31c0004 	tst	ip, #4
    2928:	13a0c000 	movne	ip, #0
    292c:	03a0c001 	moveq	ip, #1
    2930:	e3500037 	cmp	r0, #55	; 0x37
    2934:	91a0000c 	movls	r0, ip
    2938:	838c0001 	orrhi	r0, ip, #1
    293c:	e3500000 	cmp	r0, #0
    2940:	0a000005 	beq	295c <vsscanf+0x3b4>
    2944:	ea000059 	b	2ab0 <vsscanf+0x508>
                    || (base == 0 && !isdigit(digit)))
    2948:	e3520000 	cmp	r2, #0
    294c:	1a000002 	bne	295c <vsscanf+0x3b4>
    2950:	e7d60000 	ldrb	r0, [r6, r0]
    2954:	e3100004 	tst	r0, #4
    2958:	0a000054 	beq	2ab0 <vsscanf+0x508>
				break;

		switch(qualifier) {
    295c:	e353005a 	cmp	r3, #90	; 0x5a
    2960:	0a000036 	beq	2a40 <vsscanf+0x498>
    2964:	ca000004 	bgt	297c <vsscanf+0x3d4>
    2968:	e3530048 	cmp	r3, #72	; 0x48
    296c:	0a000009 	beq	2998 <vsscanf+0x3f0>
    2970:	e353004c 	cmp	r3, #76	; 0x4c
    2974:	1a000033 	bne	2a48 <vsscanf+0x4a0>
    2978:	ea000022 	b	2a08 <vsscanf+0x460>
    297c:	e353006c 	cmp	r3, #108	; 0x6c
    2980:	0a000030 	beq	2a48 <vsscanf+0x4a0>
    2984:	e353007a 	cmp	r3, #122	; 0x7a
    2988:	0a00002c 	beq	2a40 <vsscanf+0x498>
    298c:	e3530068 	cmp	r3, #104	; 0x68
    2990:	1a00002c 	bne	2a48 <vsscanf+0x4a0>
    2994:	ea00000d 	b	29d0 <vsscanf+0x428>
		case 'H':	/* that's 'hh' in format */
			if (is_sign) {
    2998:	e3510000 	cmp	r1, #0
    299c:	e2876004 	add	r6, r7, #4
    29a0:	0a000004 	beq	29b8 <vsscanf+0x410>
				signed char *s = (signed char *) va_arg(args,signed char *);
				*s = (signed char) simple_strtol(str,&next,base);
    29a4:	e1a00004 	mov	r0, r4
    29a8:	e28d100c 	add	r1, sp, #12
				break;

		switch(qualifier) {
		case 'H':	/* that's 'hh' in format */
			if (is_sign) {
				signed char *s = (signed char *) va_arg(args,signed char *);
    29ac:	e5977000 	ldr	r7, [r7]
				*s = (signed char) simple_strtol(str,&next,base);
    29b0:	ebfffbfb 	bl	19a4 <simple_strtol>
    29b4:	ea000003 	b	29c8 <vsscanf+0x420>
			} else {
				unsigned char *s = (unsigned char *) va_arg(args, unsigned char *);
				*s = (unsigned char) simple_strtoul(str, &next, base);
    29b8:	e1a00004 	mov	r0, r4
    29bc:	e28d100c 	add	r1, sp, #12
		case 'H':	/* that's 'hh' in format */
			if (is_sign) {
				signed char *s = (signed char *) va_arg(args,signed char *);
				*s = (signed char) simple_strtol(str,&next,base);
			} else {
				unsigned char *s = (unsigned char *) va_arg(args, unsigned char *);
    29c0:	e5977000 	ldr	r7, [r7]
				*s = (unsigned char) simple_strtoul(str, &next, base);
    29c4:	ebfffbd2 	bl	1914 <simple_strtoul>
    29c8:	e5c70000 	strb	r0, [r7]
    29cc:	ea00002a 	b	2a7c <vsscanf+0x4d4>
			}
			break;
		case 'h':
			if (is_sign) {
    29d0:	e3510000 	cmp	r1, #0
    29d4:	e2876004 	add	r6, r7, #4
    29d8:	0a000004 	beq	29f0 <vsscanf+0x448>
				short *s = (short *) va_arg(args,short *);
				*s = (short) simple_strtol(str,&next,base);
    29dc:	e1a00004 	mov	r0, r4
    29e0:	e28d100c 	add	r1, sp, #12
				*s = (unsigned char) simple_strtoul(str, &next, base);
			}
			break;
		case 'h':
			if (is_sign) {
				short *s = (short *) va_arg(args,short *);
    29e4:	e5977000 	ldr	r7, [r7]
				*s = (short) simple_strtol(str,&next,base);
    29e8:	ebfffbed 	bl	19a4 <simple_strtol>
    29ec:	ea000003 	b	2a00 <vsscanf+0x458>
			} else {
				unsigned short *s = (unsigned short *) va_arg(args, unsigned short *);
				*s = (unsigned short) simple_strtoul(str, &next, base);
    29f0:	e1a00004 	mov	r0, r4
    29f4:	e28d100c 	add	r1, sp, #12
		case 'h':
			if (is_sign) {
				short *s = (short *) va_arg(args,short *);
				*s = (short) simple_strtol(str,&next,base);
			} else {
				unsigned short *s = (unsigned short *) va_arg(args, unsigned short *);
    29f8:	e5977000 	ldr	r7, [r7]
				*s = (unsigned short) simple_strtoul(str, &next, base);
    29fc:	ebfffbc4 	bl	1914 <simple_strtoul>
    2a00:	e1c700b0 	strh	r0, [r7]
    2a04:	ea00001c 	b	2a7c <vsscanf+0x4d4>
				unsigned long *l = (unsigned long*) va_arg(args,unsigned long*);
				*l = simple_strtoul(str,&next,base);
			}
			break;
		case 'L':
			if (is_sign) {
    2a08:	e3510000 	cmp	r1, #0
    2a0c:	e2876004 	add	r6, r7, #4
    2a10:	0a000004 	beq	2a28 <vsscanf+0x480>
				long long *l = (long long*) va_arg(args,long long *);
				*l = simple_strtoll(str,&next,base);
    2a14:	e1a00004 	mov	r0, r4
    2a18:	e28d100c 	add	r1, sp, #12
				*l = simple_strtoul(str,&next,base);
			}
			break;
		case 'L':
			if (is_sign) {
				long long *l = (long long*) va_arg(args,long long *);
    2a1c:	e5977000 	ldr	r7, [r7]
				*l = simple_strtoll(str,&next,base);
    2a20:	ebfffc14 	bl	1a78 <simple_strtoll>
    2a24:	ea000003 	b	2a38 <vsscanf+0x490>
			} else {
				unsigned long long *l = (unsigned long long*) va_arg(args,unsigned long long*);
				*l = simple_strtoull(str,&next,base);
    2a28:	e1a00004 	mov	r0, r4
    2a2c:	e28d100c 	add	r1, sp, #12
		case 'L':
			if (is_sign) {
				long long *l = (long long*) va_arg(args,long long *);
				*l = simple_strtoll(str,&next,base);
			} else {
				unsigned long long *l = (unsigned long long*) va_arg(args,unsigned long long*);
    2a30:	e5977000 	ldr	r7, [r7]
				*l = simple_strtoull(str,&next,base);
    2a34:	ebfffbe4 	bl	19cc <simple_strtoull>
    2a38:	e1c700f0 	strd	r0, [r7]
    2a3c:	ea00000e 	b	2a7c <vsscanf+0x4d4>
			}
			break;
		case 'Z':
		case 'z':
		{
			size_t *s = (size_t*) va_arg(args,size_t*);
    2a40:	e2876004 	add	r6, r7, #4
    2a44:	ea000007 	b	2a68 <vsscanf+0x4c0>
			*s = (size_t) simple_strtoul(str,&next,base);
		}
		break;
		default:
			if (is_sign) {
    2a48:	e3510000 	cmp	r1, #0
    2a4c:	e2876004 	add	r6, r7, #4
    2a50:	0a000004 	beq	2a68 <vsscanf+0x4c0>
				int *i = (int *) va_arg(args, int*);
				*i = (int) simple_strtol(str,&next,base);
    2a54:	e1a00004 	mov	r0, r4
    2a58:	e28d100c 	add	r1, sp, #12
			*s = (size_t) simple_strtoul(str,&next,base);
		}
		break;
		default:
			if (is_sign) {
				int *i = (int *) va_arg(args, int*);
    2a5c:	e5977000 	ldr	r7, [r7]
				*i = (int) simple_strtol(str,&next,base);
    2a60:	ebfffbcf 	bl	19a4 <simple_strtol>
    2a64:	ea000003 	b	2a78 <vsscanf+0x4d0>
			} else {
				unsigned int *i = (unsigned int*) va_arg(args, unsigned int*);
				*i = (unsigned int) simple_strtoul(str,&next,base);
    2a68:	e1a00004 	mov	r0, r4
    2a6c:	e28d100c 	add	r1, sp, #12
		default:
			if (is_sign) {
				int *i = (int *) va_arg(args, int*);
				*i = (int) simple_strtol(str,&next,base);
			} else {
				unsigned int *i = (unsigned int*) va_arg(args, unsigned int*);
    2a70:	e5977000 	ldr	r7, [r7]
				*i = (unsigned int) simple_strtoul(str,&next,base);
    2a74:	ebfffba6 	bl	1914 <simple_strtoul>
    2a78:	e5870000 	str	r0, [r7]
			}
			break;
		}
		num++;

		if (!next)
    2a7c:	e59d300c 	ldr	r3, [sp, #12]
		default:
			if (is_sign) {
				int *i = (int *) va_arg(args, int*);
				*i = (int) simple_strtol(str,&next,base);
			} else {
				unsigned int *i = (unsigned int*) va_arg(args, unsigned int*);
    2a80:	e1a07006 	mov	r7, r6
			}
			break;
		}
		num++;

		if (!next)
    2a84:	e3530000 	cmp	r3, #0
				unsigned int *i = (unsigned int*) va_arg(args, unsigned int*);
				*i = (unsigned int) simple_strtoul(str,&next,base);
			}
			break;
		}
		num++;
    2a88:	e2855001 	add	r5, r5, #1

		if (!next)
    2a8c:	0a000007 	beq	2ab0 <vsscanf+0x508>
    2a90:	e1a04003 	mov	r4, r3
	int qualifier;
	int base;
	int field_width;
	int is_sign = 0;

	while(*fmt && *str) {
    2a94:	e59d3004 	ldr	r3, [sp, #4]
    2a98:	e5d33000 	ldrb	r3, [r3]
    2a9c:	e3530000 	cmp	r3, #0
    2aa0:	0a000002 	beq	2ab0 <vsscanf+0x508>
    2aa4:	e5d42000 	ldrb	r2, [r4]
    2aa8:	e3520000 	cmp	r2, #0
    2aac:	1afffec4 	bne	25c4 <vsscanf+0x1c>
	/*
	 * Now we've come all the way through so either the input string or the
	 * format ended. In the former case, there can be a %n at the current
	 * position in the format that needs to be filled.
	 */
	if (*fmt == '%' && *(fmt + 1) == 'n') {
    2ab0:	e59d3004 	ldr	r3, [sp, #4]
    2ab4:	e5d32000 	ldrb	r2, [r3]
    2ab8:	e3520025 	cmp	r2, #37	; 0x25
    2abc:	1a000004 	bne	2ad4 <vsscanf+0x52c>
    2ac0:	e5d33001 	ldrb	r3, [r3, #1]
    2ac4:	e353006e 	cmp	r3, #110	; 0x6e
		int *p = (int *)va_arg(args, int *);
		*p = str - buf;
    2ac8:	05973000 	ldreq	r3, [r7]
    2acc:	006b4004 	rsbeq	r4, fp, r4
    2ad0:	05834000 	streq	r4, [r3]
	}

	return num;
}
    2ad4:	e1a00005 	mov	r0, r5
    2ad8:	e28dd010 	add	sp, sp, #16
    2adc:	e8bd8bf0 	pop	{r4, r5, r6, r7, r8, r9, fp, pc}
    2ae0:	000031c0 	.word	0x000031c0

00002ae4 <sscanf>:
 * @buf:	input buffer
 * @fmt:	formatting of buffer
 * @...:	resulting arguments
 */
int sscanf(const char * buf, const char * fmt, ...)
{
    2ae4:	e92d000e 	push	{r1, r2, r3}
    2ae8:	e92d4003 	push	{r0, r1, lr}
	va_list args;
	int i;

	va_start(args,fmt);
	i = vsscanf(buf,fmt,args);
    2aec:	e59d100c 	ldr	r1, [sp, #12]
int sscanf(const char * buf, const char * fmt, ...)
{
	va_list args;
	int i;

	va_start(args,fmt);
    2af0:	e28d2010 	add	r2, sp, #16
    2af4:	e58d2004 	str	r2, [sp, #4]
	i = vsscanf(buf,fmt,args);
    2af8:	ebfffeaa 	bl	25a8 <vsscanf>
	va_end(args);
	return i;
}
    2afc:	e8bd400c 	pop	{r2, r3, lr}
    2b00:	e28dd00c 	add	sp, sp, #12
    2b04:	e12fff1e 	bx	lr
    2b08:	00000000 	andeq	r0, r0, r0
    2b0c:	00000000 	andeq	r0, r0, r0

00002b10 <f_osc>:
    2b10:	016e3600 316d610a 6c207838 61726269     .6n..am18x libra
    2b20:	66207972 6120726f 3038316d 73702038     ry for am1808 ps
    2b30:	000a2163 6432255b 2d25205d 20733032     c!..[%2d] %-20s 
    2b40:	32255b3d 25205d64 50000a73 455f4353     =[%2d] %s..PSC_E
    2b50:	33414d44 435f305f 53500030 44455f43     DMA3_0_C0.PSC_ED
    2b60:	5f33414d 30545f30 43535000 4d44455f     MA3_0_T0.PSC_EDM
    2b70:	305f3341 0031545f 5f435350 46494d45     A3_0_T1.PSC_EMIF
    2b80:	53500041 50535f43 50003049 4d5f4353     A.PSC_SPI0.PSC_M
    2b90:	535f434d 50003044 415f4353 495f4d52     MC_SD0.PSC_ARM_I
    2ba0:	0043544e 5f435350 5f4d5241 5f4d4152     NTC.PSC_ARM_RAM_
    2bb0:	004d4f52 5f435350 45534552 44455652     ROM.PSC_RESERVED
    2bc0:	53500030 41555f43 00305452 5f435350     0.PSC_UART0.PSC_
    2bd0:	30524353 43535000 5243535f 53500031     SCR0.PSC_SCR1.PS
    2be0:	43535f43 50003252 505f4353 50005552     C_SCR2.PSC_PRU.P
    2bf0:	415f4353 50004d52 525f4353 52455345     SC_ARM.PSC_RESER
    2c00:	31444556 43535000 4d44455f 315f3341     VED1.PSC_EDMA3_1
    2c10:	0030435f 5f435350 30425355 43535000     _C0.PSC_USB0.PSC
    2c20:	4253555f 53500031 50475f43 50004f49     _USB1.PSC_GPIO.P
    2c30:	485f4353 50004950 455f4353 0043414d     SC_HPI.PSC_EMAC.
    2c40:	5f435350 32524444 43535000 41434d5f     PSC_DDR2.PSC_MCA
    2c50:	00305053 5f435350 41544153 43535000     SP0.PSC_SATA.PSC
    2c60:	4950565f 53500046 50535f43 50003149     _VPIF.PSC_SPI1.P
    2c70:	495f4353 00314332 5f435350 54524155     SC_I2C1.PSC_UART
    2c80:	53500031 41555f43 00325452 5f435350     1.PSC_UART2.PSC_
    2c90:	5342434d 50003050 4d5f4353 50534243     MCBSP0.PSC_MCBSP
    2ca0:	53500031 434c5f43 50004344 455f4353     1.PSC_LCDC.PSC_E
    2cb0:	57505248 5350004d 4d4d5f43 44535f43     HRPWM.PSC_MMC_SD
    2cc0:	53500031 50555f43 53500050 43455f43     1.PSC_UPP.PSC_EC
    2cd0:	50005041 455f4353 33414d44 545f315f     AP.PSC_EDMA3_1_T
    2ce0:	53500030 45525f43 56524553 00324445     0.PSC_RESERVED2.
    2cf0:	5f435350 45534552 44455652 53500033     PSC_RESERVED3.PS
    2d00:	43535f43 30465f52 43535000 5243535f     C_SCR_F0.PSC_SCR
    2d10:	0031465f 5f435350 5f524353 50003246     _F1.PSC_SCR_F2.P
    2d20:	535f4353 465f5243 53500036 43535f43     SC_SCR_F6.PSC_SC
    2d30:	37465f52 43535000 5243535f 0038465f     R_F7.PSC_SCR_F8.
    2d40:	5f435350 465f5242 53500037 4e4f5f43     PSC_BR_F7.PSC_ON
    2d50:	4948435f 41525f50 5350004d 54535f43     _CHIP_RAM.PSC_ST
    2d60:	5f455441 525f5753 445f5453 42415349     ATE_SW_RST_DISAB
    2d70:	5000454c 535f4353 45544154 4e59535f     LE.PSC_STATE_SYN
    2d80:	45525f43 00544553 5f435350 54415453     C_RESET.PSC_STAT
    2d90:	49445f45 4c424153 53500045 54535f43     E_DISABLE.PSC_ST
    2da0:	5f455441 42414e45 5000454c 535f4353     ATE_ENABLE.PSC_S
    2db0:	45544154 5f4e495f 4e415254 49544953     TATE_IN_TRANSITI
    2dc0:	00004e4f                                ON..

00002dc4 <CSWTCH.3>:
    2dc4:	00000000 00000001 00000002 00000003     ................

00002dd4 <CSWTCH.6>:
    2dd4:	03020100                                ....

00002dd8 <CSWTCH.1>:
    2dd8:	00000008 00000018 00000028 00000038     ........(...8...

00002de8 <CSWTCH.6>:
    2de8:	00000000 00000001 00000002 09554d4d     ............MMU.
    2df8:	6f79614c 65527475 203d0976 58257830     LayoutRev.= 0x%X
    2e08:	5009000a 4e747261 65626d75 203d0972     ...PartNumber.= 
    2e18:	58257830 4109000a 69686372 74636574     0x%X...Architect
    2e28:	09657275 7830203d 000a5825 65705309     ure.= 0x%X...Spe
    2e38:	76655263 3d092020 25783020 09000a58     cRev  .= 0x%X...
    2e48:	6c706d49 6e656d65 09726574 7830203d     Implementer.= 0x
    2e58:	000a5825 09554d4d 6e656c49 30203d09     %X..MMU.Ilen.= 0
    2e68:	0a582578 4d490900 30203d09 0a582578     x%X...IM.= 0x%X.
    2e78:	61490900 636f7373 30203d09 0a582578     ..Iassoc.= 0x%X.
    2e88:	73490900 09657a69 7830203d 000a5825     ..Isize.= 0x%X..
    2e98:	656c4409 203d096e 58257830 4409000a     .Dlen.= 0x%X...D
    2ea8:	203d094d 58257830 4409000a 6f737361     M.= 0x%X...Dasso
    2eb8:	203d0963 58257830 4409000a 657a6973     c.= 0x%X...Dsize
    2ec8:	30203d09 0a582578 09530900 7830203d     .= 0x%X...S.= 0x
    2ed8:	000a5825 79746309 3d096570 25783020     %X...ctype.= 0x%
    2ee8:	4d000a58 4409554d 68636143 69532065     X..MMU.DCache Si
    2ef8:	2020657a 09202020 6425203d 0a424b20     ze     .= %d KB.
    2f08:	43440900 65686361 6e694c20 656c2065     ..DCache Line le
    2f18:	6874676e 25203d09 79622064 0a736574     ngth.= %d bytes.
    2f28:	43440900 65686361 73736120 6169636f     ..DCache associa
    2f38:	69766974 3d097974 2d642520 0a796177     tivity.= %d-way.
    2f48:	43490900 65686361 7a695320 20202065     ..ICache Size   
    2f58:	3d092020 20642520 000a424b 61434909       .= %d KB...ICa
    2f68:	20656863 656e694c 6e656c20 09687467     che Line length.
    2f78:	6425203d 74796220 000a7365 61434909     = %d bytes...ICa
    2f88:	20656863 6f737361 74616963 74697669     che associativit
    2f98:	203d0979 772d6425 000a7961 42440a0d     y.= %d-way....DB
    2fa8:	73253a47 5d64255b 0d203d20 2500090a     G:%s[%d] = ....%
    2fb8:	2058322e 440a0d00 253a4742 20292873     .2X ...DBG:%s() 
    2fc8:	0964254c 3d732500 30006425 34333231     L%d..%s=%d.01234
    2fd8:	38373635 43424139 00464544 4c554e3c     56789ABCDEF.<NUL
    2fe8:	28003e4c 6c6c756e 00000029 00000000     L>.(null).......
    2ff8:	00000000 00000000                       ........

00003000 <psc_kv>:
    3000:	00000000 00002b4b 00000001 00002b5a     ....K+......Z+..
    3010:	00000002 00002b69 00000003 00002b78     ....i+......x+..
    3020:	00000004 00002b82 00000005 00002b8b     .....+.......+..
    3030:	00000006 00002b97 00000007 00002ba4     .....+.......+..
    3040:	00000008 00002bb4 00000009 00002bc2     .....+.......+..
    3050:	0000000a 00002bcc 0000000b 00002bd5     .....+.......+..
    3060:	0000000c 00002bde 0000000d 00002be7     .....+.......+..
    3070:	0000000e 00002bef 0000000f 00002bf7     .....+.......+..
    3080:	00000020 00002c05 00000021 00002c14      ....,..!....,..
    3090:	00000022 00002c1d 00000023 00002c26     "....,..#...&,..
    30a0:	00000024 00002c2f 00000025 00002c37     $.../,..%...7,..
    30b0:	00000026 00002c40 00000027 00002c49     &...@,..'...I,..
    30c0:	00000028 00002c54 00000029 00002c5d     (...T,..)...],..
    30d0:	0000002a 00002c66 0000002b 00002c6f     *...f,..+...o,..
    30e0:	0000002c 00002c78 0000002d 00002c82     ,...x,..-....,..
    30f0:	0000002e 00002c8c 0000002f 00002c97     .....,../....,..
    3100:	00000030 00002ca2 00000031 00002cab     0....,..1....,..
    3110:	00000032 00002cb6 00000033 00002cc2     2....,..3....,..
    3120:	00000034 00002cca 00000035 00002cd3     4....,..5....,..
    3130:	00000036 00002ce2 00000037 00002cf0     6....,..7....,..
    3140:	00000038 00002cfe 00000039 00002d09     8....,..9....-..
    3150:	0000003a 00002d14 0000003b 00002d1f     :....-..;....-..
    3160:	0000003c 00002d2a 0000003d 00002d35     <...*-..=...5-..
    3170:	0000003e 00002d40 0000003f 00002d4a     >...@-..?...J-..

00003180 <state_kv>:
    3180:	00000000 00002d5a 00000001 00002d73     ....Z-......s-..
    3190:	00000002 00002d88 00000003 00002d9a     .....-.......-..
    31a0:	00000004 00002dab 00000000 00000000     .....-..........

000031b0 <__got_start>:
    31b0:	00000000 	.word	0x00000000
    31b4:	00000000 	.word	0x00000000
    31b8:	00000000 	.word	0x00000000
    31bc:	00003180 	.word	0x00003180
    31c0:	000031d0 	.word	0x000031d0
    31c4:	00003000 	.word	0x00003000
    31c8:	00000000 	.word	0x00000000
    31cc:	00000000 	.word	0x00000000
